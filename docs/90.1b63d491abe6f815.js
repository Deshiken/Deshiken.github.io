"use strict";(self.webpackChunkboard_game_helper=self.webpackChunkboard_game_helper||[]).push([[90],{8090:(qs,We,fe)=>{fe.r(We),fe.d(We,{default:()=>Ks});var Q=fe(5861),r=fe(4097),tt=fe(7562),it=Object.defineProperty,ne=(l,t,e)=>(((l,t,e)=>{t in l?it(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e})(l,"symbol"!=typeof t?t+"":t,e),e),Ie=(l,t,e)=>{if(!t.has(l))throw TypeError("Cannot "+e)},M=(l,t,e)=>(Ie(l,t,"read from private field"),e?e.call(l):t.get(l)),k=(l,t,e)=>{if(t.has(l))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(l):t.set(l,e)},H=(l,t,e,i)=>(Ie(l,t,"write to private field"),i?i.call(l,e):t.set(l,e),e),pe=(l,t,e,i)=>({set _(a){H(l,t,a,e)},get _(){return M(l,t,i)}});class Re{constructor(t){if(this._keys=[],this._isDirty=!0,this._areLightsDirty=!0,this._areLightsDisposed=!1,this._areAttributesDirty=!0,this._areTexturesDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!0,this._areImageProcessingDirty=!0,this._normals=!1,this._uvs=!1,this._needNormals=!1,this._needUVs=!1,this._externalProperties=t,t)for(const e in t)Object.prototype.hasOwnProperty.call(t,e)&&this._setDefaultValue(e)}get isDirty(){return this._isDirty}markAsProcessed(){this._isDirty=!1,this._areAttributesDirty=!1,this._areTexturesDirty=!1,this._areFresnelDirty=!1,this._areLightsDirty=!1,this._areLightsDisposed=!1,this._areMiscDirty=!1,this._arePrePassDirty=!1,this._areImageProcessingDirty=!1}markAsUnprocessed(){this._isDirty=!0}markAllAsDirty(){this._areTexturesDirty=!0,this._areAttributesDirty=!0,this._areLightsDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._areImageProcessingDirty=!0,this._isDirty=!0}markAsImageProcessingDirty(){this._areImageProcessingDirty=!0,this._isDirty=!0}markAsLightDirty(t=!1){this._areLightsDirty=!0,this._areLightsDisposed=this._areLightsDisposed||t,this._isDirty=!0}markAsAttributesDirty(){this._areAttributesDirty=!0,this._isDirty=!0}markAsTexturesDirty(){this._areTexturesDirty=!0,this._isDirty=!0}markAsFresnelDirty(){this._areFresnelDirty=!0,this._isDirty=!0}markAsMiscDirty(){this._areMiscDirty=!0,this._isDirty=!0}markAsPrePassDirty(){this._arePrePassDirty=!0,this._isDirty=!0}rebuild(){this._keys.length=0;for(const t of Object.keys(this))"_"!==t[0]&&this._keys.push(t);if(this._externalProperties)for(const t in this._externalProperties)-1===this._keys.indexOf(t)&&this._keys.push(t)}isEqual(t){if(this._keys.length!==t._keys.length)return!1;for(let e=0;e<this._keys.length;e++){const i=this._keys[e];if(this[i]!==t[i])return!1}return!0}cloneTo(t){this._keys.length!==t._keys.length&&(t._keys=this._keys.slice(0));for(let e=0;e<this._keys.length;e++){const i=this._keys[e];t[i]=this[i]}}reset(){this._keys.forEach(t=>this._setDefaultValue(t))}_setDefaultValue(t){var e,i,a,s,n;const o=null!==(a=null===(i=null===(e=this._externalProperties)||void 0===e?void 0:e[t])||void 0===i?void 0:i.type)&&void 0!==a?a:typeof this[t],c=null===(n=null===(s=this._externalProperties)||void 0===s?void 0:s[t])||void 0===n?void 0:n.default;switch(o){case"number":this[t]=c??0;break;case"string":this[t]=c??"";break;default:this[t]=c??!1}}toString(){let t="";for(let e=0;e<this._keys.length;e++){const i=this._keys[e],a=this[i];switch(typeof a){case"number":case"string":t+="#define "+i+" "+a+"\n";break;default:a&&(t+="#define "+i+"\n")}}return t}}class te{getDescription(){return""}apply(t,e){return!0}constructor(t=0){this.priority=t}}class be extends te{getDescription(){return"Reducing render target texture size to "+this.maximumSize}constructor(t=0,e=1024,i=.5){super(t),this.priority=t,this.maximumSize=e,this.step=i}apply(t,e){let i=!0;for(let a=0;a<t.textures.length;a++){const s=t.textures[a];if(!s.canRescale||s.getContext)continue;const n=s.getSize();Math.max(n.width,n.height)>this.maximumSize&&(s.scale(this.step),i=!1)}return i}}class ke extends te{getDescription(){return"Setting hardware scaling level to "+this._currentScale}constructor(t=0,e=2,i=.25){super(t),this.priority=t,this.maximumScale=e,this.step=i,this._currentScale=-1,this._directionOffset=1}apply(t,e){return-1===this._currentScale&&(this._currentScale=t.getEngine().getHardwareScalingLevel(),this._currentScale>this.maximumScale&&(this._directionOffset=-1)),this._currentScale+=this._directionOffset*this.step,t.getEngine().setHardwareScalingLevel(this._currentScale),1===this._directionOffset?this._currentScale>=this.maximumScale:this._currentScale<=this.maximumScale}}class Pe extends te{getDescription(){return"Turning shadows on/off"}apply(t,e){return t.shadowsEnabled=e.isInImprovementMode,!0}}class De extends te{getDescription(){return"Turning post-processes on/off"}apply(t,e){return t.postProcessesEnabled=e.isInImprovementMode,!0}}class Le extends te{getDescription(){return"Turning lens flares on/off"}apply(t,e){return t.lensFlaresEnabled=e.isInImprovementMode,!0}}class nt extends te{getDescription(){return this.onGetDescription?this.onGetDescription():"Running user defined callback"}apply(t,e){return!this.onApply||this.onApply(t,e)}}class we extends te{getDescription(){return"Turning particles on/off"}apply(t,e){return t.particlesEnabled=e.isInImprovementMode,!0}}class Ge extends te{getDescription(){return"Turning render targets off"}apply(t,e){return t.renderTargetsEnabled=e.isInImprovementMode,!0}}let Oe=(()=>{class l extends te{constructor(){super(...arguments),this._canBeMerged=e=>{if(!(e instanceof r.M))return!1;const i=e;return!(i.isDisposed()||!i.isVisible||!i.isEnabled()||i.instances.length>0||i.skeleton||i.hasLODLevels||0===i.getTotalVertices())}}static get UpdateSelectionTree(){return l._UpdateSelectionTree}static set UpdateSelectionTree(e){l._UpdateSelectionTree=e}getDescription(){return"Merging similar meshes together"}apply(e,i,a){const s=e.meshes.slice(0);let n=s.length;for(let c=0;c<n;c++){const h=new Array,d=s[c];if(this._canBeMerged(d)){h.push(d);for(let u=c+1;u<n;u++){const f=s[u];this._canBeMerged(f)&&f.material===d.material&&f.checkCollisions===d.checkCollisions&&(h.push(f),n--,s.splice(u,1),u--)}h.length<2||r.M.MergeMeshes(h,void 0,!0)}}const o=e;return o.createOrUpdateSelectionOctree&&(null!=a?a&&o.createOrUpdateSelectionOctree():l.UpdateSelectionTree&&o.createOrUpdateSelectionOctree()),!0}}return l._UpdateSelectionTree=!1,l})();class oe{constructor(t=60,e=2e3){this.targetFrameRate=t,this.trackerDuration=e,this.optimizations=new Array}addOptimization(t){return this.optimizations.push(t),this}addCustomOptimization(t,e,i=0){const a=new nt(i);return a.onApply=t,a.onGetDescription=e,this.optimizations.push(a),this}static LowDegradationAllowed(t){const e=new oe(t);let i=0;return e.addOptimization(new Oe(i)),e.addOptimization(new Pe(i)),e.addOptimization(new Le(i)),i++,e.addOptimization(new De(i)),e.addOptimization(new we(i)),i++,e.addOptimization(new be(i,1024)),e}static ModerateDegradationAllowed(t){const e=new oe(t);let i=0;return e.addOptimization(new Oe(i)),e.addOptimization(new Pe(i)),e.addOptimization(new Le(i)),i++,e.addOptimization(new De(i)),e.addOptimization(new we(i)),i++,e.addOptimization(new be(i,512)),i++,e.addOptimization(new Ge(i)),i++,e.addOptimization(new ke(i,2)),e}static HighDegradationAllowed(t){const e=new oe(t);let i=0;return e.addOptimization(new Oe(i)),e.addOptimization(new Pe(i)),e.addOptimization(new Le(i)),i++,e.addOptimization(new De(i)),e.addOptimization(new we(i)),i++,e.addOptimization(new be(i,256)),i++,e.addOptimization(new Ge(i)),i++,e.addOptimization(new ke(i,4)),e}}class Fe{get isInImprovementMode(){return this._improvementMode}set isInImprovementMode(t){this._improvementMode=t}get currentPriorityLevel(){return this._currentPriorityLevel}get currentFrameRate(){return this._currentFrameRate}get targetFrameRate(){return this._targetFrameRate}set targetFrameRate(t){this._targetFrameRate=t}get trackerDuration(){return this._trackerDuration}set trackerDuration(t){this._trackerDuration=t}get optimizations(){return this._options.optimizations}constructor(t,e,i=!0,a=!1){if(this._isRunning=!1,this._currentPriorityLevel=0,this._targetFrameRate=60,this._trackerDuration=2e3,this._currentFrameRate=0,this._improvementMode=!1,this.onSuccessObservable=new r.O,this.onNewOptimizationAppliedObservable=new r.O,this.onFailureObservable=new r.O,this._options=e||new oe,this._options.targetFrameRate&&(this._targetFrameRate=this._options.targetFrameRate),this._options.trackerDuration&&(this._trackerDuration=this._options.trackerDuration),i){let s=0;for(const n of this._options.optimizations)n.priority=s++}this._improvementMode=a,this._scene=t||r.a.LastCreatedScene,this._sceneDisposeObserver=this._scene.onDisposeObservable.add(()=>{this._sceneDisposeObserver=null,this.dispose()})}stop(){this._isRunning=!1}reset(){this._currentPriorityLevel=0}start(){this._isRunning||(this._isRunning=!0,this._scene.executeWhenReady(()=>{setTimeout(()=>{this._checkCurrentState()},this._trackerDuration)}))}_checkCurrentState(){if(!this._isRunning)return;const t=this._scene,e=this._options;if(this._currentFrameRate=Math.round(t.getEngine().getFps()),this._improvementMode&&this._currentFrameRate<=this._targetFrameRate||!this._improvementMode&&this._currentFrameRate>=this._targetFrameRate)return this._isRunning=!1,void this.onSuccessObservable.notifyObservers(this);let i=!0,a=!0;for(let s=0;s<e.optimizations.length;s++){const n=e.optimizations[s];n.priority===this._currentPriorityLevel&&(a=!1,i=i&&n.apply(t,this),this.onNewOptimizationAppliedObservable.notifyObservers(n))}if(a)return this._isRunning=!1,void this.onFailureObservable.notifyObservers(this);i&&this._currentPriorityLevel++,t.executeWhenReady(()=>{setTimeout(()=>{this._checkCurrentState()},this._trackerDuration)})}dispose(){this.stop(),this.onSuccessObservable.clear(),this.onFailureObservable.clear(),this.onNewOptimizationAppliedObservable.clear(),this._sceneDisposeObserver&&this._scene.onDisposeObservable.remove(this._sceneDisposeObserver)}static OptimizeAsync(t,e,i,a){const s=new Fe(t,e||oe.ModerateDegradationAllowed(),!1);return i&&s.onSuccessObservable.add(()=>{i()}),a&&s.onFailureObservable.add(()=>{a()}),s.start(),s}}class B extends r.c{constructor(t,e,i,a=!0){super(t,e,i,a),this._tmpUpVector=r.V.Zero(),this._tmpTargetVector=r.V.Zero(),this.cameraDirection=new r.V(0,0,0),this.cameraRotation=new r.d(0,0),this.ignoreParentScaling=!1,this.updateUpVectorFromRotation=!1,this._tmpQuaternion=new r.Q,this.rotation=new r.V(0,0,0),this.speed=2,this.noRotationConstraint=!1,this.invertRotation=!1,this.inverseRotationSpeed=.2,this.lockedTarget=null,this._currentTarget=r.V.Zero(),this._initialFocalDistance=1,this._viewMatrix=r.b.Zero(),this._camMatrix=r.b.Zero(),this._cameraTransformMatrix=r.b.Zero(),this._cameraRotationMatrix=r.b.Zero(),this._referencePoint=new r.V(0,0,1),this._transformedReferencePoint=r.V.Zero(),this._defaultUp=r.V.Up(),this._cachedRotationZ=0,this._cachedQuaternionRotationZ=0}getFrontPosition(t){this.getWorldMatrix();const e=this.getTarget().subtract(this.position);return e.normalize(),e.scaleInPlace(t),this.globalPosition.add(e)}_getLockedTargetPosition(){if(!this.lockedTarget)return null;if(this.lockedTarget.absolutePosition){const t=this.lockedTarget;t.computeWorldMatrix().getTranslationToRef(t.absolutePosition)}return this.lockedTarget.absolutePosition||this.lockedTarget}storeState(){return this._storedPosition=this.position.clone(),this._storedRotation=this.rotation.clone(),this.rotationQuaternion&&(this._storedRotationQuaternion=this.rotationQuaternion.clone()),super.storeState()}_restoreStateValues(){return!!super._restoreStateValues()&&(this.position=this._storedPosition.clone(),this.rotation=this._storedRotation.clone(),this.rotationQuaternion&&(this.rotationQuaternion=this._storedRotationQuaternion.clone()),this.cameraDirection.copyFromFloats(0,0,0),this.cameraRotation.copyFromFloats(0,0),!0)}_initCache(){super._initCache(),this._cache.lockedTarget=new r.V(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new r.V(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotationQuaternion=new r.Q(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}_updateCache(t){t||super._updateCache();const e=this._getLockedTargetPosition();e?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(e):this._cache.lockedTarget=e.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation),this.rotationQuaternion&&this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)}_isSynchronizedViewMatrix(){if(!super._isSynchronizedViewMatrix())return!1;const t=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(t):!t)&&(this.rotationQuaternion?this.rotationQuaternion.equals(this._cache.rotationQuaternion):this._cache.rotation.equals(this.rotation))}_computeLocalCameraSpeed(){const t=this.getEngine();return this.speed*Math.sqrt(t.getDeltaTime()/(100*t.getFps()))}setTarget(t){this.upVector.normalize(),this._initialFocalDistance=t.subtract(this.position).length(),this.position.z===t.z&&(this.position.z+=r.e),this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance),r.b.LookAtLHToRef(this.position,t,this._defaultUp,this._camMatrix),this._camMatrix.invert(),this.rotation.x=Math.atan(this._camMatrix.m[6]/this._camMatrix.m[10]);const e=t.subtract(this.position);this.rotation.y=e.x>=0?-Math.atan(e.z/e.x)+Math.PI/2:-Math.atan(e.z/e.x)-Math.PI/2,this.rotation.z=0,isNaN(this.rotation.x)&&(this.rotation.x=0),isNaN(this.rotation.y)&&(this.rotation.y=0),isNaN(this.rotation.z)&&(this.rotation.z=0),this.rotationQuaternion&&r.Q.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this.rotationQuaternion)}get target(){return this.getTarget()}set target(t){this.setTarget(t)}getTarget(){return this._currentTarget}_decideIfNeedsToMove(){return Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){if(this.parent)return this.parent.getWorldMatrix().invertToRef(r.T.Matrix[0]),r.V.TransformNormalToRef(this.cameraDirection,r.T.Matrix[0],r.T.Vector3[0]),void this.position.addInPlace(r.T.Vector3[0]);this.position.addInPlace(this.cameraDirection)}_checkInputs(){const t=this.invertRotation?-this.inverseRotationSpeed:1,e=this._decideIfNeedsToMove(),i=Math.abs(this.cameraRotation.x)>0||Math.abs(this.cameraRotation.y)>0;e&&this._updatePosition(),i&&(this.rotationQuaternion&&this.rotationQuaternion.toEulerAnglesToRef(this.rotation),this.rotation.x+=this.cameraRotation.x*t,this.rotation.y+=this.cameraRotation.y*t,this.noRotationConstraint||(this.rotation.x>1.570796&&(this.rotation.x=1.570796),this.rotation.x<-1.570796&&(this.rotation.x=-1.570796)),this.rotationQuaternion&&this.rotation.lengthSquared()&&r.Q.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this.rotationQuaternion)),e&&(Math.abs(this.cameraDirection.x)<this.speed*r.e&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<this.speed*r.e&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<this.speed*r.e&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),i&&(Math.abs(this.cameraRotation.x)<this.speed*r.e&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<this.speed*r.e&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia)),super._checkInputs()}_updateCameraRotationMatrix(){this.rotationQuaternion?this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix):r.b.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix)}_rotateUpVectorWithCameraRotationMatrix(){return r.V.TransformNormalToRef(this._defaultUp,this._cameraRotationMatrix,this.upVector),this}_getViewMatrix(){return this.lockedTarget&&this.setTarget(this._getLockedTargetPosition()),this._updateCameraRotationMatrix(),this.rotationQuaternion&&this._cachedQuaternionRotationZ!=this.rotationQuaternion.z?(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedQuaternionRotationZ=this.rotationQuaternion.z):this._cachedRotationZ!==this.rotation.z&&(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedRotationZ=this.rotation.z),r.V.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),this.updateUpVectorFromRotation&&(this.rotationQuaternion?r.A.Y.rotateByQuaternionToRef(this.rotationQuaternion,this.upVector):(r.Q.FromEulerVectorToRef(this.rotation,this._tmpQuaternion),r.A.Y.rotateByQuaternionToRef(this._tmpQuaternion,this.upVector))),this._computeViewMatrix(this.position,this._currentTarget,this.upVector),this._viewMatrix}_computeViewMatrix(t,e,i){if(this.ignoreParentScaling){if(this.parent){const a=this.parent.getWorldMatrix();r.V.TransformCoordinatesToRef(t,a,this._globalPosition),r.V.TransformCoordinatesToRef(e,a,this._tmpTargetVector),r.V.TransformNormalToRef(i,a,this._tmpUpVector),this._markSyncedWithParent()}else this._globalPosition.copyFrom(t),this._tmpTargetVector.copyFrom(e),this._tmpUpVector.copyFrom(i);this.getScene().useRightHandedSystem?r.b.LookAtRHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix):r.b.LookAtLHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix)}else if(this.getScene().useRightHandedSystem?r.b.LookAtRHToRef(t,e,i,this._viewMatrix):r.b.LookAtLHToRef(t,e,i,this._viewMatrix),this.parent){const a=this.parent.getWorldMatrix();this._viewMatrix.invert(),this._viewMatrix.multiplyToRef(a,this._viewMatrix),this._viewMatrix.getTranslationToRef(this._globalPosition),this._viewMatrix.invert(),this._markSyncedWithParent()}else this._globalPosition.copyFrom(t)}createRigCamera(t,e){if(this.cameraRigMode!==r.c.RIG_MODE_NONE){const i=new B(t,this.position.clone(),this.getScene());return i.isRigCamera=!0,i.rigParent=this,(this.cameraRigMode===r.c.RIG_MODE_VR||this.cameraRigMode===r.c.RIG_MODE_WEBVR)&&(this.rotationQuaternion||(this.rotationQuaternion=new r.Q),i._cameraRigParams={},i.rotationQuaternion=new r.Q),i.mode=this.mode,i.orthoLeft=this.orthoLeft,i.orthoRight=this.orthoRight,i.orthoTop=this.orthoTop,i.orthoBottom=this.orthoBottom,i}return null}_updateRigCameras(){const t=this._rigCameras[0],e=this._rigCameras[1];switch(this.computeWorldMatrix(),this.cameraRigMode){case r.c.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case r.c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case r.c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:case r.c.RIG_MODE_STEREOSCOPIC_OVERUNDER:case r.c.RIG_MODE_STEREOSCOPIC_INTERLACED:{const a=this.cameraRigMode===r.c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?-1:1;this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*(this.cameraRigMode===r.c.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?1:-1),t),this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*a,e);break}case r.c.RIG_MODE_VR:t.rotationQuaternion?(t.rotationQuaternion.copyFrom(this.rotationQuaternion),e.rotationQuaternion.copyFrom(this.rotationQuaternion)):(t.rotation.copyFrom(this.rotation),e.rotation.copyFrom(this.rotation)),t.position.copyFrom(this.position),e.position.copyFrom(this.position)}super._updateRigCameras()}_getRigCamPositionAndTarget(t,e){this.getTarget().subtractToRef(this.position,B._TargetFocalPoint),B._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);const i=B._TargetFocalPoint.addInPlace(this.position);r.b.TranslationToRef(-i.x,-i.y,-i.z,B._TargetTransformMatrix),B._TargetTransformMatrix.multiplyToRef(r.b.RotationAxis(e.upVector,t),B._RigCamTransformMatrix),r.b.TranslationToRef(i.x,i.y,i.z,B._TargetTransformMatrix),B._RigCamTransformMatrix.multiplyToRef(B._TargetTransformMatrix,B._RigCamTransformMatrix),r.V.TransformCoordinatesToRef(this.position,B._RigCamTransformMatrix,e.position),e.setTarget(i)}getClassName(){return"TargetCamera"}}B._RigCamTransformMatrix=new r.b,B._TargetTransformMatrix=new r.b,B._TargetFocalPoint=new r.V,(0,r._)([(0,r.s)()],B.prototype,"rotation",void 0),(0,r._)([(0,r.f)()],B.prototype,"speed",void 0),(0,r._)([(0,r.g)("lockedTargetId")],B.prototype,"lockedTarget",void 0);class A extends r.N{get range(){return this._range}set range(t){this._range=t,this._inverseSquaredRange=1/(this.range*this.range)}get intensityMode(){return this._intensityMode}set intensityMode(t){this._intensityMode=t,this._computePhotometricScale()}get radius(){return this._radius}set radius(t){this._radius=t,this._computePhotometricScale()}get shadowEnabled(){return this._shadowEnabled}set shadowEnabled(t){this._shadowEnabled!==t&&(this._shadowEnabled=t,this._markMeshesAsLightDirty())}get includedOnlyMeshes(){return this._includedOnlyMeshes}set includedOnlyMeshes(t){this._includedOnlyMeshes=t,this._hookArrayForIncludedOnly(t)}get excludedMeshes(){return this._excludedMeshes}set excludedMeshes(t){this._excludedMeshes=t,this._hookArrayForExcluded(t)}get excludeWithLayerMask(){return this._excludeWithLayerMask}set excludeWithLayerMask(t){this._excludeWithLayerMask=t,this._resyncMeshes()}get includeOnlyWithLayerMask(){return this._includeOnlyWithLayerMask}set includeOnlyWithLayerMask(t){this._includeOnlyWithLayerMask=t,this._resyncMeshes()}get lightmapMode(){return this._lightmapMode}set lightmapMode(t){this._lightmapMode!==t&&(this._lightmapMode=t,this._markMeshesAsLightDirty())}constructor(t,e){super(t,e),this.diffuse=new r.h(1,1,1),this.specular=new r.h(1,1,1),this.falloffType=A.FALLOFF_DEFAULT,this.intensity=1,this._range=Number.MAX_VALUE,this._inverseSquaredRange=0,this._photometricScale=1,this._intensityMode=A.INTENSITYMODE_AUTOMATIC,this._radius=1e-5,this.renderPriority=0,this._shadowEnabled=!0,this._excludeWithLayerMask=0,this._includeOnlyWithLayerMask=0,this._lightmapMode=0,this._shadowGenerators=null,this._excludedMeshesIds=new Array,this._includedOnlyMeshesIds=new Array,this._isLight=!0,this.getScene().addLight(this),this._uniformBuffer=new r.U(this.getScene().getEngine(),void 0,void 0,t),this._buildUniformLayout(),this.includedOnlyMeshes=new Array,this.excludedMeshes=new Array,this._resyncMeshes()}transferTexturesToEffect(t,e){return this}_bindLight(t,e,i,a,s=!0){var n;const o=t.toString();let c=!1;if(this._uniformBuffer.bindToEffect(i,"Light"+o),this._renderId!==e.getRenderId()||this._lastUseSpecular!==a||!this._uniformBuffer.useUbo){this._renderId=e.getRenderId(),this._lastUseSpecular=a;const h=this.getScaledIntensity();this.transferToEffect(i,o),this.diffuse.scaleToRef(h,r.i.Color3[0]),this._uniformBuffer.updateColor4("vLightDiffuse",r.i.Color3[0],this.range,o),a&&(this.specular.scaleToRef(h,r.i.Color3[1]),this._uniformBuffer.updateColor4("vLightSpecular",r.i.Color3[1],this.radius,o)),c=!0}if(this.transferTexturesToEffect(i,o),e.shadowsEnabled&&this.shadowEnabled&&s){const h=null!==(n=this.getShadowGenerator(e.activeCamera))&&void 0!==n?n:this.getShadowGenerator();h&&(h.bindShadowLight(o,i),c=!0)}c?this._uniformBuffer.update():this._uniformBuffer.bindUniformBuffer()}getClassName(){return"Light"}toString(t){let e="Name: "+this.name;if(e+=", type: "+["Point","Directional","Spot","Hemispheric"][this.getTypeID()],this.animations)for(let i=0;i<this.animations.length;i++)e+=", animation[0]: "+this.animations[i].toString(t);return e}_syncParentEnabledState(){super._syncParentEnabledState(),this.isDisposed()||this._resyncMeshes()}setEnabled(t){super.setEnabled(t),this._resyncMeshes()}getShadowGenerator(t=null){var e;return null===this._shadowGenerators?null:null!==(e=this._shadowGenerators.get(t))&&void 0!==e?e:null}getShadowGenerators(){return this._shadowGenerators}getAbsolutePosition(){return r.V.Zero()}canAffectMesh(t){return!t||!(this.includedOnlyMeshes&&this.includedOnlyMeshes.length>0&&-1===this.includedOnlyMeshes.indexOf(t)||this.excludedMeshes&&this.excludedMeshes.length>0&&-1!==this.excludedMeshes.indexOf(t)||0!==this.includeOnlyWithLayerMask&&!(this.includeOnlyWithLayerMask&t.layerMask)||0!==this.excludeWithLayerMask&&this.excludeWithLayerMask&t.layerMask)}dispose(t,e=!1){if(this._shadowGenerators){const i=this._shadowGenerators.values();for(let a=i.next();!0!==a.done;a=i.next())a.value.dispose();this._shadowGenerators=null}if(this.getScene().stopAnimation(this),this._parentContainer){const i=this._parentContainer.lights.indexOf(this);i>-1&&this._parentContainer.lights.splice(i,1),this._parentContainer=null}for(const i of this.getScene().meshes)i._removeLightSource(this,!0);this._uniformBuffer.dispose(),this.getScene().removeLight(this),super.dispose(t,e)}getTypeID(){return 0}getScaledIntensity(){return this._photometricScale*this.intensity}clone(t,e=null){const i=A.GetConstructorFromName(this.getTypeID(),t,this.getScene());if(!i)return null;const a=r.j.Clone(i,this);return t&&(a.name=t),e&&(a.parent=e),a.setEnabled(this.isEnabled()),this.onClonedObservable.notifyObservers(a),a}serialize(){const t=r.j.Serialize(this);return t.uniqueId=this.uniqueId,t.type=this.getTypeID(),this.parent&&this.parent._serializeAsParent(t),this.excludedMeshes.length>0&&(t.excludedMeshesIds=[],this.excludedMeshes.forEach(e=>{t.excludedMeshesIds.push(e.id)})),this.includedOnlyMeshes.length>0&&(t.includedOnlyMeshesIds=[],this.includedOnlyMeshes.forEach(e=>{t.includedOnlyMeshesIds.push(e.id)})),r.j.AppendSerializedAnimations(this,t),t.ranges=this.serializeAnimationRanges(),t.isEnabled=this.isEnabled(),t}static GetConstructorFromName(t,e,i){return r.N.Construct("Light_Type_"+t,e,i)||null}static Parse(t,e){const i=A.GetConstructorFromName(t.type,t.name,e);if(!i)return null;const a=r.j.Parse(i,t,e);if(t.excludedMeshesIds&&(a._excludedMeshesIds=t.excludedMeshesIds),t.includedOnlyMeshesIds&&(a._includedOnlyMeshesIds=t.includedOnlyMeshesIds),void 0!==t.parentId&&(a._waitingParentId=t.parentId),void 0!==t.parentInstanceIndex&&(a._waitingParentInstanceIndex=t.parentInstanceIndex),void 0!==t.falloffType&&(a.falloffType=t.falloffType),void 0!==t.lightmapMode&&(a.lightmapMode=t.lightmapMode),t.animations){for(let s=0;s<t.animations.length;s++){const n=t.animations[s],o=(0,r.G)("BABYLON.Animation");o&&a.animations.push(o.Parse(n))}r.N.ParseAnimationRanges(a,t,e)}return t.autoAnimate&&e.beginAnimation(a,t.autoAnimateFrom,t.autoAnimateTo,t.autoAnimateLoop,t.autoAnimateSpeed||1),void 0!==t.isEnabled&&a.setEnabled(t.isEnabled),a}_hookArrayForExcluded(t){const e=t.push;t.push=(...a)=>{const s=e.apply(t,a);for(const n of a)n._resyncLightSource(this);return s};const i=t.splice;t.splice=(a,s)=>{const n=i.apply(t,[a,s]);for(const o of n)o._resyncLightSource(this);return n};for(const a of t)a._resyncLightSource(this)}_hookArrayForIncludedOnly(t){const e=t.push;t.push=(...a)=>{const s=e.apply(t,a);return this._resyncMeshes(),s};const i=t.splice;t.splice=(a,s)=>{const n=i.apply(t,[a,s]);return this._resyncMeshes(),n},this._resyncMeshes()}_resyncMeshes(){for(const t of this.getScene().meshes)t._resyncLightSource(this)}_markMeshesAsLightDirty(){for(const t of this.getScene().meshes)-1!==t.lightSources.indexOf(this)&&t._markSubMeshesAsLightDirty()}_computePhotometricScale(){this._photometricScale=this._getPhotometricScale(),this.getScene().resetCachedMaterial()}_getPhotometricScale(){let t=0;const e=this.getTypeID();let i=this.intensityMode;switch(i===A.INTENSITYMODE_AUTOMATIC&&(i=e===A.LIGHTTYPEID_DIRECTIONALLIGHT?A.INTENSITYMODE_ILLUMINANCE:A.INTENSITYMODE_LUMINOUSINTENSITY),e){case A.LIGHTTYPEID_POINTLIGHT:case A.LIGHTTYPEID_SPOTLIGHT:switch(i){case A.INTENSITYMODE_LUMINOUSPOWER:t=1/(4*Math.PI);break;case A.INTENSITYMODE_LUMINOUSINTENSITY:t=1;break;case A.INTENSITYMODE_LUMINANCE:t=this.radius*this.radius}break;case A.LIGHTTYPEID_DIRECTIONALLIGHT:switch(i){case A.INTENSITYMODE_ILLUMINANCE:t=1;break;case A.INTENSITYMODE_LUMINANCE:{let a=this.radius;a=Math.max(a,.001),t=2*Math.PI*(1-Math.cos(a));break}}break;case A.LIGHTTYPEID_HEMISPHERICLIGHT:t=1}return t}_reorderLightsInScene(){const t=this.getScene();0!=this._renderPriority&&(t.requireLightSorting=!0),this.getScene().sortLightsByPriority()}}A.FALLOFF_DEFAULT=r.L.FALLOFF_DEFAULT,A.FALLOFF_PHYSICAL=r.L.FALLOFF_PHYSICAL,A.FALLOFF_GLTF=r.L.FALLOFF_GLTF,A.FALLOFF_STANDARD=r.L.FALLOFF_STANDARD,A.LIGHTMAP_DEFAULT=r.L.LIGHTMAP_DEFAULT,A.LIGHTMAP_SPECULAR=r.L.LIGHTMAP_SPECULAR,A.LIGHTMAP_SHADOWSONLY=r.L.LIGHTMAP_SHADOWSONLY,A.INTENSITYMODE_AUTOMATIC=r.L.INTENSITYMODE_AUTOMATIC,A.INTENSITYMODE_LUMINOUSPOWER=r.L.INTENSITYMODE_LUMINOUSPOWER,A.INTENSITYMODE_LUMINOUSINTENSITY=r.L.INTENSITYMODE_LUMINOUSINTENSITY,A.INTENSITYMODE_ILLUMINANCE=r.L.INTENSITYMODE_ILLUMINANCE,A.INTENSITYMODE_LUMINANCE=r.L.INTENSITYMODE_LUMINANCE,A.LIGHTTYPEID_POINTLIGHT=r.L.LIGHTTYPEID_POINTLIGHT,A.LIGHTTYPEID_DIRECTIONALLIGHT=r.L.LIGHTTYPEID_DIRECTIONALLIGHT,A.LIGHTTYPEID_SPOTLIGHT=r.L.LIGHTTYPEID_SPOTLIGHT,A.LIGHTTYPEID_HEMISPHERICLIGHT=r.L.LIGHTTYPEID_HEMISPHERICLIGHT,(0,r._)([(0,r.k)()],A.prototype,"diffuse",void 0),(0,r._)([(0,r.k)()],A.prototype,"specular",void 0),(0,r._)([(0,r.f)()],A.prototype,"falloffType",void 0),(0,r._)([(0,r.f)()],A.prototype,"intensity",void 0),(0,r._)([(0,r.f)()],A.prototype,"range",null),(0,r._)([(0,r.f)()],A.prototype,"intensityMode",null),(0,r._)([(0,r.f)()],A.prototype,"radius",null),(0,r._)([(0,r.f)()],A.prototype,"_renderPriority",void 0),(0,r._)([(0,r.l)("_reorderLightsInScene")],A.prototype,"renderPriority",void 0),(0,r._)([(0,r.f)("shadowEnabled")],A.prototype,"_shadowEnabled",void 0),(0,r._)([(0,r.f)("excludeWithLayerMask")],A.prototype,"_excludeWithLayerMask",void 0),(0,r._)([(0,r.f)("includeOnlyWithLayerMask")],A.prototype,"_includeOnlyWithLayerMask",void 0),(0,r._)([(0,r.f)("lightmapMode")],A.prototype,"_lightmapMode",void 0);class _e extends A{constructor(){super(...arguments),this._needProjectionMatrixCompute=!0}_setPosition(t){this._position=t}get position(){return this._position}set position(t){this._setPosition(t)}_setDirection(t){this._direction=t}get direction(){return this._direction}set direction(t){this._setDirection(t)}get shadowMinZ(){return this._shadowMinZ}set shadowMinZ(t){this._shadowMinZ=t,this.forceProjectionMatrixCompute()}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(t){this._shadowMaxZ=t,this.forceProjectionMatrixCompute()}computeTransformedInformation(){return!(!this.parent||!this.parent.getWorldMatrix||(this.transformedPosition||(this.transformedPosition=r.V.Zero()),r.V.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this.transformedPosition),this.direction&&(this.transformedDirection||(this.transformedDirection=r.V.Zero()),r.V.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this.transformedDirection)),0))}getDepthScale(){return 50}getShadowDirection(t){return this.transformedDirection?this.transformedDirection:this.direction}getAbsolutePosition(){return this.transformedPosition?this.transformedPosition:this.position}setDirectionToTarget(t){return this.direction=r.V.Normalize(t.subtract(this.position)),this.direction}getRotation(){this.direction.normalize();const t=r.V.Cross(this.direction,r.A.Y),e=r.V.Cross(t,this.direction);return r.V.RotationFromAxis(t,e,this.direction)}needCube(){return!1}needProjectionMatrixCompute(){return this._needProjectionMatrixCompute}forceProjectionMatrixCompute(){this._needProjectionMatrixCompute=!0}_initCache(){super._initCache(),this._cache.position=r.V.Zero()}_isSynchronized(){return!!this._cache.position.equals(this.position)}computeWorldMatrix(t){return!t&&this.isSynchronized()?(this._currentRenderId=this.getScene().getRenderId(),this._worldMatrix):(this._updateCache(),this._cache.position.copyFrom(this.position),this._worldMatrix||(this._worldMatrix=r.b.Identity()),r.b.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this.parent&&this.parent.getWorldMatrix&&(this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix),this._markSyncedWithParent()),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix)}getDepthMinZ(t){return void 0!==this.shadowMinZ?this.shadowMinZ:t.minZ}getDepthMaxZ(t){return void 0!==this.shadowMaxZ?this.shadowMaxZ:t.maxZ}setShadowProjectionMatrix(t,e,i){return this.customProjectionMatrixBuilder?this.customProjectionMatrixBuilder(e,i,t):this._setDefaultShadowProjectionMatrix(t,e,i),this}_syncParentEnabledState(){super._syncParentEnabledState(),(!this.parent||!this.parent.getWorldMatrix)&&(this.transformedPosition=null,this.transformedDirection=null)}}(0,r._)([(0,r.s)()],_e.prototype,"position",null),(0,r._)([(0,r.s)()],_e.prototype,"direction",null),(0,r._)([(0,r.f)()],_e.prototype,"shadowMinZ",null),(0,r._)([(0,r.f)()],_e.prototype,"shadowMaxZ",null),r.N.AddNodeConstructor("Light_Type_1",(l,t)=>()=>new $(l,r.V.Zero(),t));class $ extends _e{get shadowFrustumSize(){return this._shadowFrustumSize}set shadowFrustumSize(t){this._shadowFrustumSize=t,this.forceProjectionMatrixCompute()}get shadowOrthoScale(){return this._shadowOrthoScale}set shadowOrthoScale(t){this._shadowOrthoScale=t,this.forceProjectionMatrixCompute()}get orthoLeft(){return this._orthoLeft}set orthoLeft(t){this._orthoLeft=t}get orthoRight(){return this._orthoRight}set orthoRight(t){this._orthoRight=t}get orthoTop(){return this._orthoTop}set orthoTop(t){this._orthoTop=t}get orthoBottom(){return this._orthoBottom}set orthoBottom(t){this._orthoBottom=t}constructor(t,e,i){super(t,i),this._shadowFrustumSize=0,this._shadowOrthoScale=.1,this.autoUpdateExtends=!0,this.autoCalcShadowZBounds=!1,this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE,this.position=e.scale(-1),this.direction=e}getClassName(){return"DirectionalLight"}getTypeID(){return A.LIGHTTYPEID_DIRECTIONALLIGHT}_setDefaultShadowProjectionMatrix(t,e,i){this.shadowFrustumSize>0?this._setDefaultFixedFrustumShadowProjectionMatrix(t):this._setDefaultAutoExtendShadowProjectionMatrix(t,e,i)}_setDefaultFixedFrustumShadowProjectionMatrix(t){const e=this.getScene().activeCamera;e&&r.b.OrthoLHToRef(this.shadowFrustumSize,this.shadowFrustumSize,void 0!==this.shadowMinZ?this.shadowMinZ:e.minZ,void 0!==this.shadowMaxZ?this.shadowMaxZ:e.maxZ,t,this.getScene().getEngine().isNDCHalfZRange)}_setDefaultAutoExtendShadowProjectionMatrix(t,e,i){const a=this.getScene().activeCamera;if(!a)return;if(this.autoUpdateExtends||this._orthoLeft===Number.MAX_VALUE){const d=r.V.Zero();this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE;let u=Number.MAX_VALUE,f=Number.MIN_VALUE;for(let p=0;p<i.length;p++){const m=i[p];if(!m)continue;const S=m.getBoundingInfo().boundingBox;for(let _=0;_<S.vectorsWorld.length;_++)r.V.TransformCoordinatesToRef(S.vectorsWorld[_],e,d),d.x<this._orthoLeft&&(this._orthoLeft=d.x),d.y<this._orthoBottom&&(this._orthoBottom=d.y),d.x>this._orthoRight&&(this._orthoRight=d.x),d.y>this._orthoTop&&(this._orthoTop=d.y),this.autoCalcShadowZBounds&&(d.z<u&&(u=d.z),d.z>f&&(f=d.z))}this.autoCalcShadowZBounds&&(this._shadowMinZ=u,this._shadowMaxZ=f)}const s=this._orthoRight-this._orthoLeft,n=this._orthoTop-this._orthoBottom,o=void 0!==this.shadowMinZ?this.shadowMinZ:a.minZ,c=void 0!==this.shadowMaxZ?this.shadowMaxZ:a.maxZ,h=this.getScene().getEngine().useReverseDepthBuffer;r.b.OrthoOffCenterLHToRef(this._orthoLeft-s*this.shadowOrthoScale,this._orthoRight+s*this.shadowOrthoScale,this._orthoBottom-n*this.shadowOrthoScale,this._orthoTop+n*this.shadowOrthoScale,h?c:o,h?o:c,t,this.getScene().getEngine().isNDCHalfZRange)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(t,e){return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z,1,e),this):(this._uniformBuffer.updateFloat4("vLightData",this.direction.x,this.direction.y,this.direction.z,1,e),this)}transferToNodeMaterialEffect(t,e){return this.computeTransformedInformation()?(t.setFloat3(e,this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z),this):(t.setFloat3(e,this.direction.x,this.direction.y,this.direction.z),this)}getDepthMinZ(t){const e=this._scene.getEngine();return!e.useReverseDepthBuffer&&e.isNDCHalfZRange?0:1}getDepthMaxZ(t){const e=this._scene.getEngine();return e.useReverseDepthBuffer&&e.isNDCHalfZRange?0:1}prepareLightSpecificDefines(t,e){t["DIRLIGHT"+e]=!0}}(0,r._)([(0,r.f)()],$.prototype,"shadowFrustumSize",null),(0,r._)([(0,r.f)()],$.prototype,"shadowOrthoScale",null),(0,r._)([(0,r.f)()],$.prototype,"autoUpdateExtends",void 0),(0,r._)([(0,r.f)()],$.prototype,"autoCalcShadowZBounds",void 0),(0,r._)([(0,r.f)("orthoLeft")],$.prototype,"_orthoLeft",void 0),(0,r._)([(0,r.f)("orthoRight")],$.prototype,"_orthoRight",void 0),(0,r._)([(0,r.f)("orthoTop")],$.prototype,"_orthoTop",void 0),(0,r._)([(0,r.f)("orthoBottom")],$.prototype,"_orthoBottom",void 0),r.N.AddNodeConstructor("Light_Type_3",(l,t)=>()=>new Se(l,r.V.Zero(),t));class Se extends A{constructor(t,e,i){super(t,i),this.groundColor=new r.h(0,0,0),this.direction=e||r.V.Up()}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightGround",3),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}getClassName(){return"HemisphericLight"}setDirectionToTarget(t){return this.direction=r.V.Normalize(t.subtract(r.V.Zero())),this.direction}getShadowGenerator(){return null}transferToEffect(t,e){const i=r.V.Normalize(this.direction);return this._uniformBuffer.updateFloat4("vLightData",i.x,i.y,i.z,0,e),this._uniformBuffer.updateColor3("vLightGround",this.groundColor.scale(this.intensity),e),this}transferToNodeMaterialEffect(t,e){const i=r.V.Normalize(this.direction);return t.setFloat3(e,i.x,i.y,i.z),this}computeWorldMatrix(){return this._worldMatrix||(this._worldMatrix=r.b.Identity()),this._worldMatrix}getTypeID(){return A.LIGHTTYPEID_HEMISPHERICLIGHT}prepareLightSpecificDefines(t,e){t["HEMILIGHT"+e]=!0}}(0,r._)([(0,r.k)()],Se.prototype,"groundColor",void 0),(0,r._)([(0,r.s)()],Se.prototype,"direction",void 0);class ie{constructor(t,e){this.width=t,this.height=e}toString(){return`{W: ${this.width}, H: ${this.height}}`}getClassName(){return"Size"}getHashCode(){let t=0|this.width;return t=397*t^(0|this.height),t}copyFrom(t){this.width=t.width,this.height=t.height}copyFromFloats(t,e){return this.width=t,this.height=e,this}set(t,e){return this.copyFromFloats(t,e)}multiplyByFloats(t,e){return new ie(this.width*t,this.height*e)}clone(){return new ie(this.width,this.height)}equals(t){return!!t&&this.width===t.width&&this.height===t.height}get surface(){return this.width*this.height}static Zero(){return new ie(0,0)}add(t){return new ie(this.width+t.width,this.height+t.height)}subtract(t){return new ie(this.width-t.width,this.height-t.height)}static Lerp(t,e,i){return new ie(t.width+(e.width-t.width)*i,t.height+(e.height-t.height)*i)}}class Ne{get wrapU(){return this._wrapU}set wrapU(t){this._wrapU=t}get wrapV(){return this._wrapV}set wrapV(t){this._wrapV=t}get coordinatesMode(){return 0}get isCube(){return!!this._texture&&this._texture.isCube}set isCube(t){this._texture&&(this._texture.isCube=t)}get is3D(){return!!this._texture&&this._texture.is3D}set is3D(t){this._texture&&(this._texture.is3D=t)}get is2DArray(){return!!this._texture&&this._texture.is2DArray}set is2DArray(t){this._texture&&(this._texture.is2DArray=t)}getClassName(){return"ThinTexture"}static _IsRenderTargetWrapper(t){return void 0!==t?._shareDepth}constructor(t){this._wrapU=1,this._wrapV=1,this.wrapR=1,this.anisotropicFilteringLevel=4,this.delayLoadState=0,this._texture=null,this._engine=null,this._cachedSize=ie.Zero(),this._cachedBaseSize=ie.Zero(),this._initialSamplingMode=2,this._texture=Ne._IsRenderTargetWrapper(t)?t.texture:t,this._texture&&(this._engine=this._texture.getEngine())}isReady(){return 4===this.delayLoadState?(this.delayLoad(),!1):!!this._texture&&this._texture.isReady}delayLoad(){}getInternalTexture(){return this._texture}getSize(){if(this._texture){if(this._texture.width)return this._cachedSize.width=this._texture.width,this._cachedSize.height=this._texture.height,this._cachedSize;if(this._texture._size)return this._cachedSize.width=this._texture._size,this._cachedSize.height=this._texture._size,this._cachedSize}return this._cachedSize}getBaseSize(){return this.isReady()&&this._texture?this._texture._size?(this._cachedBaseSize.width=this._texture._size,this._cachedBaseSize.height=this._texture._size,this._cachedBaseSize):(this._cachedBaseSize.width=this._texture.baseWidth,this._cachedBaseSize.height=this._texture.baseHeight,this._cachedBaseSize):(this._cachedBaseSize.width=0,this._cachedBaseSize.height=0,this._cachedBaseSize)}get samplingMode(){return this._texture?this._texture.samplingMode:this._initialSamplingMode}updateSamplingMode(t){this._texture&&this._engine&&this._engine.updateTextureSamplingMode(t,this._texture)}releaseInternalTexture(){this._texture&&(this._texture.dispose(),this._texture=null)}dispose(){this._texture&&(this.releaseInternalTexture(),this._engine=null)}}let O=(()=>{class l extends Ne{set hasAlpha(e){this._hasAlpha!==e&&(this._hasAlpha=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,i=>i.hasTexture(this)))}get hasAlpha(){return this._hasAlpha}set getAlphaFromRGB(e){this._getAlphaFromRGB!==e&&(this._getAlphaFromRGB=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,i=>i.hasTexture(this)))}get getAlphaFromRGB(){return this._getAlphaFromRGB}set coordinatesIndex(e){this._coordinatesIndex!==e&&(this._coordinatesIndex=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,i=>i.hasTexture(this)))}get coordinatesIndex(){return this._coordinatesIndex}set coordinatesMode(e){this._coordinatesMode!==e&&(this._coordinatesMode=e,this._scene&&this._scene.markAllMaterialsAsDirty(1,i=>i.hasTexture(this)))}get coordinatesMode(){return this._coordinatesMode}get wrapU(){return this._wrapU}set wrapU(e){this._wrapU=e}get wrapV(){return this._wrapV}set wrapV(e){this._wrapV=e}get isCube(){return this._texture?this._texture.isCube:this._isCube}set isCube(e){this._texture?this._texture.isCube=e:this._isCube=e}get is3D(){return!!this._texture&&this._texture.is3D}set is3D(e){this._texture&&(this._texture.is3D=e)}get is2DArray(){return!!this._texture&&this._texture.is2DArray}set is2DArray(e){this._texture&&(this._texture.is2DArray=e)}get gammaSpace(){return this._texture?(null===this._texture._gammaSpace&&(this._texture._gammaSpace=this._gammaSpace),this._texture._gammaSpace&&!this._texture._useSRGBBuffer):this._gammaSpace}set gammaSpace(e){if(this._texture){if(this._texture._gammaSpace===e)return;this._texture._gammaSpace=e}else{if(this._gammaSpace===e)return;this._gammaSpace=e}this._markAllSubMeshesAsTexturesDirty()}get isRGBD(){return null!=this._texture&&this._texture._isRGBD}set isRGBD(e){this._texture&&(this._texture._isRGBD=e)}get noMipmap(){return!1}get lodGenerationOffset(){return this._texture?this._texture._lodGenerationOffset:0}set lodGenerationOffset(e){this._texture&&(this._texture._lodGenerationOffset=e)}get lodGenerationScale(){return this._texture?this._texture._lodGenerationScale:0}set lodGenerationScale(e){this._texture&&(this._texture._lodGenerationScale=e)}get linearSpecularLOD(){return!!this._texture&&this._texture._linearSpecularLOD}set linearSpecularLOD(e){this._texture&&(this._texture._linearSpecularLOD=e)}get irradianceTexture(){return this._texture?this._texture._irradianceTexture:null}set irradianceTexture(e){this._texture&&(this._texture._irradianceTexture=e)}get uid(){return this._uid||(this._uid=(0,r.R)()),this._uid}toString(){return this.name}getClassName(){return"BaseTexture"}set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}get isBlocking(){return!0}get loadingError(){return this._loadingError}get errorObject(){return this._errorObject}constructor(e,i=null){super(null),this.metadata=null,this.reservedDataStore=null,this._hasAlpha=!1,this._getAlphaFromRGB=!1,this.level=1,this._coordinatesIndex=0,this.optimizeUVAllocation=!0,this._coordinatesMode=0,this.wrapR=1,this.anisotropicFilteringLevel=l.DEFAULT_ANISOTROPIC_FILTERING_LEVEL,this._isCube=!1,this._gammaSpace=!0,this.invertZ=!1,this.lodLevelInAlpha=!1,this.isRenderTarget=!1,this._prefiltered=!1,this._forceSerialize=!1,this.animations=new Array,this.onDisposeObservable=new r.O,this._onDisposeObserver=null,this._scene=null,this._uid=null,this._parentContainer=null,this._loadingError=!1,e?l._IsScene(e)?this._scene=e:this._engine=e:this._scene=r.a.LastCreatedScene,this._scene&&(this.uniqueId=this._scene.getUniqueId(),this._scene.addTexture(this),this._engine=this._scene.getEngine()),this._texture=i,this._uid=null}getScene(){return this._scene}_getEngine(){return this._engine}checkTransformsAreIdentical(e){return null!==e}getTextureMatrix(){return r.b.IdentityReadOnly}getReflectionTextureMatrix(){return r.b.IdentityReadOnly}isReadyOrNotBlocking(){return!this.isBlocking||this.isReady()||this.loadingError}scale(e){}get canRescale(){return!1}_getFromCache(e,i,a,s,n,o){const c=this._getEngine();if(!c)return null;const h=c._getUseSRGBBuffer(!!n,i),d=c.getLoadedTexturesCache();for(let u=0;u<d.length;u++){const f=d[u];if(!(void 0!==n&&h!==f._useSRGBBuffer||void 0!==s&&s!==f.invertY||f.url!==e||f.generateMipMaps!==!i||a&&a!==f.samplingMode||void 0!==o&&o!==f.isCube))return f.incrementReferences(),f}return null}_rebuild(){}clone(){return null}get textureType(){return this._texture&&void 0!==this._texture.type?this._texture.type:0}get textureFormat(){return this._texture&&void 0!==this._texture.format?this._texture.format:5}_markAllSubMeshesAsTexturesDirty(){const e=this.getScene();e&&e.markAllMaterialsAsDirty(1)}readPixels(e=0,i=0,a=null,s=!0,n=!1,o=0,c=0,h=Number.MAX_VALUE,d=Number.MAX_VALUE){if(!this._texture)return null;const u=this._getEngine();if(!u)return null;const f=this.getSize();let p=f.width,m=f.height;0!==i&&(p/=Math.pow(2,i),m/=Math.pow(2,i),p=Math.round(p),m=Math.round(m)),h=Math.min(p,h),d=Math.min(m,d);try{return u._readTexturePixels(this._texture,h,d,this._texture.isCube?e:-1,i,a,s,n,o,c)}catch{return null}}_readPixelsSync(e=0,i=0,a=null,s=!0,n=!1){if(!this._texture)return null;const o=this.getSize();let c=o.width,h=o.height;const d=this._getEngine();if(!d)return null;0!=i&&(c/=Math.pow(2,i),h/=Math.pow(2,i),c=Math.round(c),h=Math.round(h));try{return d._readTexturePixelsSync(this._texture,c,h,this._texture.isCube?e:-1,i,a,s,n)}catch{return null}}get _lodTextureHigh(){return this._texture?this._texture._lodTextureHigh:null}get _lodTextureMid(){return this._texture?this._texture._lodTextureMid:null}get _lodTextureLow(){return this._texture?this._texture._lodTextureLow:null}dispose(){if(this._scene){this._scene.stopAnimation&&this._scene.stopAnimation(this),this._scene.removePendingData(this);const e=this._scene.textures.indexOf(this);if(e>=0&&this._scene.textures.splice(e,1),this._scene.onTextureRemovedObservable.notifyObservers(this),this._scene=null,this._parentContainer){const i=this._parentContainer.textures.indexOf(this);i>-1&&this._parentContainer.textures.splice(i,1),this._parentContainer=null}}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.metadata=null,super.dispose()}serialize(e=!1){if(!this.name&&!e)return null;const i=r.j.Serialize(this);return r.j.AppendSerializedAnimations(this,i),i}static WhenAllReady(e,i){let a=e.length;if(0!==a)for(let s=0;s<e.length;s++){const n=e[s];if(n.isReady())0==--a&&i();else{const o=n.onLoadObservable;o?o.addOnce(()=>{0==--a&&i()}):0==--a&&i()}}else i()}static _IsScene(e){return"Scene"===e.getClassName()}}return l.DEFAULT_ANISOTROPIC_FILTERING_LEVEL=4,l})();function He(l,t,e=!1){const i=t.width,a=t.height;if(l instanceof Float32Array){let c=l.byteLength/l.BYTES_PER_ELEMENT;const h=new Uint8Array(c);for(;--c>=0;){let d=l[c];d<0?d=0:d>1&&(d=1),h[c]=255*d}l=h}const s=document.createElement("canvas");s.width=i,s.height=a;const n=s.getContext("2d");if(!n)return null;const o=n.createImageData(i,a);if(o.data.set(l),n.putImageData(o,0,0),e){const c=document.createElement("canvas");c.width=i,c.height=a;const h=c.getContext("2d");return h?(h.translate(0,a),h.scale(1,-1),h.drawImage(s,0,0),c.toDataURL("image/png")):null}return s.toDataURL("image/png")}function ye(){return(ye=(0,Q.Z)(function*(l,t=0,e=0){const i=l.getInternalTexture();if(!i)return null;const a=yield l.readPixels(t,e);return a?He(a,l.getSize(),i.invertY):null})).apply(this,arguments)}(0,r._)([(0,r.f)()],O.prototype,"uniqueId",void 0),(0,r._)([(0,r.f)()],O.prototype,"name",void 0),(0,r._)([(0,r.f)()],O.prototype,"metadata",void 0),(0,r._)([(0,r.f)("hasAlpha")],O.prototype,"_hasAlpha",void 0),(0,r._)([(0,r.f)("getAlphaFromRGB")],O.prototype,"_getAlphaFromRGB",void 0),(0,r._)([(0,r.f)()],O.prototype,"level",void 0),(0,r._)([(0,r.f)("coordinatesIndex")],O.prototype,"_coordinatesIndex",void 0),(0,r._)([(0,r.f)()],O.prototype,"optimizeUVAllocation",void 0),(0,r._)([(0,r.f)("coordinatesMode")],O.prototype,"_coordinatesMode",void 0),(0,r._)([(0,r.f)()],O.prototype,"wrapU",null),(0,r._)([(0,r.f)()],O.prototype,"wrapV",null),(0,r._)([(0,r.f)()],O.prototype,"wrapR",void 0),(0,r._)([(0,r.f)()],O.prototype,"anisotropicFilteringLevel",void 0),(0,r._)([(0,r.f)()],O.prototype,"isCube",null),(0,r._)([(0,r.f)()],O.prototype,"is3D",null),(0,r._)([(0,r.f)()],O.prototype,"is2DArray",null),(0,r._)([(0,r.f)()],O.prototype,"gammaSpace",null),(0,r._)([(0,r.f)()],O.prototype,"invertZ",void 0),(0,r._)([(0,r.f)()],O.prototype,"lodLevelInAlpha",void 0),(0,r._)([(0,r.f)()],O.prototype,"lodGenerationOffset",null),(0,r._)([(0,r.f)()],O.prototype,"lodGenerationScale",null),(0,r._)([(0,r.f)()],O.prototype,"linearSpecularLOD",null),(0,r._)([(0,r.m)()],O.prototype,"irradianceTexture",null),(0,r._)([(0,r.f)()],O.prototype,"isRenderTarget",void 0);class g extends O{get noMipmap(){return this._noMipmap}get mimeType(){return this._mimeType}set isBlocking(t){this._isBlocking=t}get isBlocking(){return this._isBlocking}get invertY(){return this._invertY}constructor(t,e,i,a,s=g.TRILINEAR_SAMPLINGMODE,n=null,o=null,c=null,h=!1,d,u,f,p,m){var S,_,T,E,x,R,P,C,L;super(e),this.url=null,this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.uRotationCenter=.5,this.vRotationCenter=.5,this.wRotationCenter=.5,this.homogeneousRotationInUVTransform=!1,this.inspectableCustomProperties=null,this._noMipmap=!1,this._invertY=!1,this._rowGenerationMatrix=null,this._cachedTextureMatrix=null,this._projectionModeMatrix=null,this._t0=null,this._t1=null,this._t2=null,this._cachedUOffset=-1,this._cachedVOffset=-1,this._cachedUScale=0,this._cachedVScale=0,this._cachedUAng=-1,this._cachedVAng=-1,this._cachedWAng=-1,this._cachedReflectionProjectionMatrixId=-1,this._cachedURotationCenter=-1,this._cachedVRotationCenter=-1,this._cachedWRotationCenter=-1,this._cachedHomogeneousRotationInUVTransform=!1,this._cachedReflectionTextureMatrix=null,this._cachedReflectionUOffset=-1,this._cachedReflectionVOffset=-1,this._cachedReflectionUScale=0,this._cachedReflectionVScale=0,this._cachedReflectionCoordinatesMode=-1,this._buffer=null,this._deleteBuffer=!1,this._format=null,this._delayedOnLoad=null,this._delayedOnError=null,this.onLoadObservable=new r.O,this._isBlocking=!0,this.name=t||"",this.url=t;let I,b=!1,q=null;"object"==typeof i&&null!==i?(I=null!==(S=i.noMipmap)&&void 0!==S&&S,a=null!==(_=i.invertY)&&void 0!==_?_:!r.n.UseOpenGLOrientationForUV,s=null!==(T=i.samplingMode)&&void 0!==T?T:g.TRILINEAR_SAMPLINGMODE,n=null!==(E=i.onLoad)&&void 0!==E?E:null,o=null!==(x=i.onError)&&void 0!==x?x:null,c=null!==(R=i.buffer)&&void 0!==R?R:null,h=null!==(P=i.deleteBuffer)&&void 0!==P&&P,d=i.format,u=i.mimeType,f=i.loaderOptions,p=i.creationFlags,b=null!==(C=i.useSRGBBuffer)&&void 0!==C&&C,q=null!==(L=i.internalTexture)&&void 0!==L?L:null):I=!!i,this._noMipmap=I,this._invertY=void 0===a?!r.n.UseOpenGLOrientationForUV:a,this._initialSamplingMode=s,this._buffer=c,this._deleteBuffer=h,this._mimeType=u,this._loaderOptions=f,this._creationFlags=p,this._useSRGBBuffer=b,this._forcedExtension=m,d&&(this._format=d);const w=this.getScene(),he=this._getEngine();if(!he)return;he.onBeforeTextureInitObservable.notifyObservers(this);const F=()=>{this._texture&&(this._texture._invertVScale&&(this.vScale*=-1,this.vOffset+=1),null!==this._texture._cachedWrapU&&(this.wrapU=this._texture._cachedWrapU,this._texture._cachedWrapU=null),null!==this._texture._cachedWrapV&&(this.wrapV=this._texture._cachedWrapV,this._texture._cachedWrapV=null),null!==this._texture._cachedWrapR&&(this.wrapR=this._texture._cachedWrapR,this._texture._cachedWrapR=null)),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this),n&&n(),!this.isBlocking&&w&&w.resetCachedMaterial()},Y=(Z,W)=>{this._loadingError=!0,this._errorObject={message:Z,exception:W},o&&o(Z,W),g.OnTextureLoadErrorObservable.notifyObservers(this)};if(!this.url&&!q)return this._delayedOnLoad=F,void(this._delayedOnError=Y);if(this._texture=q??this._getFromCache(this.url,I,s,this._invertY,b),this._texture)if(this._texture.isReady)r.o.SetImmediate(()=>F());else{const Z=this._texture.onLoadedObservable.add(F);this._texture.onErrorObservable.add(W=>{var ae;Y(W.message,W.exception),null===(ae=this._texture)||void 0===ae||ae.onLoadedObservable.remove(Z)})}else if(w&&w.useDelayedTextureLoading)this.delayLoadState=4,this._delayedOnLoad=F,this._delayedOnError=Y;else{try{this._texture=he.createTexture(this.url,I,this._invertY,w,s,F,Y,this._buffer,void 0,this._format,this._forcedExtension,u,f,p,b)}catch(Z){throw Y("error loading",Z),Z}h&&(this._buffer=null)}}updateURL(t,e=null,i,a){this.url&&(this.releaseInternalTexture(),this.getScene().markAllMaterialsAsDirty(1)),(!this.name||this.name.startsWith("data:"))&&(this.name=t),this.url=t,this._buffer=e,this._forcedExtension=a,this.delayLoadState=4,i&&(this._delayedOnLoad=i),this.delayLoad()}delayLoad(){if(4!==this.delayLoadState)return;const t=this.getScene();t&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap,this.samplingMode,this._invertY,this._useSRGBBuffer),this._texture?this._delayedOnLoad&&(this._texture.isReady?r.o.SetImmediate(this._delayedOnLoad):this._texture.onLoadedObservable.add(this._delayedOnLoad)):(this._texture=t.getEngine().createTexture(this.url,this._noMipmap,this._invertY,t,this.samplingMode,this._delayedOnLoad,this._delayedOnError,this._buffer,null,this._format,this._forcedExtension,this._mimeType,this._loaderOptions,this._creationFlags,this._useSRGBBuffer),this._deleteBuffer&&(this._buffer=null)),this._delayedOnLoad=null,this._delayedOnError=null)}_prepareRowForTextureGeneration(t,e,i,a){t*=this._cachedUScale,e*=this._cachedVScale,r.V.TransformCoordinatesFromFloatsToRef(t-=this.uRotationCenter*this._cachedUScale,e-=this.vRotationCenter*this._cachedVScale,i-=this.wRotationCenter,this._rowGenerationMatrix,a),a.x+=this.uRotationCenter*this._cachedUScale+this._cachedUOffset,a.y+=this.vRotationCenter*this._cachedVScale+this._cachedVOffset,a.z+=this.wRotationCenter}checkTransformsAreIdentical(t){return null!==t&&this.uOffset===t.uOffset&&this.vOffset===t.vOffset&&this.uScale===t.uScale&&this.vScale===t.vScale&&this.uAng===t.uAng&&this.vAng===t.vAng&&this.wAng===t.wAng}getTextureMatrix(t=1){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale*t===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng&&this.uRotationCenter===this._cachedURotationCenter&&this.vRotationCenter===this._cachedVRotationCenter&&this.wRotationCenter===this._cachedWRotationCenter&&this.homogeneousRotationInUVTransform===this._cachedHomogeneousRotationInUVTransform)return this._cachedTextureMatrix;this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale*t,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedURotationCenter=this.uRotationCenter,this._cachedVRotationCenter=this.vRotationCenter,this._cachedWRotationCenter=this.wRotationCenter,this._cachedHomogeneousRotationInUVTransform=this.homogeneousRotationInUVTransform,(!this._cachedTextureMatrix||!this._rowGenerationMatrix)&&(this._cachedTextureMatrix=r.b.Zero(),this._rowGenerationMatrix=new r.b,this._t0=r.V.Zero(),this._t1=r.V.Zero(),this._t2=r.V.Zero()),r.b.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this.homogeneousRotationInUVTransform?(r.b.TranslationToRef(-this._cachedURotationCenter,-this._cachedVRotationCenter,-this._cachedWRotationCenter,r.T.Matrix[0]),r.b.TranslationToRef(this._cachedURotationCenter,this._cachedVRotationCenter,this._cachedWRotationCenter,r.T.Matrix[1]),r.b.ScalingToRef(this._cachedUScale,this._cachedVScale,0,r.T.Matrix[2]),r.b.TranslationToRef(this._cachedUOffset,this._cachedVOffset,0,r.T.Matrix[3]),r.T.Matrix[0].multiplyToRef(this._rowGenerationMatrix,this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(r.T.Matrix[1],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(r.T.Matrix[2],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(r.T.Matrix[3],this._cachedTextureMatrix),this._cachedTextureMatrix.setRowFromFloats(2,this._cachedTextureMatrix.m[12],this._cachedTextureMatrix.m[13],this._cachedTextureMatrix.m[14],1)):(this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),r.b.FromValuesToRef(this._t1.x,this._t1.y,this._t1.z,0,this._t2.x,this._t2.y,this._t2.z,0,this._t0.x,this._t0.y,this._t0.z,0,0,0,0,1,this._cachedTextureMatrix));const e=this.getScene();return e?(this.optimizeUVAllocation&&e.markAllMaterialsAsDirty(1,i=>i.hasTexture(this)),this._cachedTextureMatrix):this._cachedTextureMatrix}getReflectionTextureMatrix(){const t=this.getScene();if(!t)return this._cachedReflectionTextureMatrix;if(this.uOffset===this._cachedReflectionUOffset&&this.vOffset===this._cachedReflectionVOffset&&this.uScale===this._cachedReflectionUScale&&this.vScale===this._cachedReflectionVScale&&this.coordinatesMode===this._cachedReflectionCoordinatesMode){if(this.coordinatesMode!==g.PROJECTION_MODE)return this._cachedReflectionTextureMatrix;if(this._cachedReflectionProjectionMatrixId===t.getProjectionMatrix().updateFlag)return this._cachedReflectionTextureMatrix}this._cachedReflectionTextureMatrix||(this._cachedReflectionTextureMatrix=r.b.Zero()),this._projectionModeMatrix||(this._projectionModeMatrix=r.b.Zero());const e=this._cachedReflectionCoordinatesMode!==this.coordinatesMode;switch(this._cachedReflectionUOffset=this.uOffset,this._cachedReflectionVOffset=this.vOffset,this._cachedReflectionUScale=this.uScale,this._cachedReflectionVScale=this.vScale,this._cachedReflectionCoordinatesMode=this.coordinatesMode,this.coordinatesMode){case g.PLANAR_MODE:r.b.IdentityToRef(this._cachedReflectionTextureMatrix),this._cachedReflectionTextureMatrix[0]=this.uScale,this._cachedReflectionTextureMatrix[5]=this.vScale,this._cachedReflectionTextureMatrix[12]=this.uOffset,this._cachedReflectionTextureMatrix[13]=this.vOffset;break;case g.PROJECTION_MODE:{r.b.FromValuesToRef(.5,0,0,0,0,-.5,0,0,0,0,0,0,.5,.5,1,1,this._projectionModeMatrix);const i=t.getProjectionMatrix();this._cachedReflectionProjectionMatrixId=i.updateFlag,i.multiplyToRef(this._projectionModeMatrix,this._cachedReflectionTextureMatrix);break}default:r.b.IdentityToRef(this._cachedReflectionTextureMatrix)}return e&&t.markAllMaterialsAsDirty(1,i=>-1!==i.getActiveTextures().indexOf(this)),this._cachedReflectionTextureMatrix}clone(){const t={noMipmap:this._noMipmap,invertY:this._invertY,samplingMode:this.samplingMode,onLoad:void 0,onError:void 0,buffer:this._texture?this._texture._buffer:void 0,deleteBuffer:this._deleteBuffer,format:this.textureFormat,mimeType:this.mimeType,loaderOptions:this._loaderOptions,creationFlags:this._creationFlags,useSRGBBuffer:this._useSRGBBuffer};return r.j.Clone(()=>new g(this._texture?this._texture.url:null,this.getScene(),t),this)}serialize(){var t,e;const i=this.name;g.SerializeBuffers||this.name.startsWith("data:")&&(this.name=""),this.name.startsWith("data:")&&this.url===this.name&&(this.url="");const a=super.serialize(g._SerializeInternalTextureUniqueId);return a?((g.SerializeBuffers||g.ForceSerializeBuffers)&&("string"==typeof this._buffer&&"data:"===this._buffer.substr(0,5)?(a.base64String=this._buffer,a.name=a.name.replace("data:","")):this.url&&this.url.startsWith("data:")&&this._buffer instanceof Uint8Array?a.base64String="data:image/png;base64,"+(0,r.p)(this._buffer):(g.ForceSerializeBuffers||this.url&&this.url.startsWith("blob:")||this._forceSerialize)&&(a.base64String=!this._engine||this._engine._features.supportSyncTextureRead?function ht(l,t=0,e=0){const i=l.getInternalTexture();if(!i)return null;const a=l._readPixelsSync(t,e);return a?He(a,l.getSize(),i.invertY):null}(this):function dt(l){return ye.apply(this,arguments)}(this))),a.invertY=this._invertY,a.samplingMode=this.samplingMode,a._creationFlags=this._creationFlags,a._useSRGBBuffer=this._useSRGBBuffer,g._SerializeInternalTextureUniqueId&&(a.internalTextureUniqueId=null!==(e=null===(t=this._texture)||void 0===t?void 0:t.uniqueId)&&void 0!==e?e:void 0),this.name=i,a):null}getClassName(){return"Texture"}dispose(){super.dispose(),this.onLoadObservable.clear(),this._delayedOnLoad=null,this._delayedOnError=null,this._buffer=null}static Parse(t,e,i){if(t.customType){const o=r.I.Instantiate(t.customType).Parse(t,e,i);return t.samplingMode&&o.updateSamplingMode&&o._samplingMode&&o._samplingMode!==t.samplingMode&&o.updateSamplingMode(t.samplingMode),o}if(t.isCube&&!t.isRenderTarget)return g._CubeTextureParser(t,e,i);const a=void 0!==t.internalTextureUniqueId;if(!t.name&&!t.isRenderTarget&&!a)return null;let s;if(a){const o=e.getEngine().getLoadedTexturesCache();for(const c of o)if(c.uniqueId===t.internalTextureUniqueId){s=c;break}}const n=o=>{var c;if(o&&o._texture&&(o._texture._cachedWrapU=null,o._texture._cachedWrapV=null,o._texture._cachedWrapR=null),t.samplingMode){const h=t.samplingMode;o&&o.samplingMode!==h&&o.updateSamplingMode(h)}if(o&&t.animations)for(let h=0;h<t.animations.length;h++){const d=t.animations[h],u=(0,r.G)("BABYLON.Animation");u&&o.animations.push(u.Parse(d))}a&&!s&&(null===(c=o?._texture)||void 0===c||c._setUniqueId(t.internalTextureUniqueId))};return r.j.Parse(()=>{var o,c,h;let d=!0;if(t.noMipmap&&(d=!1),t.mirrorPlane){const u=g._CreateMirror(t.name,t.renderTargetSize,e,d);return u._waitingRenderList=t.renderList,u.mirrorPlane=r.P.FromArray(t.mirrorPlane),n(u),u}if(t.isRenderTarget){let u=null;if(t.isCube){if(e.reflectionProbes)for(let f=0;f<e.reflectionProbes.length;f++){const p=e.reflectionProbes[f];if(p.name===t.name)return p.cubeTexture}}else u=g._CreateRenderTargetTexture(t.name,t.renderTargetSize,e,d,null!==(o=t._creationFlags)&&void 0!==o?o:0),u._waitingRenderList=t.renderList;return n(u),u}{let u;if(t.base64String&&!s)u=g.CreateFromBase64String(t.base64String,t.base64String,e,!d,t.invertY,t.samplingMode,()=>{n(u)},null!==(c=t._creationFlags)&&void 0!==c?c:0,null!==(h=t._useSRGBBuffer)&&void 0!==h&&h),u.name=t.name;else{let f;f=t.name&&t.name.indexOf("://")>0?t.name:i+t.name,t.url&&(t.url.startsWith("data:")||g.UseSerializedUrlIfAny)&&(f=t.url),u=new g(f,e,{noMipmap:!d,invertY:t.invertY,samplingMode:t.samplingMode,onLoad:()=>{n(u)},internalTexture:s})}return u}},t,e)}static CreateFromBase64String(t,e,i,a,s,n=g.TRILINEAR_SAMPLINGMODE,o=null,c=null,h=5,d){return new g("data:"+e,i,a,s,n,o,c,t,!1,h,void 0,void 0,d)}static LoadFromDataString(t,e,i,a=!1,s,n=!0,o=g.TRILINEAR_SAMPLINGMODE,c=null,h=null,d=5,u){return"data:"!==t.substr(0,5)&&(t="data:"+t),new g(t,i,s,n,o,c,h,e,a,d,void 0,void 0,u)}}g.SerializeBuffers=!0,g.ForceSerializeBuffers=!1,g.OnTextureLoadErrorObservable=new r.O,g._SerializeInternalTextureUniqueId=!1,g._CubeTextureParser=(l,t,e)=>{throw(0,r.q)("CubeTexture")},g._CreateMirror=(l,t,e,i)=>{throw(0,r.q)("MirrorTexture")},g._CreateRenderTargetTexture=(l,t,e,i,a)=>{throw(0,r.q)("RenderTargetTexture")},g.NEAREST_SAMPLINGMODE=1,g.NEAREST_NEAREST_MIPLINEAR=8,g.BILINEAR_SAMPLINGMODE=2,g.LINEAR_LINEAR_MIPNEAREST=11,g.TRILINEAR_SAMPLINGMODE=3,g.LINEAR_LINEAR_MIPLINEAR=3,g.NEAREST_NEAREST_MIPNEAREST=4,g.NEAREST_LINEAR_MIPNEAREST=5,g.NEAREST_LINEAR_MIPLINEAR=6,g.NEAREST_LINEAR=7,g.NEAREST_NEAREST=1,g.LINEAR_NEAREST_MIPNEAREST=9,g.LINEAR_NEAREST_MIPLINEAR=10,g.LINEAR_LINEAR=2,g.LINEAR_NEAREST=12,g.EXPLICIT_MODE=0,g.SPHERICAL_MODE=1,g.PLANAR_MODE=2,g.CUBIC_MODE=3,g.PROJECTION_MODE=4,g.SKYBOX_MODE=5,g.INVCUBIC_MODE=6,g.EQUIRECTANGULAR_MODE=7,g.FIXED_EQUIRECTANGULAR_MODE=8,g.FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,g.CLAMP_ADDRESSMODE=0,g.WRAP_ADDRESSMODE=1,g.MIRROR_ADDRESSMODE=2,g.UseSerializedUrlIfAny=!1,(0,r._)([(0,r.f)()],g.prototype,"url",void 0),(0,r._)([(0,r.f)()],g.prototype,"uOffset",void 0),(0,r._)([(0,r.f)()],g.prototype,"vOffset",void 0),(0,r._)([(0,r.f)()],g.prototype,"uScale",void 0),(0,r._)([(0,r.f)()],g.prototype,"vScale",void 0),(0,r._)([(0,r.f)()],g.prototype,"uAng",void 0),(0,r._)([(0,r.f)()],g.prototype,"vAng",void 0),(0,r._)([(0,r.f)()],g.prototype,"wAng",void 0),(0,r._)([(0,r.f)()],g.prototype,"uRotationCenter",void 0),(0,r._)([(0,r.f)()],g.prototype,"vRotationCenter",void 0),(0,r._)([(0,r.f)()],g.prototype,"wRotationCenter",void 0),(0,r._)([(0,r.f)()],g.prototype,"homogeneousRotationInUVTransform",void 0),(0,r._)([(0,r.f)()],g.prototype,"isBlocking",null),(0,r.r)("BABYLON.Texture",g),r.j._TextureParser=g.Parse;class ct{get depthStencilTexture(){return this._depthStencilTexture}get depthStencilTextureWithStencil(){return this._depthStencilTextureWithStencil}get isCube(){return this._isCube}get isMulti(){return this._isMulti}get is2DArray(){return this.layers>0}get size(){return this.width}get width(){return this._size.width||this._size}get height(){return this._size.height||this._size}get layers(){return this._size.layers||0}get texture(){var t,e;return null!==(e=null===(t=this._textures)||void 0===t?void 0:t[0])&&void 0!==e?e:null}get textures(){return this._textures}get faceIndices(){return this._faceIndices}get layerIndices(){return this._layerIndices}get samples(){return this._samples}setSamples(t,e=!0,i=!1){if(this.samples===t&&!i)return t;const a=this._isMulti?this._engine.updateMultipleRenderTargetTextureSampleCount(this,t,e):this._engine.updateRenderTargetTextureSampleCount(this,t);return this._samples=t,a}constructor(t,e,i,a){this._textures=null,this._faceIndices=null,this._layerIndices=null,this._samples=1,this._attachments=null,this._generateStencilBuffer=!1,this._generateDepthBuffer=!1,this._depthStencilTextureWithStencil=!1,this._isMulti=t,this._isCube=e,this._size=i,this._engine=a,this._depthStencilTexture=null}setTextures(t){this._textures=Array.isArray(t)?t:t?[t]:null}setTexture(t,e=0,i=!0){this._textures||(this._textures=[]),this._textures[e]&&i&&this._textures[e].dispose(),this._textures[e]=t}setLayerAndFaceIndices(t,e){this._layerIndices=t,this._faceIndices=e}setLayerAndFaceIndex(t=0,e,i){this._layerIndices||(this._layerIndices=[]),this._faceIndices||(this._faceIndices=[]),void 0!==e&&e>=0&&(this._layerIndices[t]=e),void 0!==i&&i>=0&&(this._faceIndices[t]=i)}createDepthStencilTexture(t=0,e=!0,i=!1,a=1,s=14,n){var o;return null===(o=this._depthStencilTexture)||void 0===o||o.dispose(),this._depthStencilTextureWithStencil=i,this._depthStencilTexture=this._engine.createDepthStencilTexture(this._size,{bilinearFiltering:e,comparisonFunction:t,generateStencil:i,isCube:this._isCube,samples:a,depthTextureFormat:s,label:n},this),this._depthStencilTexture}_shareDepth(t){this._depthStencilTexture&&(t._depthStencilTexture&&t._depthStencilTexture.dispose(),t._depthStencilTexture=this._depthStencilTexture,this._depthStencilTexture.incrementReferences())}_swapAndDie(t){this.texture&&this.texture._swapAndDie(t),this._textures=null,this.dispose(!0)}_cloneRenderTargetWrapper(){var t,e,i,a,s,n,o,c;let h=null;if(this._isMulti){const d=this.textures;if(d&&d.length>0){let u=!1,f=d.length;const p=d[d.length-1]._source;(p===r.t.Depth||p===r.t.DepthStencil)&&(u=!0,f--);const m=[],S=[],_=[],T=[],E=[],x=[],R=[],P={};for(let I=0;I<f;++I){const b=d[I];m.push(b.samplingMode),S.push(b.type),_.push(b.format),void 0!==P[b.uniqueId]?(T.push(-1),R.push(0)):(P[b.uniqueId]=I,b.is2DArray?(T.push(35866),R.push(b.depth)):b.isCube?(T.push(34067),R.push(0)):b.is3D?(T.push(32879),R.push(b.depth)):(T.push(3553),R.push(0))),this._faceIndices&&E.push(null!==(t=this._faceIndices[I])&&void 0!==t?t:0),this._layerIndices&&x.push(null!==(e=this._layerIndices[I])&&void 0!==e?e:0)}h=this._engine.createMultipleRenderTarget({width:this.width,height:this.height},{samplingModes:m,generateMipMaps:d[0].generateMipMaps,generateDepthBuffer:this._generateDepthBuffer,generateStencilBuffer:this._generateStencilBuffer,generateDepthTexture:u,types:S,formats:_,textureCount:f,targetTypes:T,faceIndex:E,layerIndex:x,layerCounts:R});for(let I=0;I<f;++I)-1===T[I]&&h.setTexture(h.textures[P[d[I].uniqueId]],I)}}else{const d={};if(d.generateDepthBuffer=this._generateDepthBuffer,d.generateMipMaps=null!==(a=null===(i=this.texture)||void 0===i?void 0:i.generateMipMaps)&&void 0!==a&&a,d.generateStencilBuffer=this._generateStencilBuffer,d.samplingMode=null===(s=this.texture)||void 0===s?void 0:s.samplingMode,d.type=null===(n=this.texture)||void 0===n?void 0:n.type,d.format=null===(o=this.texture)||void 0===o?void 0:o.format,this.isCube)h=this._engine.createRenderTargetCubeTexture(this.width,d);else{const u={width:this.width,height:this.height,layers:this.is2DArray?null===(c=this.texture)||void 0===c?void 0:c.depth:void 0};h=this._engine.createRenderTargetTexture(u,d)}h.texture.isReady=!0}return h}_swapRenderTargetWrapper(t){if(this._textures&&t._textures)for(let e=0;e<this._textures.length;++e)this._textures[e]._swapAndDie(t._textures[e],!1),t._textures[e].isReady=!0;this._depthStencilTexture&&t._depthStencilTexture&&(this._depthStencilTexture._swapAndDie(t._depthStencilTexture),t._depthStencilTexture.isReady=!0),this._textures=null,this._depthStencilTexture=null}_rebuild(){const t=this._cloneRenderTargetWrapper();if(t){if(this._depthStencilTexture){const e=this._depthStencilTexture.samplingMode;t.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction,2===e||3===e||11===e,this._depthStencilTextureWithStencil,this._depthStencilTexture.samples)}this.samples>1&&t.setSamples(this.samples),t._swapRenderTargetWrapper(this),t.dispose()}}releaseTextures(){var t,e;if(this._textures)for(let i=0;null!==(e=i<(null===(t=this._textures)||void 0===t?void 0:t.length))&&void 0!==e&&e;++i)this._textures[i].dispose();this._textures=null}dispose(t=!1){var e;t||(null===(e=this._depthStencilTexture)||void 0===e||e.dispose(),this._depthStencilTexture=null,this.releaseTextures()),this._engine._releaseRenderTargetWrapper(this)}}class ut extends ct{constructor(t,e,i,a,s){super(t,e,i,a),this._framebuffer=null,this._depthStencilBuffer=null,this._MSAAFramebuffer=null,this._colorTextureArray=null,this._depthStencilTextureArray=null,this._context=s}_cloneRenderTargetWrapper(){let t=null;return this._colorTextureArray&&this._depthStencilTextureArray?(t=this._engine.createMultiviewRenderTargetTexture(this.width,this.height),t.texture.isReady=!0):t=super._cloneRenderTargetWrapper(),t}_swapRenderTargetWrapper(t){super._swapRenderTargetWrapper(t),t._framebuffer=this._framebuffer,t._depthStencilBuffer=this._depthStencilBuffer,t._MSAAFramebuffer=this._MSAAFramebuffer,t._colorTextureArray=this._colorTextureArray,t._depthStencilTextureArray=this._depthStencilTextureArray,this._framebuffer=this._depthStencilBuffer=this._MSAAFramebuffer=this._colorTextureArray=this._depthStencilTextureArray=null}_shareDepth(t){super._shareDepth(t);const e=this._context,i=this._depthStencilBuffer,a=t._MSAAFramebuffer||t._framebuffer;t._depthStencilBuffer&&e.deleteRenderbuffer(t._depthStencilBuffer),t._depthStencilBuffer=this._depthStencilBuffer,this._engine._bindUnboundFramebuffer(a),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,i),this._engine._bindUnboundFramebuffer(null)}_bindTextureRenderTarget(t,e=0,i,a=0){var s,n,o,c;if(!t._hardwareTexture)return;const d=this._engine._currentFramebuffer;if(this._engine._bindUnboundFramebuffer(this._framebuffer),this._engine.webGLVersion>1){const u=this._context,f=u["COLOR_ATTACHMENT"+e];t.is2DArray||t.is3D?(i=null!==(n=i??(null===(s=this.layerIndices)||void 0===s?void 0:s[e]))&&void 0!==n?n:0,u.framebufferTextureLayer(u.FRAMEBUFFER,f,t._hardwareTexture.underlyingResource,a,i)):t.isCube?(i=null!==(c=i??(null===(o=this.faceIndices)||void 0===o?void 0:o[e]))&&void 0!==c?c:0,u.framebufferTexture2D(u.FRAMEBUFFER,f,u.TEXTURE_CUBE_MAP_POSITIVE_X+i,t._hardwareTexture.underlyingResource,a)):u.framebufferTexture2D(u.FRAMEBUFFER,f,u.TEXTURE_2D,t._hardwareTexture.underlyingResource,a)}else{const u=this._context;u.framebufferTexture2D(u.FRAMEBUFFER,u["COLOR_ATTACHMENT"+e+"_WEBGL"],void 0!==i?u.TEXTURE_CUBE_MAP_POSITIVE_X+i:u.TEXTURE_2D,t._hardwareTexture.underlyingResource,a)}this._engine._bindUnboundFramebuffer(d)}setTexture(t,e=0,i=!0){super.setTexture(t,e,i),this._bindTextureRenderTarget(t,e)}setLayerAndFaceIndices(t,e){var i,a;if(super.setLayerAndFaceIndices(t,e),!this.textures||!this.layerIndices||!this.faceIndices)return;const s=null!==(a=null===(i=this._attachments)||void 0===i?void 0:i.length)&&void 0!==a?a:this.textures.length;for(let n=0;n<s;n++){const o=this.textures[n];o&&(o.is2DArray||o.is3D?this._bindTextureRenderTarget(o,n,this.layerIndices[n]):o.isCube?this._bindTextureRenderTarget(o,n,this.faceIndices[n]):this._bindTextureRenderTarget(o,n))}}setLayerAndFaceIndex(t=0,e,i){if(super.setLayerAndFaceIndex(t,e,i),!this.textures||!this.layerIndices||!this.faceIndices)return;const a=this.textures[t];a.is2DArray||a.is3D?this._bindTextureRenderTarget(this.textures[t],t,this.layerIndices[t]):a.isCube&&this._bindTextureRenderTarget(this.textures[t],t,this.faceIndices[t])}dispose(t=!1){const e=this._context;t||(this._colorTextureArray&&(this._context.deleteTexture(this._colorTextureArray),this._colorTextureArray=null),this._depthStencilTextureArray&&(this._context.deleteTexture(this._depthStencilTextureArray),this._depthStencilTextureArray=null)),this._framebuffer&&(e.deleteFramebuffer(this._framebuffer),this._framebuffer=null),this._depthStencilBuffer&&(e.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null),this._MSAAFramebuffer&&(e.deleteFramebuffer(this._MSAAFramebuffer),this._MSAAFramebuffer=null),super.dispose(t)}}r.u.prototype._createHardwareRenderTargetWrapper=function(l,t,e){const i=new ut(l,t,e,this,this._gl);return this._renderTargetWrapperCache.push(i),i},r.u.prototype.createRenderTargetTexture=function(l,t){var e,i;const a=this._createHardwareRenderTargetWrapper(!1,!1,l);let c,s=!0,n=!1,o=!1,h=1;void 0!==t&&"object"==typeof t&&(s=null===(e=t.generateDepthBuffer)||void 0===e||e,n=!!t.generateStencilBuffer,o=!!t.noColorAttachment,c=t.colorAttachment,h=null!==(i=t.samples)&&void 0!==i?i:1);const d=c||(o?null:this._createInternalTexture(l,t,!0,r.t.RenderTarget)),u=l.width||l,f=l.height||l,p=this._currentFramebuffer,m=this._gl,S=m.createFramebuffer();return this._bindUnboundFramebuffer(S),a._depthStencilBuffer=this._setupFramebufferDepthAttachments(n,s,u,f),d&&!d.is2DArray&&m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,d._hardwareTexture.underlyingResource,0),this._bindUnboundFramebuffer(p),a._framebuffer=S,a._generateDepthBuffer=s,a._generateStencilBuffer=n,a.setTextures(d),this.updateRenderTargetTextureSampleCount(a,h),a},r.u.prototype.createDepthStencilTexture=function(l,t,e){return t.isCube?this._createDepthStencilCubeTexture(l.width||l,t,e):this._createDepthStencilTexture(l,t,e)},r.u.prototype._createDepthStencilTexture=function(l,t,e){const i=this._gl,a=l.layers||0,s=0!==a?i.TEXTURE_2D_ARRAY:i.TEXTURE_2D,n=new r.v(this,r.t.DepthStencil);if(!this._caps.depthTextureExtension)return r.w.Error("Depth texture is not supported by your browser or hardware."),n;const o={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...t};if(this._bindTextureDirectly(s,n,!0),this._setupDepthStencilTexture(n,l,o.generateStencil,0!==o.comparisonFunction&&o.bilinearFiltering,o.comparisonFunction,o.samples),void 0!==o.depthTextureFormat){if(15!==o.depthTextureFormat&&16!==o.depthTextureFormat&&17!==o.depthTextureFormat&&13!==o.depthTextureFormat&&14!==o.depthTextureFormat&&18!==o.depthTextureFormat)return r.w.Error("Depth texture format is not supported."),n;n.format=o.depthTextureFormat}else n.format=o.generateStencil?13:16;const c=17===n.format||13===n.format||18===n.format;e._depthStencilTexture=n,e._depthStencilTextureWithStencil=c;let h=i.UNSIGNED_INT;15===n.format?h=i.UNSIGNED_SHORT:17===n.format||13===n.format?h=i.UNSIGNED_INT_24_8:14===n.format?h=i.FLOAT:18===n.format&&(h=i.FLOAT_32_UNSIGNED_INT_24_8_REV);const d=c?i.DEPTH_STENCIL:i.DEPTH_COMPONENT;let u=d;this.webGLVersion>1&&(15===n.format?u=i.DEPTH_COMPONENT16:16===n.format?u=i.DEPTH_COMPONENT24:17===n.format||13===n.format?u=i.DEPTH24_STENCIL8:14===n.format?u=i.DEPTH_COMPONENT32F:18===n.format&&(u=i.DEPTH32F_STENCIL8)),n.is2DArray?i.texImage3D(s,0,u,n.width,n.height,a,0,d,h,null):i.texImage2D(s,0,u,n.width,n.height,0,d,h,null),this._bindTextureDirectly(s,null),this._internalTexturesCache.push(n);const f=e;if(f._depthStencilBuffer){const p=this._currentFramebuffer;this._bindUnboundFramebuffer(f._framebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.RENDERBUFFER,null),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.RENDERBUFFER,null),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.STENCIL_ATTACHMENT,i.RENDERBUFFER,null),this._bindUnboundFramebuffer(p),i.deleteRenderbuffer(f._depthStencilBuffer),f._depthStencilBuffer=null}return n},r.u.prototype.updateRenderTargetTextureSampleCount=function(l,t){if(this.webGLVersion<2||!l||!l.texture)return 1;if(l.samples===t)return t;const e=this._gl;t=Math.min(t,this.getCaps().maxMSAASamples),l._depthStencilBuffer&&(e.deleteRenderbuffer(l._depthStencilBuffer),l._depthStencilBuffer=null),l._MSAAFramebuffer&&(e.deleteFramebuffer(l._MSAAFramebuffer),l._MSAAFramebuffer=null);const i=l.texture._hardwareTexture;if(i.releaseMSAARenderBuffers(),t>1&&"function"==typeof e.renderbufferStorageMultisample){const a=e.createFramebuffer();if(!a)throw new Error("Unable to create multi sampled framebuffer");l._MSAAFramebuffer=a,this._bindUnboundFramebuffer(l._MSAAFramebuffer);const s=this._createRenderBuffer(l.texture.width,l.texture.height,t,-1,this._getRGBAMultiSampleBufferFormat(l.texture.type),e.COLOR_ATTACHMENT0,!1);if(!s)throw new Error("Unable to create multi sampled framebuffer");i.addMSAARenderBuffer(s)}else this._bindUnboundFramebuffer(l._framebuffer);return l.texture.samples=t,l._samples=t,l._depthStencilBuffer=this._setupFramebufferDepthAttachments(l._generateStencilBuffer,l._generateDepthBuffer,l.texture.width,l.texture.height,t),this._bindUnboundFramebuffer(null),t},r.u.prototype.createRenderTargetCubeTexture=function(l,t){const e=this._createHardwareRenderTargetWrapper(!1,!0,l),i={generateMipMaps:!0,generateDepthBuffer:!0,generateStencilBuffer:!1,type:0,samplingMode:3,format:5,...t};i.generateStencilBuffer=i.generateDepthBuffer&&i.generateStencilBuffer,(1===i.type&&!this._caps.textureFloatLinearFiltering||2===i.type&&!this._caps.textureHalfFloatLinearFiltering)&&(i.samplingMode=1);const a=this._gl,s=new r.v(this,r.t.RenderTarget);this._bindTextureDirectly(a.TEXTURE_CUBE_MAP,s,!0);const n=this._getSamplingParameters(i.samplingMode,i.generateMipMaps);1===i.type&&!this._caps.textureFloat&&(i.type=0,r.w.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_MAG_FILTER,n.mag),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_MIN_FILTER,n.min),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_CUBE_MAP,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);for(let c=0;c<6;c++)a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+c,0,this._getRGBABufferInternalSizedFormat(i.type,i.format),l,l,0,this._getInternalFormat(i.format),this._getWebGLTextureType(i.type),null);const o=a.createFramebuffer();return this._bindUnboundFramebuffer(o),e._depthStencilBuffer=this._setupFramebufferDepthAttachments(i.generateStencilBuffer,i.generateDepthBuffer,l,l),i.generateMipMaps&&a.generateMipmap(a.TEXTURE_CUBE_MAP),this._bindTextureDirectly(a.TEXTURE_CUBE_MAP,null),this._bindUnboundFramebuffer(null),e._framebuffer=o,e._generateDepthBuffer=i.generateDepthBuffer,e._generateStencilBuffer=i.generateStencilBuffer,s.width=l,s.height=l,s.isReady=!0,s.isCube=!0,s.samples=1,s.generateMipMaps=i.generateMipMaps,s.samplingMode=i.samplingMode,s.type=i.type,s.format=i.format,this._internalTexturesCache.push(s),e.setTextures(s),e},r.x.ShadersStore.postprocessVertexShader="attribute vec2 position;\nuniform vec2 scale;\nvarying vec2 vUV;\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";const Ue={positions:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class _t{constructor(t,e=Ue){var i,a;this._fullscreenViewport=new r.y(0,0,1,1);const s=null!==(i=e.positions)&&void 0!==i?i:Ue.positions,n=null!==(a=e.indices)&&void 0!==a?a:Ue.indices;this.engine=t,this._vertexBuffers={[r.z.PositionKind]:new r.z(t,s,r.z.PositionKind,!1,!1,2)},this._indexBuffer=t.createIndexBuffer(n),this._onContextRestoredObserver=t.onContextRestoredObservable.add(()=>{this._indexBuffer=t.createIndexBuffer(n);for(const o in this._vertexBuffers)this._vertexBuffers[o]._rebuild()})}setViewport(t=this._fullscreenViewport){this.engine.setViewport(t)}bindBuffers(t){this.engine.bindBuffers(this._vertexBuffers,this._indexBuffer,t)}applyEffectWrapper(t){this.engine.setState(!0),this.engine.depthCullingState.depthTest=!1,this.engine.stencilState.stencilTest=!1,this.engine.enableEffect(t._drawWrapper),this.bindBuffers(t.effect),t.onApplyObservable.notifyObservers({})}restoreStates(){this.engine.depthCullingState.depthTest=!0,this.engine.stencilState.stencilTest=!0}draw(){this.engine.drawElementsType(0,0,6)}_isRenderTargetTexture(t){return void 0!==t.renderTarget}render(t,e=null){if(!t.effect.isReady())return;this.setViewport();const i=null===e?null:this._isRenderTargetTexture(e)?e.renderTarget:e;i&&this.engine.bindFramebuffer(i),this.applyEffectWrapper(t),this.draw(),i&&this.engine.unBindFramebuffer(i),this.restoreStates()}dispose(){const t=this._vertexBuffers[r.z.PositionKind];t&&(t.dispose(),delete this._vertexBuffers[r.z.PositionKind]),this._indexBuffer&&this.engine._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class mt{get effect(){return this._drawWrapper.effect}set effect(t){this._drawWrapper.effect=t}constructor(t){let e;this.onApplyObservable=new r.O;const i=t.uniformNames||[];t.vertexShader?e={fragmentSource:t.fragmentShader,vertexSource:t.vertexShader,spectorName:t.name||"effectWrapper"}:(i.push("scale"),e={fragmentSource:t.fragmentShader,vertex:"postprocess",spectorName:t.name||"effectWrapper"},this.onApplyObservable.add(()=>{this.effect.setFloat2("scale",1,1)}));const a=t.defines?t.defines.join("\n"):"";this._drawWrapper=new r.B(t.engine),t.useShaderStore?(e.fragment=e.fragmentSource,e.vertex||(e.vertex=e.vertexSource),delete e.fragmentSource,delete e.vertexSource,this.effect=t.engine.createEffect(e,t.attributeNames||["position"],i,t.samplerNames,a,void 0,t.onCompiled,void 0,void 0,t.shaderLanguage)):(this.effect=new r.F(e,t.attributeNames||["position"],i,t.samplerNames,t.engine,a,void 0,t.onCompiled,void 0,void 0,void 0,t.shaderLanguage),this._onContextRestoredObserver=t.engine.onContextRestoredObservable.add(()=>{this.effect._pipelineContext=null,this.effect._wasPreviouslyReady=!1,this.effect._prepareEffect()}))}dispose(){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.effect.dispose()}}const Ye="passPixelShader",Ze="varying vec2 vUV;\nuniform sampler2D textureSampler;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{\ngl_FragColor=texture2D(textureSampler,vUV);\n}";r.x.ShadersStore[Ye]=Ze;const je_name=Ye,je_shader=Ze;class z{static _CreateDumpRenderer(){if(!z._DumpToolsEngine){const t=document.createElement("canvas"),e=new r.u(t,!1,{preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1});e.getCaps().parallelShaderCompile=void 0;const i=new _t(e),a=new mt({engine:e,name:je_name,fragmentShader:je_shader,samplerNames:["textureSampler"]});z._DumpToolsEngine={canvas:t,engine:e,renderer:i,wrapper:a}}return z._DumpToolsEngine}static DumpFramebuffer(t,e,i,a,s="image/png",n){return(0,Q.Z)(function*(){const o=yield i.readPixels(0,0,t,e),c=new Uint8Array(o.buffer);z.DumpData(t,e,c,a,s,n,!0)})()}static DumpDataAsync(t,e,i,a="image/png",s,n=!1,o=!1,c){return new Promise(h=>{z.DumpData(t,e,i,d=>h(d),a,s,n,o,c)})}static DumpData(t,e,i,a,s="image/png",n,o=!1,c=!1,h){const d=z._CreateDumpRenderer();if(d.engine.setSize(t,e,!0),i instanceof Float32Array){const f=new Uint8Array(i.length);let p=i.length;for(;p--;){const m=i[p];f[p]=m<0?0:m>1?1:Math.round(255*m)}i=f}const u=d.engine.createRawTexture(i,t,e,5,!1,!o,1);d.renderer.setViewport(),d.renderer.applyEffectWrapper(d.wrapper),d.wrapper.effect._bindTexture("textureSampler",u),d.renderer.draw(),c?r.H.ToBlob(d.canvas,f=>{const p=new FileReader;p.onload=m=>{a&&a(m.target.result)},p.readAsArrayBuffer(f)},s,h):r.H.EncodeScreenshotCanvasData(d.canvas,a,s,n,h),u.dispose()}static Dispose(){z._DumpToolsEngine&&(z._DumpToolsEngine.wrapper.dispose(),z._DumpToolsEngine.renderer.dispose(),z._DumpToolsEngine.engine.dispose()),z._DumpToolsEngine=null}}r.H.DumpData=z.DumpData,r.H.DumpDataAsync=z.DumpDataAsync,r.H.DumpFramebuffer=z.DumpFramebuffer;let de=(()=>{class l extends g{get renderList(){return this._renderList}set renderList(e){this._unObserveRenderList&&(this._unObserveRenderList(),this._unObserveRenderList=null),e&&(this._unObserveRenderList=(0,r.J)(e,this._renderListHasChanged)),this._renderList=e}get postProcesses(){return this._postProcesses}get _prePassEnabled(){return!!this._prePassRenderTarget&&this._prePassRenderTarget.enabled}set onAfterUnbind(e){this._onAfterUnbindObserver&&this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=this.onAfterUnbindObservable.add(e)}set onBeforeRender(e){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(e)}set onAfterRender(e){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(e)}set onClear(e){this._onClearObserver&&this.onClearObservable.remove(this._onClearObserver),this._onClearObserver=this.onClearObservable.add(e)}get renderPassIds(){return this._renderPassIds}get currentRefreshId(){return this._currentRefreshId}setMaterialForRendering(e,i){let a;a=Array.isArray(e)?e:[e];for(let s=0;s<a.length;++s)for(let n=0;n<this._renderPassIds.length;++n)a[s].setMaterialForRenderPass(this._renderPassIds[n],void 0!==i?Array.isArray(i)?i[n]:i:void 0)}get isMulti(){var e,i;return null!==(i=null===(e=this._renderTarget)||void 0===e?void 0:e.isMulti)&&void 0!==i&&i}get renderTargetOptions(){return this._renderTargetOptions}get renderTarget(){return this._renderTarget}_onRatioRescale(){this._sizeRatio&&this.resize(this._initialSizeParameter)}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const i=this.getScene();i&&i.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}get depthStencilTexture(){var e,i;return null!==(i=null===(e=this._renderTarget)||void 0===e?void 0:e._depthStencilTexture)&&void 0!==i?i:null}constructor(e,i,a,s=!1,n=!0,o=0,c=!1,h=g.TRILINEAR_SAMPLINGMODE,d=!0,u=!1,f=!1,p=5,m=!1,S,_,T=!1,E=!1){var x,R,P,C,L,I;let b;if("object"==typeof s){const w=s;s=!!w.generateMipMaps,n=null===(x=w.doNotChangeAspectRatio)||void 0===x||x,o=null!==(R=w.type)&&void 0!==R?R:0,c=!!w.isCube,h=null!==(P=w.samplingMode)&&void 0!==P?P:g.TRILINEAR_SAMPLINGMODE,d=null===(C=w.generateDepthBuffer)||void 0===C||C,u=!!w.generateStencilBuffer,f=!!w.isMulti,p=null!==(L=w.format)&&void 0!==L?L:5,m=!!w.delayAllocation,S=w.samples,_=w.creationFlags,T=!!w.noColorAttachment,E=!!w.useSRGBBuffer,b=w.colorAttachment}if(super(null,a,!s,void 0,h,void 0,void 0,void 0,void 0,p),this._unObserveRenderList=null,this._renderListHasChanged=(w,he)=>{var F;const Y=this._renderList?this._renderList.length:0;(0===he&&Y>0||0===Y)&&(null===(F=this.getScene())||void 0===F||F.meshes.forEach(Z=>{Z._markSubMeshesAsLightDirty()}))},this.renderParticles=!0,this.renderSprites=!1,this.forceLayerMaskCheck=!1,this.ignoreCameraViewport=!1,this.onBeforeBindObservable=new r.O,this.onAfterUnbindObservable=new r.O,this.onBeforeRenderObservable=new r.O,this.onAfterRenderObservable=new r.O,this.onClearObservable=new r.O,this.onResizeObservable=new r.O,this._cleared=!1,this.skipInitialClear=!1,this._currentRefreshId=-1,this._refreshRate=1,this._samples=1,this._canRescale=!0,this._renderTarget=null,this.boundingBoxPosition=r.V.Zero(),!(a=this.getScene()))return;const q=this.getScene().getEngine();this._coordinatesMode=g.PROJECTION_MODE,this.renderList=new Array,this.name=e,this.isRenderTarget=!0,this._initialSizeParameter=i,this._renderPassIds=[],this._isCubeData=c,this._processSizeParameter(i),this.renderPassId=this._renderPassIds[0],this._resizeObserver=q.onResizeObservable.add(()=>{}),this._generateMipMaps=!!s,this._doNotChangeAspectRatio=n,this._renderingManager=new r.K(a),this._renderingManager._useSceneAutoClearSetup=!0,!f&&(this._renderTargetOptions={generateMipMaps:s,type:o,format:null!==(I=this._format)&&void 0!==I?I:void 0,samplingMode:this.samplingMode,generateDepthBuffer:d,generateStencilBuffer:u,samples:S,creationFlags:_,noColorAttachment:T,useSRGBBuffer:E,colorAttachment:b,label:this.name},this.samplingMode===g.NEAREST_SAMPLINGMODE&&(this.wrapU=g.CLAMP_ADDRESSMODE,this.wrapV=g.CLAMP_ADDRESSMODE),m||(c?(this._renderTarget=a.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions),this.coordinatesMode=g.INVCUBIC_MODE,this._textureMatrix=r.b.Identity()):this._renderTarget=a.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,void 0!==S&&(this.samples=S)))}createDepthStencilTexture(e=0,i=!0,a=!1,s=1,n=14){var o;null===(o=this._renderTarget)||void 0===o||o.createDepthStencilTexture(e,i,a,s,n)}_releaseRenderPassId(){if(this._scene){const e=this._scene.getEngine();for(let i=0;i<this._renderPassIds.length;++i)e.releaseRenderPassId(this._renderPassIds[i])}this._renderPassIds=[]}_createRenderPassId(){this._releaseRenderPassId();const e=this._scene.getEngine(),i=this._isCubeData?6:this.getRenderLayers()||1;for(let a=0;a<i;++a)this._renderPassIds[a]=e.createRenderPassId(`RenderTargetTexture - ${this.name}#${a}`)}_processSizeParameter(e){if(e.ratio){this._sizeRatio=e.ratio;const i=this._getEngine();this._size={width:this._bestReflectionRenderTargetDimension(i.getRenderWidth(),this._sizeRatio),height:this._bestReflectionRenderTargetDimension(i.getRenderHeight(),this._sizeRatio)}}else this._size=e;this._createRenderPassId()}get samples(){var e,i;return null!==(i=null===(e=this._renderTarget)||void 0===e?void 0:e.samples)&&void 0!==i?i:this._samples}set samples(e){this._renderTarget&&(this._samples=this._renderTarget.setSamples(e))}resetRefreshCounter(){this._currentRefreshId=-1}get refreshRate(){return this._refreshRate}set refreshRate(e){this._refreshRate=e,this.resetRefreshCounter()}addPostProcess(e){if(!this._postProcessManager){const i=this.getScene();if(!i)return;this._postProcessManager=new r.W(i),this._postProcesses=new Array}this._postProcesses.push(e),this._postProcesses[0].autoClear=!1}clearPostProcesses(e=!1){if(this._postProcesses){if(e)for(const i of this._postProcesses)i.dispose();this._postProcesses=[]}}removePostProcess(e){if(!this._postProcesses)return;const i=this._postProcesses.indexOf(e);-1!==i&&(this._postProcesses.splice(i,1),this._postProcesses.length>0&&(this._postProcesses[0].autoClear=!1))}_shouldRender(){return-1===this._currentRefreshId||this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)}getRenderSize(){return this.getRenderWidth()}getRenderWidth(){return this._size.width?this._size.width:this._size}getRenderHeight(){return this._size.width?this._size.height:this._size}getRenderLayers(){return this._size.layers||0}disableRescaling(){this._canRescale=!1}get canRescale(){return this._canRescale}scale(e){const i=Math.max(1,this.getRenderSize()*e);this.resize(i)}getReflectionTextureMatrix(){return this.isCube?this._textureMatrix:super.getReflectionTextureMatrix()}resize(e){var i;const a=this.isCube;null===(i=this._renderTarget)||void 0===i||i.dispose(),this._renderTarget=null;const s=this.getScene();s&&(this._processSizeParameter(e),this._renderTarget=a?s.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions):s.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,void 0!==this._renderTargetOptions.samples&&(this.samples=this._renderTargetOptions.samples),this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this))}render(e=!1,i=!1){this._render(e,i)}isReadyForRendering(){return this._render(!1,!1,!0)}_render(e=!1,i=!1,a=!1){var s;const n=this.getScene();if(!n)return a;const o=n.getEngine();if(void 0!==this.useCameraPostProcesses&&(e=this.useCameraPostProcesses),this._waitingRenderList){this.renderList=[];for(let f=0;f<this._waitingRenderList.length;f++){const m=n.getMeshById(this._waitingRenderList[f]);m&&this.renderList.push(m)}this._waitingRenderList=void 0}if(this.renderListPredicate){this.renderList?this.renderList.length=0:this.renderList=[];const f=this.getScene();if(!f)return a;const p=f.meshes;for(let m=0;m<p.length;m++){const S=p[m];this.renderListPredicate(S)&&this.renderList.push(S)}}const c=o.currentRenderPassId;this.onBeforeBindObservable.notifyObservers(this);const h=null!==(s=this.activeCamera)&&void 0!==s?s:n.activeCamera,d=n.activeCamera;h&&(h!==n.activeCamera&&(n.setTransformMatrix(h.getViewMatrix(),h.getProjectionMatrix(!0)),n.activeCamera=h),o.setViewport(h.viewport,this.getRenderWidth(),this.getRenderHeight())),this._defaultRenderListPrepared=!1;let u=a;if(a){n.getViewMatrix()||n.updateTransformMatrix();const f=this.is2DArray?this.getRenderLayers():this.isCube?6:1;for(let p=0;p<f&&u;p++){let m=null;const S=this.renderList?this.renderList:n.getActiveMeshes().data,_=this.renderList?this.renderList.length:n.getActiveMeshes().length;o.currentRenderPassId=this._renderPassIds[p],this.onBeforeRenderObservable.notifyObservers(p),this.getCustomRenderList&&(m=this.getCustomRenderList(p,S,_)),m||(m=S),this._doNotChangeAspectRatio||n.updateTransformMatrix(!0);for(let T=0;T<m.length&&u;++T){const E=m[T];if(E.isEnabled()&&!E.isBlocked&&E.isVisible&&E.subMeshes)if(this.customIsReadyFunction){if(!this.customIsReadyFunction(E,this.refreshRate,a)){u=!1;continue}}else if(!E.isReady(!0)){u=!1;continue}}this.onAfterRenderObservable.notifyObservers(p),(this.is2DArray||this.isCube)&&(n.incrementRenderId(),n.resetCachedMaterial())}}else if(this.is2DArray&&!this.isMulti)for(let f=0;f<this.getRenderLayers();f++)this._renderToTarget(0,e,i,f,h),n.incrementRenderId(),n.resetCachedMaterial();else if(this.isCube&&!this.isMulti)for(let f=0;f<6;f++)this._renderToTarget(f,e,i,void 0,h),n.incrementRenderId(),n.resetCachedMaterial();else this._renderToTarget(0,e,i,void 0,h);return this.onAfterUnbindObservable.notifyObservers(this),o.currentRenderPassId=c,d&&(n.activeCamera=d,(n.getEngine().scenes.length>1||this.activeCamera&&this.activeCamera!==n.activeCamera)&&n.setTransformMatrix(n.activeCamera.getViewMatrix(),n.activeCamera.getProjectionMatrix(!0)),o.setViewport(n.activeCamera.viewport)),n.resetCachedMaterial(),u}_bestReflectionRenderTargetDimension(e,i){const a=e*i,s=r.E.NearestPOT(a+16384/(128+a));return Math.min(r.E.FloorPOT(e),s)}_prepareRenderingManager(e,i,a,s){const n=this.getScene();if(!n)return;this._renderingManager.reset();const o=n.getRenderId();for(let c=0;c<i;c++){const h=e[c];if(h&&!h.isBlocked){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(h,this.refreshRate,!1)){this.resetRefreshCounter();continue}}else if(!h.isReady(0===this.refreshRate)){this.resetRefreshCounter();continue}if(!h._internalAbstractMeshDataInfo._currentLODIsUpToDate&&n.activeCamera&&(h._internalAbstractMeshDataInfo._currentLOD=n.customLODSelector?n.customLODSelector(h,this.activeCamera||n.activeCamera):h.getLOD(this.activeCamera||n.activeCamera),h._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0),!h._internalAbstractMeshDataInfo._currentLOD)continue;let u,d=h._internalAbstractMeshDataInfo._currentLOD;if(d._preActivateForIntermediateRendering(o),u=!(!s||!a)&&0==(h.layerMask&a.layerMask),h.isEnabled()&&h.isVisible&&h.subMeshes&&!u&&(d!==h&&d._activate(o,!0),h._activate(o,!0)&&h.subMeshes.length)){h.isAnInstance?h._internalAbstractMeshDataInfo._actAsRegularMesh&&(d=h):d._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!1,d._internalAbstractMeshDataInfo._isActiveIntermediate=!0;for(let f=0;f<d.subMeshes.length;f++)this._renderingManager.dispatch(d.subMeshes[f],d)}}}for(let c=0;c<n.particleSystems.length;c++){const h=n.particleSystems[c],d=h.emitter;!h.isStarted()||!d||d.position&&!d.isEnabled()||this._renderingManager.dispatchParticles(h)}}_bindFrameBuffer(e=0,i=0){const a=this.getScene();if(!a)return;const s=a.getEngine();this._renderTarget&&s.bindFramebuffer(this._renderTarget,this.isCube?e:void 0,void 0,void 0,this.ignoreCameraViewport,0,i)}_unbindFrameBuffer(e,i){this._renderTarget&&e.unBindFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(i)})}_prepareFrame(e,i,a,s){this._postProcessManager?this._prePassEnabled||this._postProcessManager._prepareFrame(this._texture,this._postProcesses):(!s||!e.postProcessManager._prepareFrame(this._texture))&&this._bindFrameBuffer(i,a)}_renderToTarget(e,i,a,s=0,n=null){var o,c,h,d,u,f;const p=this.getScene();if(!p)return;const m=p.getEngine();if(null===(o=m._debugPushGroup)||void 0===o||o.call(m,`render to face #${e} layer #${s}`,1),this._prepareFrame(p,e,s,i),this.is2DArray?(m.currentRenderPassId=this._renderPassIds[s],this.onBeforeRenderObservable.notifyObservers(s)):(m.currentRenderPassId=this._renderPassIds[e],this.onBeforeRenderObservable.notifyObservers(e)),m.snapshotRendering&&1===m.snapshotRenderingMode)this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(m):this.skipInitialClear||m.clear(this.clearColor||p.clearColor,!0,!0,!0);else{let S=null;const _=this.renderList?this.renderList:p.getActiveMeshes().data,T=this.renderList?this.renderList.length:p.getActiveMeshes().length;this.getCustomRenderList&&(S=this.getCustomRenderList(this.is2DArray?s:e,_,T)),S?this._prepareRenderingManager(S,S.length,n,this.forceLayerMaskCheck):(this._defaultRenderListPrepared||(this._prepareRenderingManager(_,T,n,!this.renderList||this.forceLayerMaskCheck),this._defaultRenderListPrepared=!0),S=_);for(const x of p._beforeRenderTargetClearStage)x.action(this,e,s);this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(m):this.skipInitialClear||m.clear(this.clearColor||p.clearColor,!0,!0,!0),this._doNotChangeAspectRatio||p.updateTransformMatrix(!0);for(const x of p._beforeRenderTargetDrawStage)x.action(this,e,s);this._renderingManager.render(this.customRenderFunction,S,this.renderParticles,this.renderSprites);for(const x of p._afterRenderTargetDrawStage)x.action(this,e,s);const E=null!==(h=null===(c=this._texture)||void 0===c?void 0:c.generateMipMaps)&&void 0!==h&&h;this._texture&&(this._texture.generateMipMaps=!1),this._postProcessManager?this._postProcessManager._finalizeFrame(!1,null!==(d=this._renderTarget)&&void 0!==d?d:void 0,e,this._postProcesses,this.ignoreCameraViewport):i&&p.postProcessManager._finalizeFrame(!1,null!==(u=this._renderTarget)&&void 0!==u?u:void 0,e);for(const x of p._afterRenderTargetPostProcessStage)x.action(this,e,s);this._texture&&(this._texture.generateMipMaps=E),this._doNotChangeAspectRatio||p.updateTransformMatrix(!0),a&&z.DumpFramebuffer(this.getRenderWidth(),this.getRenderHeight(),m)}this._unbindFrameBuffer(m,e),this._texture&&this.isCube&&5===e&&m.generateMipMapsForCubemap(this._texture),null===(f=m._debugPopGroup)||void 0===f||f.call(m,1)}setRenderingOrder(e,i=null,a=null,s=null){this._renderingManager.setRenderingOrder(e,i,a,s)}setRenderingAutoClearDepthStencil(e,i){this._renderingManager.setRenderingAutoClearDepthStencil(e,i),this._renderingManager._useSceneAutoClearSetup=!1}clone(){const e=this.getSize(),i=new l(this.name,e,this.getScene(),this._renderTargetOptions.generateMipMaps,this._doNotChangeAspectRatio,this._renderTargetOptions.type,this.isCube,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer,this._renderTargetOptions.generateStencilBuffer,void 0,this._renderTargetOptions.format,void 0,this._renderTargetOptions.samples);return i.hasAlpha=this.hasAlpha,i.level=this.level,i.coordinatesMode=this.coordinatesMode,this.renderList&&(i.renderList=this.renderList.slice(0)),i}serialize(){if(!this.name)return null;const e=super.serialize();if(e.renderTargetSize=this.getRenderSize(),e.renderList=[],this.renderList)for(let i=0;i<this.renderList.length;i++)e.renderList.push(this.renderList[i].id);return e}disposeFramebufferObjects(){var e;null===(e=this._renderTarget)||void 0===e||e.dispose(!0)}releaseInternalTexture(){var e;null===(e=this._renderTarget)||void 0===e||e.releaseTextures(),this._texture=null}dispose(){var e;this.onResizeObservable.clear(),this.onClearObservable.clear(),this.onAfterRenderObservable.clear(),this.onAfterUnbindObservable.clear(),this.onBeforeBindObservable.clear(),this.onBeforeRenderObservable.clear(),this._postProcessManager&&(this._postProcessManager.dispose(),this._postProcessManager=null),this._prePassRenderTarget&&this._prePassRenderTarget.dispose(),this._releaseRenderPassId(),this.clearPostProcesses(!0),this._resizeObserver&&(this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this.renderList=null;const i=this.getScene();if(!i)return;let a=i.customRenderTargets.indexOf(this);a>=0&&i.customRenderTargets.splice(a,1);for(const s of i.cameras)a=s.customRenderTargets.indexOf(this),a>=0&&s.customRenderTargets.splice(a,1);null===(e=this._renderTarget)||void 0===e||e.dispose(),this._renderTarget=null,this._texture=null,super.dispose()}_rebuild(){this.refreshRate===l.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=l.REFRESHRATE_RENDER_ONCE),this._postProcessManager&&this._postProcessManager._rebuild()}freeRenderingGroups(){this._renderingManager&&this._renderingManager.freeRenderingGroups()}getViewCount(){return 1}}return l.REFRESHRATE_RENDER_ONCE=0,l.REFRESHRATE_RENDER_ONEVERYFRAME=1,l.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=2,l})();g._CreateRenderTargetTexture=(l,t,e,i,a)=>new de(l,t,e,i);let y=(()=>{class l{static RegisterShaderCodeProcessing(e,i){i?l._CustomShaderCodeProcessing[e??""]=i:delete l._CustomShaderCodeProcessing[e??""]}static _GetShaderCodeProcessing(e){var i;return null!==(i=l._CustomShaderCodeProcessing[e])&&void 0!==i?i:l._CustomShaderCodeProcessing[""]}get samples(){return this._samples}set samples(e){this._samples=Math.min(e,this._engine.getCaps().maxMSAASamples),this._textures.forEach(i=>{i.setSamples(this._samples)})}getEffectName(){return this._fragmentUrl}set onActivate(e){this._onActivateObserver&&this.onActivateObservable.remove(this._onActivateObserver),e&&(this._onActivateObserver=this.onActivateObservable.add(e))}set onSizeChanged(e){this._onSizeChangedObserver&&this.onSizeChangedObservable.remove(this._onSizeChangedObserver),this._onSizeChangedObserver=this.onSizeChangedObservable.add(e)}set onApply(e){this._onApplyObserver&&this.onApplyObservable.remove(this._onApplyObserver),this._onApplyObserver=this.onApplyObservable.add(e)}set onBeforeRender(e){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(e)}set onAfterRender(e){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(e)}get inputTexture(){return this._textures.data[this._currentRenderTextureInd]}set inputTexture(e){this._forcedOutputTexture=e}restoreDefaultInputTexture(){this._forcedOutputTexture&&(this._forcedOutputTexture=null,this.markTextureDirty())}getCamera(){return this._camera}get texelSize(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.texelSize:(this._forcedOutputTexture&&this._texelSize.copyFromFloats(1/this._forcedOutputTexture.width,1/this._forcedOutputTexture.height),this._texelSize)}constructor(e,i,a,s,n,o,c=1,h,d,u=null,f=0,p="postprocess",m,S=!1,_=5,T=r.Z.GLSL){this._parentContainer=null,this.width=-1,this.height=-1,this.nodeMaterialSource=null,this._outputTexture=null,this.autoClear=!0,this.forceAutoClearInAlphaMode=!1,this.alphaMode=0,this.animations=new Array,this.enablePixelPerfectMode=!1,this.forceFullscreenViewport=!0,this.scaleMode=1,this.alwaysForcePOT=!1,this._samples=1,this.adaptScaleToCurrentViewport=!1,this._reusable=!1,this._renderId=0,this.externalTextureSamplerBinding=!1,this._textures=new r.Y(2),this._textureCache=[],this._currentRenderTextureInd=0,this._scaleRatio=new r.d(1,1),this._texelSize=r.d.Zero(),this.onActivateObservable=new r.O,this.onSizeChangedObservable=new r.O,this.onApplyObservable=new r.O,this.onBeforeRenderObservable=new r.O,this.onAfterRenderObservable=new r.O,this.name=e,null!=o?(this._camera=o,this._scene=o.getScene(),o.attachPostProcess(this),this._engine=this._scene.getEngine(),this._scene.postProcesses.push(this),this.uniqueId=this._scene.getUniqueId()):h&&(this._engine=h,this._engine.postProcesses.push(this)),this._options=n,this.renderTargetSamplingMode=c||1,this._reusable=d||!1,this._textureType=f,this._textureFormat=_,this._shaderLanguage=T,this._samplers=s||[],this._samplers.push("textureSampler"),this._fragmentUrl=i,this._vertexUrl=p,this._parameters=a||[],this._parameters.push("scale"),this._indexParameters=m,this._drawWrapper=new r.B(this._engine),S||this.updateEffect(u)}getClassName(){return"PostProcess"}getEngine(){return this._engine}getEffect(){return this._drawWrapper.effect}shareOutputWith(e){return this._disposeTextures(),this._shareOutputWithPostProcess=e,this}useOwnOutput(){0==this._textures.length&&(this._textures=new r.Y(2)),this._shareOutputWithPostProcess=null}updateEffect(e=null,i=null,a=null,s,n,o,c,h){var d,u;const f=l._GetShaderCodeProcessing(this.name);if(null!=f&&f.defineCustomBindings){const p=null!==(d=i?.slice())&&void 0!==d?d:[];p.push(...this._parameters);const m=null!==(u=a?.slice())&&void 0!==u?u:[];m.push(...this._samplers),e=f.defineCustomBindings(this.name,e,p,m),i=p,a=m}this._postProcessDefines=e,this._drawWrapper.effect=this._engine.createEffect({vertex:c??this._vertexUrl,fragment:h??this._fragmentUrl},{attributes:["position"],uniformsNames:i||this._parameters,uniformBuffersNames:[],samplers:a||this._samplers,defines:null!==e?e:"",fallbacks:null,onCompiled:n??null,onError:o??null,indexParameters:s||this._indexParameters,processCodeAfterIncludes:null!=f&&f.processCodeAfterIncludes?(p,m)=>f.processCodeAfterIncludes(this.name,p,m):null,processFinalCode:null!=f&&f.processFinalCode?(p,m)=>f.processFinalCode(this.name,p,m):null,shaderLanguage:this._shaderLanguage},this._engine)}isReusable(){return this._reusable}markTextureDirty(){this.width=-1}_createRenderTargetTexture(e,i,a=0){for(let n=0;n<this._textureCache.length;n++)if(this._textureCache[n].texture.width===e.width&&this._textureCache[n].texture.height===e.height&&this._textureCache[n].postProcessChannel===a&&this._textureCache[n].texture._generateDepthBuffer===i.generateDepthBuffer&&this._textureCache[n].texture.samples===i.samples)return this._textureCache[n].texture;const s=this._engine.createRenderTargetTexture(e,i);return this._textureCache.push({texture:s,postProcessChannel:a,lastUsedRenderId:-1}),s}_flushTextureCache(){const e=this._renderId;for(let i=this._textureCache.length-1;i>=0;i--)if(e-this._textureCache[i].lastUsedRenderId>100){let a=!1;for(let s=0;s<this._textures.length;s++)if(this._textures.data[s]===this._textureCache[i].texture){a=!0;break}a||(this._textureCache[i].texture.dispose(),this._textureCache.splice(i,1))}}_resize(e,i,a,s,n){this._textures.length>0&&this._textures.reset(),this.width=e,this.height=i;let o=null;for(let d=0;d<a._postProcesses.length;d++)if(null!==a._postProcesses[d]){o=a._postProcesses[d];break}const c={width:this.width,height:this.height},h={generateMipMaps:s,generateDepthBuffer:n||o===this,generateStencilBuffer:(n||o===this)&&this._engine.isStencilEnable,samplingMode:this.renderTargetSamplingMode,type:this._textureType,format:this._textureFormat,samples:this._samples,label:"PostProcessRTT-"+this.name};this._textures.push(this._createRenderTargetTexture(c,h,0)),this._reusable&&this._textures.push(this._createRenderTargetTexture(c,h,1)),this._texelSize.copyFromFloats(1/this.width,1/this.height),this.onSizeChangedObservable.notifyObservers(this)}activate(e,i=null,a){var s,n;const o=(e=e||this._camera).getScene(),c=o.getEngine(),h=c.getCaps().maxTextureSize;let d=(i?i.width:this._engine.getRenderWidth(!0))*this._options|0;const u=(i?i.height:this._engine.getRenderHeight(!0))*this._options|0,f=e.parent;f&&(f.leftCamera==e||f.rightCamera==e)&&(d/=2);let p=this._options.width||d,m=this._options.height||u;const S=7!==this.renderTargetSamplingMode&&1!==this.renderTargetSamplingMode&&2!==this.renderTargetSamplingMode;if(!this._shareOutputWithPostProcess&&!this._forcedOutputTexture){if(this.adaptScaleToCurrentViewport){const T=c.currentViewport;T&&(p*=T.width,m*=T.height)}(S||this.alwaysForcePOT)&&(this._options.width||(p=c.needPOTTextures?r.E.GetExponentOfTwo(p,h,this.scaleMode):p),this._options.height||(m=c.needPOTTextures?r.E.GetExponentOfTwo(m,h,this.scaleMode):m)),(this.width!==p||this.height!==m)&&this._resize(p,m,e,S,a),this._textures.forEach(T=>{T.samples!==this.samples&&this._engine.updateRenderTargetTextureSampleCount(T,this.samples)}),this._flushTextureCache(),this._renderId++}let _;if(this._shareOutputWithPostProcess)_=this._shareOutputWithPostProcess.inputTexture;else if(this._forcedOutputTexture)_=this._forcedOutputTexture,this.width=this._forcedOutputTexture.width,this.height=this._forcedOutputTexture.height;else{let T;_=this.inputTexture;for(let E=0;E<this._textureCache.length;E++)if(this._textureCache[E].texture===_){T=this._textureCache[E];break}T&&(T.lastUsedRenderId=this._renderId)}return this.enablePixelPerfectMode?(this._scaleRatio.copyFromFloats(d/p,u/m),this._engine.bindFramebuffer(_,0,d,u,this.forceFullscreenViewport)):(this._scaleRatio.copyFromFloats(1,1),this._engine.bindFramebuffer(_,0,void 0,void 0,this.forceFullscreenViewport)),null===(n=(s=this._engine)._debugInsertMarker)||void 0===n||n.call(s,`post process ${this.name} input`),this.onActivateObservable.notifyObservers(e),this.autoClear&&(0===this.alphaMode||this.forceAutoClearInAlphaMode)&&this._engine.clear(this.clearColor?this.clearColor:o.clearColor,o._allowPostProcessClearColor,!0,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2),_}get isSupported(){return this._drawWrapper.effect.isSupported}get aspectRatio(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.aspectRatio:this._forcedOutputTexture?this._forcedOutputTexture.width/this._forcedOutputTexture.height:this.width/this.height}isReady(){var e,i;return null!==(i=null===(e=this._drawWrapper.effect)||void 0===e?void 0:e.isReady())&&void 0!==i&&i}apply(){var e,i,a;if(null===(e=this._drawWrapper.effect)||void 0===e||!e.isReady())return null;let s;return this._engine.enableEffect(this._drawWrapper),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._engine.setAlphaMode(this.alphaMode),this.alphaConstants&&this.getEngine().setAlphaConstants(this.alphaConstants.r,this.alphaConstants.g,this.alphaConstants.b,this.alphaConstants.a),s=this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.inputTexture:this._forcedOutputTexture?this._forcedOutputTexture:this.inputTexture,this.externalTextureSamplerBinding||this._drawWrapper.effect._bindTexture("textureSampler",s?.texture),this._drawWrapper.effect.setVector2("scale",this._scaleRatio),this.onApplyObservable.notifyObservers(this._drawWrapper.effect),null===(a=null===(i=l._GetShaderCodeProcessing(this.name))||void 0===i?void 0:i.bindCustomBindings)||void 0===a||a.call(i,this.name,this._drawWrapper.effect),this._drawWrapper.effect}_disposeTextures(){this._shareOutputWithPostProcess||this._forcedOutputTexture?this._disposeTextureCache():(this._disposeTextureCache(),this._textures.dispose())}_disposeTextureCache(){for(let e=this._textureCache.length-1;e>=0;e--)this._textureCache[e].texture.dispose();this._textureCache.length=0}setPrePassRenderer(e){return!!this._prePassEffectConfiguration&&(this._prePassEffectConfiguration=e.addEffectConfiguration(this._prePassEffectConfiguration),this._prePassEffectConfiguration.enabled=!0,!0)}dispose(e){let i;if(e=e||this._camera,this._disposeTextures(),this._scene&&(i=this._scene.postProcesses.indexOf(this),-1!==i&&this._scene.postProcesses.splice(i,1)),this._parentContainer){const a=this._parentContainer.postProcesses.indexOf(this);a>-1&&this._parentContainer.postProcesses.splice(a,1),this._parentContainer=null}if(i=this._engine.postProcesses.indexOf(this),-1!==i&&this._engine.postProcesses.splice(i,1),e){if(e.detachPostProcess(this),i=e._postProcesses.indexOf(this),0===i&&e._postProcesses.length>0){const a=this._camera._getFirstPostProcess();a&&a.markTextureDirty()}this.onActivateObservable.clear(),this.onAfterRenderObservable.clear(),this.onApplyObservable.clear(),this.onBeforeRenderObservable.clear(),this.onSizeChangedObservable.clear()}}serialize(){const e=r.j.Serialize(this),i=this.getCamera()||this._scene&&this._scene.activeCamera;return e.customType="BABYLON."+this.getClassName(),e.cameraId=i?i.id:null,e.reusable=this._reusable,e.textureType=this._textureType,e.fragmentUrl=this._fragmentUrl,e.parameters=this._parameters,e.samplers=this._samplers,e.options=this._options,e.defines=this._postProcessDefines,e.textureFormat=this._textureFormat,e.vertexUrl=this._vertexUrl,e.indexParameters=this._indexParameters,e}clone(){const e=this.serialize();e._engine=this._engine,e.cameraId=null;const i=l.Parse(e,this._scene,"");return i?(i.onActivateObservable=this.onActivateObservable.clone(),i.onSizeChangedObservable=this.onSizeChangedObservable.clone(),i.onApplyObservable=this.onApplyObservable.clone(),i.onBeforeRenderObservable=this.onBeforeRenderObservable.clone(),i.onAfterRenderObservable=this.onAfterRenderObservable.clone(),i._prePassEffectConfiguration=this._prePassEffectConfiguration,i):null}static Parse(e,i,a){const s=(0,r.G)(e.customType);if(!s||!s._Parse)return null;const n=i?i.getCameraById(e.cameraId):null;return s._Parse(e,n,i,a)}static _Parse(e,i,a,s){return r.j.Parse(()=>new l(e.name,e.fragmentUrl,e.parameters,e.samplers,e.options,i,e.renderTargetSamplingMode,e._engine,e.reusable,e.defines,e.textureType,e.vertexUrl,e.indexParameters,!1,e.textureFormat),e,a,s)}}return l._CustomShaderCodeProcessing={},l})();(0,r._)([(0,r.f)()],y.prototype,"uniqueId",void 0),(0,r._)([(0,r.f)()],y.prototype,"name",void 0),(0,r._)([(0,r.f)()],y.prototype,"width",void 0),(0,r._)([(0,r.f)()],y.prototype,"height",void 0),(0,r._)([(0,r.f)()],y.prototype,"renderTargetSamplingMode",void 0),(0,r._)([(0,r.X)()],y.prototype,"clearColor",void 0),(0,r._)([(0,r.f)()],y.prototype,"autoClear",void 0),(0,r._)([(0,r.f)()],y.prototype,"forceAutoClearInAlphaMode",void 0),(0,r._)([(0,r.f)()],y.prototype,"alphaMode",void 0),(0,r._)([(0,r.f)()],y.prototype,"alphaConstants",void 0),(0,r._)([(0,r.f)()],y.prototype,"enablePixelPerfectMode",void 0),(0,r._)([(0,r.f)()],y.prototype,"forceFullscreenViewport",void 0),(0,r._)([(0,r.f)()],y.prototype,"scaleMode",void 0),(0,r._)([(0,r.f)()],y.prototype,"alwaysForcePOT",void 0),(0,r._)([(0,r.f)("samples")],y.prototype,"_samples",void 0),(0,r._)([(0,r.f)()],y.prototype,"adaptScaleToCurrentViewport",void 0),(0,r.r)("BABYLON.PostProcess",y),r.x.IncludesShadersStore.kernelBlurVaryingDeclaration="varying vec2 sampleCoord{X};",r.x.IncludesShadersStore.packingFunctions="vec4 pack(float depth)\n{\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\nvec4 res=fract(depth*bit_shift);\nres-=res.xxyz*bit_mask;\nreturn res;\n}\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}",r.x.IncludesShadersStore.kernelBlurFragment="#ifdef DOF\nfactor=sampleCoC(sampleCoord{X}); \ncomputedWeight=KERNEL_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;\n#endif\n",r.x.IncludesShadersStore.kernelBlurFragment2="#ifdef DOF\nfactor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});\ncomputedWeight=KERNEL_DEP_WEIGHT{X}*factor;\nsumOfWeights+=computedWeight;\n#else\ncomputedWeight=KERNEL_DEP_WEIGHT{X};\n#endif\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;\n#else\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;\n#endif\n",r.x.ShadersStore.kernelBlurPixelShader="uniform sampler2D textureSampler;\nuniform vec2 delta;\nvarying vec2 sampleCenter;\n#ifdef DOF\nuniform sampler2D circleOfConfusionSampler;\nfloat sampleCoC(in vec2 offset) {\nfloat coc=texture2D(circleOfConfusionSampler,offset).r;\nreturn coc; \n}\n#endif\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\n#ifdef PACKEDFLOAT\n#include<packingFunctions>\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\nfloat computedWeight=0.0;\n#ifdef PACKEDFLOAT\nfloat blend=0.;\n#else\nvec4 blend=vec4(0.);\n#endif\n#ifdef DOF\nfloat sumOfWeights=CENTER_WEIGHT; \nfloat factor=0.0;\n#ifdef PACKEDFLOAT\nblend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;\n#else\nblend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;\n#endif\n#endif\n#include<kernelBlurFragment>[0..varyingCount]\n#include<kernelBlurFragment2>[0..depCount]\n#ifdef PACKEDFLOAT\ngl_FragColor=pack(blend);\n#else\ngl_FragColor=blend;\n#endif\n#ifdef DOF\ngl_FragColor/=sumOfWeights;\n#endif\n}",r.x.IncludesShadersStore.kernelBlurVertex="sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};",r.x.ShadersStore.kernelBlurVertexShader="attribute vec2 position;\nuniform vec2 delta;\nvarying vec2 sampleCenter;\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\nconst vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nsampleCenter=(position*madd+madd);\n#include<kernelBlurVertex>[0..varyingCount]\ngl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";class se extends y{set kernel(t){this._idealKernel!==t&&(t=Math.max(t,1),this._idealKernel=t,this._kernel=this._nearestBestKernel(t),this._blockCompilation||this._updateParameters())}get kernel(){return this._idealKernel}set packedFloat(t){this._packedFloat!==t&&(this._packedFloat=t,this._blockCompilation||this._updateParameters())}get packedFloat(){return this._packedFloat}getClassName(){return"BlurPostProcess"}constructor(t,e,i,a,s,n=g.BILINEAR_SAMPLINGMODE,o,c,h=0,d="",u=!1,f=5){super(t,"kernelBlur",["delta","direction"],["circleOfConfusionSampler"],a,s,n,o,c,null,h,"kernelBlur",{varyingCount:0,depCount:0},!0,f),this._blockCompilation=u,this._packedFloat=!1,this._staticDefines="",this._staticDefines=d,this.direction=e,this.onApplyObservable.add(p=>{this._outputTexture?p.setFloat2("delta",1/this._outputTexture.width*this.direction.x,1/this._outputTexture.height*this.direction.y):p.setFloat2("delta",1/this.width*this.direction.x,1/this.height*this.direction.y)}),this.kernel=i}updateEffect(t=null,e=null,i=null,a,s,n){this._updateParameters(s,n)}_updateParameters(t,e){const i=this._kernel,a=(i-1)/2;let s=[],n=[],o=0;for(let _=0;_<i;_++){const E=this._gaussianWeight(_/(i-1)*2-1);s[_]=_-a,n[_]=E,o+=E}for(let _=0;_<n.length;_++)n[_]/=o;const c=[],h=[],d=[];for(let _=0;_<=a;_+=2){const T=Math.min(_+1,Math.floor(a));if(_===T)d.push({o:s[_],w:n[_]});else{const x=n[_]+n[T]*(T===a?.5:1),R=s[_]+1/(1+n[_]/n[T]);0===R?(d.push({o:s[_],w:n[_]}),d.push({o:s[_+1],w:n[_+1]})):(d.push({o:R,w:x}),d.push({o:-R,w:x}))}}for(let _=0;_<d.length;_++)h[_]=d[_].o,c[_]=d[_].w;s=h,n=c;const u=this.getEngine().getCaps().maxVaryingVectors,f=Math.max(u,0)-1;let p=Math.min(s.length,f),m="";m+=this._staticDefines,-1!=this._staticDefines.indexOf("DOF")&&(m+=`#define CENTER_WEIGHT ${this._glslFloat(n[p-1])}\r\n`,p--);for(let _=0;_<p;_++)m+=`#define KERNEL_OFFSET${_} ${this._glslFloat(s[_])}\r\n`,m+=`#define KERNEL_WEIGHT${_} ${this._glslFloat(n[_])}\r\n`;let S=0;for(let _=f;_<s.length;_++)m+=`#define KERNEL_DEP_OFFSET${S} ${this._glslFloat(s[_])}\r\n`,m+=`#define KERNEL_DEP_WEIGHT${S} ${this._glslFloat(n[_])}\r\n`,S++;this.packedFloat&&(m+="#define PACKEDFLOAT 1"),this._blockCompilation=!1,super.updateEffect(m,null,null,{varyingCount:p,depCount:S},t,e)}_nearestBestKernel(t){const e=Math.round(t);for(const i of[e,e-1,e+1,e-2,e+2])if(i%2!=0&&Math.floor(i/2)%2==0&&i>0)return Math.max(i,3);return Math.max(e,3)}_gaussianWeight(t){const e=.3333333333333333;return 1/(Math.sqrt(2*Math.PI)*e)*Math.exp(-t*t/(2*e*e))}_glslFloat(t,e=8){return t.toFixed(e).replace(/0+$/,"")}static _Parse(t,e,i,a){return r.j.Parse(()=>new se(t.name,t.direction,t.kernel,t.options,e,t.renderTargetSamplingMode,i.getEngine(),t.reusable,t.textureType,void 0,!1),t,i,a)}}(0,r._)([(0,r.f)("kernel")],se.prototype,"_kernel",void 0),(0,r._)([(0,r.f)("packedFloat")],se.prototype,"_packedFloat",void 0),(0,r._)([(0,r.$)()],se.prototype,"direction",void 0),(0,r.r)("BABYLON.BlurPostProcess",se);class Be{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(t,e){this._defines[t]||(t<this._currentRank&&(this._currentRank=t),t>this._maxRank&&(this._maxRank=t),this._defines[t]=new Array),this._defines[t].push(e)}addCPUSkinningFallback(t,e){this._mesh=e,t<this._currentRank&&(this._currentRank=t),t>this._maxRank&&(this._maxRank=t)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(t,e){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,t=t.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),e._bonesComputationForcedToCPU=!0;const i=this._mesh.getScene();for(let a=0;a<i.meshes.length;a++){const s=i.meshes[a];if(s.material){if(s.computeBonesUsingShaders&&0!==s.numBoneInfluencers)if(s.material.getEffect()===e)s.computeBonesUsingShaders=!1;else if(s.subMeshes)for(const n of s.subMeshes)if(n.effect===e){s.computeBonesUsingShaders=!1;break}}else!this._mesh.material&&s.computeBonesUsingShaders&&s.numBoneInfluencers>0&&(s.computeBonesUsingShaders=!1)}}else{const i=this._defines[this._currentRank];if(i)for(let a=0;a<i.length;a++)t=t.replace("#define "+i[a],"");this._currentRank++}return t}}r.x.IncludesShadersStore.bayerDitherFunctions="float bayerDither2(vec2 _P) {\nreturn mod(2.0*_P.y+_P.x+1.0,4.0);\n}\nfloat bayerDither4(vec2 _P) {\nvec2 P1=mod(_P,2.0); \nvec2 P2=floor(0.5*mod(_P,4.0)); \nreturn 4.0*bayerDither2(P1)+bayerDither2(P2);\n}\nfloat bayerDither8(vec2 _P) {\nvec2 P1=mod(_P,2.0); \nvec2 P2=floor(0.5 *mod(_P,4.0)); \nvec2 P4=floor(0.25*mod(_P,8.0)); \nreturn 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);\n}\n",r.x.IncludesShadersStore.shadowMapFragmentExtraDeclaration="#if SM_FLOAT==0\n#include<packingFunctions>\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#include<bayerDitherFunctions>\nuniform float softTransparentShadowSM;\n#endif\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE==1\nuniform vec3 lightDataSM;\nvarying vec3 vPositionWSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\n#endif\n",r.x.IncludesShadersStore.clipPlaneFragmentDeclaration="#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n",r.x.IncludesShadersStore.clipPlaneFragment="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{\ndiscard;\n}\n#endif\n",r.x.IncludesShadersStore.shadowMapFragment="float depthSM=vDepthMetricSM;\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\n#if SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\ndepthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\ndepthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_FragDepth=clamp(1.0-depthSM,0.0,1.0);\n#else\ngl_FragDepth=clamp(depthSM,0.0,1.0); \n#endif\n#elif SM_USEDISTANCE==1\ndepthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#if SM_ESM==1\ndepthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);\n#endif\n#if SM_FLOAT==1\ngl_FragColor=vec4(depthSM,1.0,1.0,1.0);\n#else\ngl_FragColor=pack(depthSM);\n#endif\nreturn;",r.x.ShadersStore.shadowMapPixelShader="#include<shadowMapFragmentExtraDeclaration>\n#ifdef ALPHATEXTURE\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEXTURE\nfloat alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;\n#ifdef ALPHATESTVALUE\nif (alphaFromAlphaTexture<ALPHATESTVALUE)\ndiscard;\n#endif\n#endif\n#if SM_SOFTTRANSPARENTSHADOW==1\n#ifdef ALPHATEXTURE\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;\n#else\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;\n#endif\n#endif\n#include<shadowMapFragment>\n}",r.x.IncludesShadersStore.bonesDeclaration="#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;\nattribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;\nattribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform sampler2D boneSampler;\nuniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{\nfloat offset=index *4.0;\nfloat dx=1.0/boneTextureWidth;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.bakedVertexAnimationDeclaration="#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;\nuniform vec2 bakedVertexAnimationTextureSizeInverted;\nuniform vec4 bakedVertexAnimationSettings;\nuniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{\nfloat offset=index*4.0;\nfloat frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;\nfloat dx=bakedVertexAnimationTextureSizeInverted.x;\nvec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));\nvec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));\nvec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));\nvec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));\nreturn mat4(m0,m1,m2,m3);\n}\n#endif\n",r.x.IncludesShadersStore.morphTargetsVertexGlobalDeclaration="#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nprecision mediump sampler2DArray; \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];\nuniform vec3 morphTargetTextureInfo;\nuniform sampler2DArray morphTargets;\nvec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);\nfloat x=vertexIndex-y*morphTargetTextureInfo.y;\nvec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);\nreturn texture(morphTargets,textureUV).xyz;\n}\n#endif\n#endif\n",r.x.IncludesShadersStore.morphTargetsVertexDeclaration="#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.helperFunctions="const float PI=3.1415926535897932384626433832795;\nconst float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\nconst float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}\nmat3 inverseMat3(mat3 inMatrix) {\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\nfloat b01=a22*a11-a12*a21;\nfloat b11=-a22*a10+a12*a20;\nfloat b21=a21*a10-a11*a20;\nfloat det=a00*b01+a01*b11+a02*b21;\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{\nvec3 nearZeroSection=0.0773993808*color;\nvec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{\nvec3 nearZeroSection=12.92*color;\nvec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;\nfloat remainingSection=pow(0.947867299*(color+0.055),2.4);\nreturn color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;\nfloat remainingSection=1.055*pow(color,0.41666)-0.055;\nreturn color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{\nreturn value*value;\n}\nvec3 square(vec3 value)\n{\nreturn value*value;\n}\nfloat pow5(float value) {\nfloat sq=value*value;\nreturn sq*sq*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\n}\nfloat getRand(vec2 seed) {\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat dither(vec2 seed,float varianceAmount) {\nfloat rand=getRand(seed);\nfloat normVariance=varianceAmount/255.0;\nfloat dither=mix(-normVariance,normVariance,rand);\nreturn dither;\n}\nconst float rgbdMaxRange=255.0;\nvec4 toRGBD(vec3 color) {\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\nfloat D =max(rgbdMaxRange/maxRGB,1.);\nD =clamp(floor(D)/255.0,0.,1.);\nvec3 rgb=color.rgb*D;\nrgb=toGammaSpace(rgb);\nreturn vec4(clamp(rgb,0.,1.),D); \n}\nvec3 fromRGBD(vec4 rgbd) {\nrgbd.rgb=toLinearSpace(rgbd.rgb);\nreturn rgbd.rgb/rgbd.a;\n}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\nvec3 halfSize=cubeSize*0.5;\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\nvec3 intersectPositionWS=vertexPos+origVec*distance;\nreturn intersectPositionWS-cubePos;\n}\n",r.x.IncludesShadersStore.sceneVertexDeclaration="uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec4 vEyePosition;\n",r.x.IncludesShadersStore.meshVertexDeclaration="uniform mat4 world;\nuniform float visibility;\n",r.x.IncludesShadersStore.shadowMapVertexDeclaration="#include<sceneVertexDeclaration>\n#include<meshVertexDeclaration>\n",r.x.IncludesShadersStore.sceneUboDeclaration="layout(std140,column_major) uniform;\nuniform Scene {\nmat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;\nmat4 projection;\nvec4 vEyePosition;\n};\n",r.x.IncludesShadersStore.meshUboDeclaration="#ifdef WEBGL2\nuniform mat4 world;\nuniform float visibility;\n#else\nlayout(std140,column_major) uniform;\nuniform Mesh\n{\nmat4 world;\nfloat visibility;\n};\n#endif\n#define WORLD_UBO\n",r.x.IncludesShadersStore.shadowMapUboDeclaration="layout(std140,column_major) uniform;\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",r.x.IncludesShadersStore.shadowMapVertexExtraDeclaration="#if SM_NORMALBIAS==1\nuniform vec3 lightDataSM;\n#endif\nuniform vec3 biasAndScaleSM;\nuniform vec2 depthValuesSM;\nvarying float vDepthMetricSM;\n#if SM_USEDISTANCE==1\nvarying vec3 vPositionWSM;\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nvarying float zSM;\n#endif\n",r.x.IncludesShadersStore.clipPlaneVertexDeclaration="#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nvarying float fClipDistance6;\n#endif\n",r.x.IncludesShadersStore.morphTargetsVertexGlobal="#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n",r.x.IncludesShadersStore.morphTargetsVertex="#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE \nvertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\npositionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.instancesVertex="#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n",r.x.IncludesShadersStore.bonesVertex="#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n",r.x.IncludesShadersStore.bakedVertexAnimation="#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;\nfloat VATEndFrame=BVASNAME.y;\nfloat VATOffsetFrame=BVASNAME.z;\nfloat VATSpeed=BVASNAME.w;\nfloat totalFrames=VATEndFrame-VATStartFrame+1.0;\nfloat time=bakedVertexAnimationTime*VATSpeed/totalFrames;\nfloat frameCorrection=time<1.0 ? 0.0 : 1.0;\nfloat numOfFrames=totalFrames-frameCorrection;\nfloat VATFrameNum=fract(time)*numOfFrames;\nVATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);\nVATFrameNum=floor(VATFrameNum);\nVATFrameNum+=VATStartFrame+frameCorrection;\nmat4 VATInfluence;\nVATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;\n}\n#endif\n",r.x.IncludesShadersStore.shadowMapVertexNormalBias="#if SM_NORMALBIAS==1\n#if SM_DIRECTIONINLIGHTDATA==1\nvec3 worldLightDirSM=normalize(-lightDataSM.xyz);\n#else\nvec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;\nvec3 worldLightDirSM=normalize(directionToLightSM);\n#endif\nfloat ndlSM=dot(vNormalW,worldLightDirSM);\nfloat sinNLSM=sqrt(1.0-ndlSM*ndlSM);\nfloat normalBiasSM=biasAndScaleSM.y*sinNLSM;\nworldPos.xyz-=vNormalW*normalBiasSM;\n#endif\n",r.x.IncludesShadersStore.shadowMapVertexMetric="#if SM_USEDISTANCE==1\nvPositionWSM=worldPos.xyz;\n#endif\n#if SM_DEPTHTEXTURE==1\n#ifdef IS_NDC_HALF_ZRANGE\n#define BIASFACTOR 0.5\n#else\n#define BIASFACTOR 1.0\n#endif\n#ifdef USE_REVERSE_DEPTHBUFFER\ngl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#else\ngl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;\n#endif\n#endif\n#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1\nzSM=gl_Position.z;\ngl_Position.z=0.0;\n#elif SM_USEDISTANCE==0\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#else\nvDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;\n#endif\n#endif\n",r.x.IncludesShadersStore.clipPlaneVertex="#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n",r.x.ShadersStore.shadowMapVertexShader="attribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#endif\n#include<helperFunctions>\n#include<__decl__shadowMapVertex>\n#ifdef ALPHATEXTURE\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#include<shadowMapVertexExtraDeclaration>\n#include<clipPlaneVertexDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normWorldSM=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));\nvNormalW=normalize(normWorldSM*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormWorldSM=transposeMat3(inverseMat3(normWorldSM));\n#endif\nvec3 vNormalW=normalize(normWorldSM*normalUpdated);\n#endif\n#endif\n#include<shadowMapVertexNormalBias>\ngl_Position=viewProjection*worldPos;\n#include<shadowMapVertexMetric>\n#ifdef ALPHATEXTURE\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n#include<clipPlaneVertex>\n}",r.x.ShadersStore.depthBoxBlurPixelShader="varying vec2 vUV;\nuniform sampler2D textureSampler;\nuniform vec2 screenSize;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\nvec4 colorDepth=vec4(0.0);\nfor (int x=-OFFSET; x<=OFFSET; x++)\nfor (int y=-OFFSET; y<=OFFSET; y++)\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\n}",r.x.IncludesShadersStore.shadowMapFragmentSoftTransparentShadow="#if SM_SOFTTRANSPARENTSHADOW==1\nif ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;\n#endif\n";let G=(()=>{class l{get bias(){return this._bias}set bias(e){this._bias=e}get normalBias(){return this._normalBias}set normalBias(e){this._normalBias=e}get blurBoxOffset(){return this._blurBoxOffset}set blurBoxOffset(e){this._blurBoxOffset!==e&&(this._blurBoxOffset=e,this._disposeBlurPostProcesses())}get blurScale(){return this._blurScale}set blurScale(e){this._blurScale!==e&&(this._blurScale=e,this._disposeBlurPostProcesses())}get blurKernel(){return this._blurKernel}set blurKernel(e){this._blurKernel!==e&&(this._blurKernel=e,this._disposeBlurPostProcesses())}get useKernelBlur(){return this._useKernelBlur}set useKernelBlur(e){this._useKernelBlur!==e&&(this._useKernelBlur=e,this._disposeBlurPostProcesses())}get depthScale(){return void 0!==this._depthScale?this._depthScale:this._light.getDepthScale()}set depthScale(e){this._depthScale=e}_validateFilter(e){return e}get filter(){return this._filter}set filter(e){if(e=this._validateFilter(e),this._light.needCube()){if(e===l.FILTER_BLUREXPONENTIALSHADOWMAP)return void(this.useExponentialShadowMap=!0);if(e===l.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP)return void(this.useCloseExponentialShadowMap=!0);if(e===l.FILTER_PCF||e===l.FILTER_PCSS)return void(this.usePoissonSampling=!0)}e!==l.FILTER_PCF&&e!==l.FILTER_PCSS||this._scene.getEngine()._features.supportShadowSamplers?this._filter!==e&&(this._filter=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty()):this.usePoissonSampling=!0}get usePoissonSampling(){return this.filter===l.FILTER_POISSONSAMPLING}set usePoissonSampling(e){const i=this._validateFilter(l.FILTER_POISSONSAMPLING);!e&&this.filter!==l.FILTER_POISSONSAMPLING||(this.filter=e?i:l.FILTER_NONE)}get useExponentialShadowMap(){return this.filter===l.FILTER_EXPONENTIALSHADOWMAP}set useExponentialShadowMap(e){const i=this._validateFilter(l.FILTER_EXPONENTIALSHADOWMAP);!e&&this.filter!==l.FILTER_EXPONENTIALSHADOWMAP||(this.filter=e?i:l.FILTER_NONE)}get useBlurExponentialShadowMap(){return this.filter===l.FILTER_BLUREXPONENTIALSHADOWMAP}set useBlurExponentialShadowMap(e){const i=this._validateFilter(l.FILTER_BLUREXPONENTIALSHADOWMAP);!e&&this.filter!==l.FILTER_BLUREXPONENTIALSHADOWMAP||(this.filter=e?i:l.FILTER_NONE)}get useCloseExponentialShadowMap(){return this.filter===l.FILTER_CLOSEEXPONENTIALSHADOWMAP}set useCloseExponentialShadowMap(e){const i=this._validateFilter(l.FILTER_CLOSEEXPONENTIALSHADOWMAP);!e&&this.filter!==l.FILTER_CLOSEEXPONENTIALSHADOWMAP||(this.filter=e?i:l.FILTER_NONE)}get useBlurCloseExponentialShadowMap(){return this.filter===l.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP}set useBlurCloseExponentialShadowMap(e){const i=this._validateFilter(l.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);!e&&this.filter!==l.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP||(this.filter=e?i:l.FILTER_NONE)}get usePercentageCloserFiltering(){return this.filter===l.FILTER_PCF}set usePercentageCloserFiltering(e){const i=this._validateFilter(l.FILTER_PCF);!e&&this.filter!==l.FILTER_PCF||(this.filter=e?i:l.FILTER_NONE)}get filteringQuality(){return this._filteringQuality}set filteringQuality(e){this._filteringQuality!==e&&(this._filteringQuality=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get useContactHardeningShadow(){return this.filter===l.FILTER_PCSS}set useContactHardeningShadow(e){const i=this._validateFilter(l.FILTER_PCSS);!e&&this.filter!==l.FILTER_PCSS||(this.filter=e?i:l.FILTER_NONE)}get contactHardeningLightSizeUVRatio(){return this._contactHardeningLightSizeUVRatio}set contactHardeningLightSizeUVRatio(e){this._contactHardeningLightSizeUVRatio=e}get darkness(){return this._darkness}set darkness(e){this.setDarkness(e)}getDarkness(){return this._darkness}setDarkness(e){return this._darkness=e>=1?1:e<=0?0:e,this}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(e){this.setTransparencyShadow(e)}setTransparencyShadow(e){return this._transparencyShadow=e,this}getShadowMap(){return this._shadowMap}getShadowMapForRendering(){return this._shadowMap2?this._shadowMap2:this._shadowMap}getClassName(){return l.CLASSNAME}addShadowCaster(e,i=!0){if(!this._shadowMap)return this;if(this._shadowMap.renderList||(this._shadowMap.renderList=[]),-1===this._shadowMap.renderList.indexOf(e)&&this._shadowMap.renderList.push(e),i)for(const a of e.getChildMeshes())-1===this._shadowMap.renderList.indexOf(a)&&this._shadowMap.renderList.push(a);return this}removeShadowCaster(e,i=!0){if(!this._shadowMap||!this._shadowMap.renderList)return this;const a=this._shadowMap.renderList.indexOf(e);if(-1!==a&&this._shadowMap.renderList.splice(a,1),i)for(const s of e.getChildren())this.removeShadowCaster(s);return this}getLight(){return this._light}_getCamera(){var e;return null!==(e=this._camera)&&void 0!==e?e:this._scene.activeCamera}get mapSize(){return this._mapSize}set mapSize(e){this._mapSize=e,this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}constructor(e,i,a,s){this.onBeforeShadowMapRenderObservable=new r.O,this.onAfterShadowMapRenderObservable=new r.O,this.onBeforeShadowMapRenderMeshObservable=new r.O,this.onAfterShadowMapRenderMeshObservable=new r.O,this._bias=5e-5,this._normalBias=0,this._blurBoxOffset=1,this._blurScale=2,this._blurKernel=1,this._useKernelBlur=!1,this._filter=l.FILTER_NONE,this._filteringQuality=l.QUALITY_HIGH,this._contactHardeningLightSizeUVRatio=.1,this._darkness=0,this._transparencyShadow=!1,this.enableSoftTransparentShadow=!1,this.useOpacityTextureForTransparentShadow=!1,this.frustumEdgeFalloff=0,this.forceBackFacesOnly=!1,this._lightDirection=r.V.Zero(),this._viewMatrix=r.b.Zero(),this._projectionMatrix=r.b.Zero(),this._transformMatrix=r.b.Zero(),this._cachedPosition=new r.V(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cachedDirection=new r.V(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._currentFaceIndex=0,this._currentFaceIndexCache=0,this._defaultTextureMatrix=r.b.Identity(),this._mapSize=e,this._light=i,this._scene=i.getScene(),this._camera=s??null;let n=i._shadowGenerators;n||(n=i._shadowGenerators=new Map),n.set(this._camera,this),this.id=i.id,this._useUBO=this._scene.getEngine().supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))),l._SceneComponentInitialization(this._scene);const o=this._scene.getEngine().getCaps();this._textureType=a?o.textureFloatRender&&o.textureFloatLinearFiltering?1:o.textureHalfFloatRender&&o.textureHalfFloatLinearFiltering?2:0:o.textureHalfFloatRender&&o.textureHalfFloatLinearFiltering?2:o.textureFloatRender&&o.textureFloatLinearFiltering?1:0,this._initializeGenerator(),this._applyFilterValues()}_initializeGenerator(){this._light._markMeshesAsLightDirty(),this._initializeShadowMap()}_createTargetRenderTexture(){const e=this._scene.getEngine();e._features.supportDepthStencilTexture?(this._shadowMap=new de(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube(),void 0,!1,!1),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0)):this._shadowMap=new de(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube())}_initializeShadowMap(){if(this._createTargetRenderTexture(),null===this._shadowMap)return;this._shadowMap.wrapU=g.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=g.CLAMP_ADDRESSMODE,this._shadowMap.anisotropicFilteringLevel=1,this._shadowMap.updateSamplingMode(g.BILINEAR_SAMPLINGMODE),this._shadowMap.renderParticles=!1,this._shadowMap.ignoreCameraViewport=!0,this._storedUniqueId&&(this._shadowMap.uniqueId=this._storedUniqueId),this._shadowMap.customRenderFunction=this._renderForShadowMap.bind(this),this._shadowMap.customIsReadyFunction=()=>!0;const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.add(()=>{var s;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),null===(s=e._debugPushGroup)||void 0===s||s.call(e,`shadow map generation for pass id ${e.currentRenderPassId}`,1)}),this._shadowMap.onBeforeRenderObservable.add(s=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[0]),this._currentFaceIndex=s,this._filter===l.FILTER_PCF&&e.setColorWrite(!1),this.getTransformMatrix(),this._scene.setTransformMatrix(this._viewMatrix,this._projectionMatrix),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onAfterUnbindObservable.add(()=>{var s,n;if(this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._scene.updateTransformMatrix(),this._filter===l.FILTER_PCF&&e.setColorWrite(!0),!this.useBlurExponentialShadowMap&&!this.useBlurCloseExponentialShadowMap)return void(null===(s=e._debugPopGroup)||void 0===s||s.call(e,1));const o=this.getShadowMapForRendering();o&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,o.renderTarget,!0),e.unBindFramebuffer(o.renderTarget,!0),null===(n=e._debugPopGroup)||void 0===n||n.call(e,1))});const i=new r.C(0,0,0,0),a=new r.C(1,1,1,1);this._shadowMap.onClearObservable.add(s=>{this._filter===l.FILTER_PCF?s.clear(a,!1,!0,!1):s.clear(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?i:a,!0,!0,!1)}),this._shadowMap.onResizeObservable.add(s=>{this._storedUniqueId=this._shadowMap.uniqueId,this._mapSize=s.getRenderSize(),this._light._markMeshesAsLightDirty(),this.recreateShadowMap()});for(let s=r.K.MIN_RENDERINGGROUPS;s<r.K.MAX_RENDERINGGROUPS;s++)this._shadowMap.setRenderingAutoClearDepthStencil(s,!1)}_initializeBlurRTTAndPostProcesses(){const e=this._scene.getEngine(),i=this._mapSize/this.blurScale;(!this.useKernelBlur||1!==this.blurScale)&&(this._shadowMap2=new de(this._light.name+"_shadowMap2",i,this._scene,!1,!0,this._textureType,void 0,void 0,!1),this._shadowMap2.wrapU=g.CLAMP_ADDRESSMODE,this._shadowMap2.wrapV=g.CLAMP_ADDRESSMODE,this._shadowMap2.updateSamplingMode(g.BILINEAR_SAMPLINGMODE)),this.useKernelBlur?(this._kernelBlurXPostprocess=new se(this._light.name+"KernelBlurX",new r.d(1,0),this.blurKernel,1,null,g.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.width=i,this._kernelBlurXPostprocess.height=i,this._kernelBlurXPostprocess.externalTextureSamplerBinding=!0,this._kernelBlurXPostprocess.onApplyObservable.add(a=>{a.setTexture("textureSampler",this._shadowMap)}),this._kernelBlurYPostprocess=new se(this._light.name+"KernelBlurY",new r.d(0,1),this.blurKernel,1,null,g.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.autoClear=!1,this._kernelBlurYPostprocess.autoClear=!1,0===this._textureType&&(this._kernelBlurXPostprocess.packedFloat=!0,this._kernelBlurYPostprocess.packedFloat=!0),this._blurPostProcesses=[this._kernelBlurXPostprocess,this._kernelBlurYPostprocess]):(this._boxBlurPostprocess=new y(this._light.name+"DepthBoxBlur","depthBoxBlur",["screenSize","boxOffset"],[],1,null,g.BILINEAR_SAMPLINGMODE,e,!1,"#define OFFSET "+this._blurBoxOffset,this._textureType),this._boxBlurPostprocess.externalTextureSamplerBinding=!0,this._boxBlurPostprocess.onApplyObservable.add(a=>{a.setFloat2("screenSize",i,i),a.setTexture("textureSampler",this._shadowMap)}),this._boxBlurPostprocess.autoClear=!1,this._blurPostProcesses=[this._boxBlurPostprocess])}_renderForShadowMap(e,i,a,s){let n;if(s.length)for(n=0;n<s.length;n++)this._renderSubMeshForShadowMap(s.data[n]);for(n=0;n<e.length;n++)this._renderSubMeshForShadowMap(e.data[n]);for(n=0;n<i.length;n++)this._renderSubMeshForShadowMap(i.data[n]);if(this._transparencyShadow)for(n=0;n<a.length;n++)this._renderSubMeshForShadowMap(a.data[n],!0);else for(n=0;n<a.length;n++)a.data[n].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}_bindCustomEffectForRenderSubMeshForShadowMap(e,i,a){i.setMatrix("viewProjection",this.getTransformMatrix())}_renderSubMeshForShadowMap(e,i=!1){var a,s;const n=e.getRenderingMesh(),o=e.getEffectiveMesh(),c=this._scene,h=c.getEngine(),d=e.getMaterial();if(o._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!d||0===e.verticesCount||e._renderId===c.getRenderId())return;const u=o._getWorldMatrixDeterminant()<0;let f=null!==(a=n.overrideMaterialSideOrientation)&&void 0!==a?a:d.sideOrientation;u&&(f=0===f?1:0),h.setState(d.backFaceCulling,void 0,void 0,0===f,d.cullBackFaces);const m=n._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(m.mustReturn)return;const S=h.getCaps().instancedArrays&&(null!=m.visibleInstances[e._id]||n.hasThinInstances);if(!this.customAllowRendering||this.customAllowRendering(e))if(this.isReady(e,S,i)){e._renderId=c.getRenderId();const _=d.shadowDepthWrapper,T=null!==(s=_?.getEffect(e,this,h.currentRenderPassId))&&void 0!==s?s:e._getDrawWrapper(),E=r.B.GetEffect(T);h.enableEffect(T),S||n._bind(e,E,d.fillMode),this.getTransformMatrix(),E.setFloat3("biasAndScaleSM",this.bias,this.normalBias,this.depthScale),this.getLight().getTypeID()===A.LIGHTTYPEID_DIRECTIONALLIGHT?E.setVector3("lightDataSM",this._cachedDirection):E.setVector3("lightDataSM",this._cachedPosition);const x=this._getCamera();if(x&&E.setFloat2("depthValuesSM",this.getLight().getDepthMinZ(x),this.getLight().getDepthMinZ(x)+this.getLight().getDepthMaxZ(x)),i&&this.enableSoftTransparentShadow&&E.setFloat("softTransparentShadowSM",o.visibility*d.alpha),_)e._setMainDrawWrapperOverride(T),_.standalone?_.baseMaterial.bindForSubMesh(o.getWorldMatrix(),n,e):d.bindForSubMesh(o.getWorldMatrix(),n,e),e._setMainDrawWrapperOverride(null);else{if(this._opacityTexture&&(E.setTexture("diffuseSampler",this._opacityTexture),E.setMatrix("diffuseMatrix",this._opacityTexture.getTextureMatrix()||this._defaultTextureMatrix)),n.useBones&&n.computeBonesUsingShaders&&n.skeleton){const P=n.skeleton;if(P.isUsingTextureForMatrices){const C=P.getTransformMatrixTexture(n);if(!C)return;E.setTexture("boneSampler",C),E.setFloat("boneTextureWidth",4*(P.bones.length+1))}else E.setMatrices("mBones",P.getTransformMatrices(n))}r.a0.BindMorphTargetParameters(n,E),n.morphTargetManager&&n.morphTargetManager.isUsingTextureForTargets&&n.morphTargetManager._bind(E),(0,r.a1)(E,d,c)}!this._useUBO&&!_&&this._bindCustomEffectForRenderSubMeshForShadowMap(e,E,o),r.a0.BindSceneUniformBuffer(E,this._scene.getSceneUniformBuffer()),this._scene.getSceneUniformBuffer().bindUniformBuffer();const R=o.getWorldMatrix();S&&(o.getMeshUniformBuffer().bindToEffect(E,"Mesh"),o.transferToEffect(R)),this.forceBackFacesOnly&&h.setState(!0,0,!1,!0,d.cullBackFaces),this.onBeforeShadowMapRenderMeshObservable.notifyObservers(n),this.onBeforeShadowMapRenderObservable.notifyObservers(E),n._processRendering(o,e,E,d.fillMode,m,S,(P,C)=>{o===n||P?(o.getMeshUniformBuffer().bindToEffect(E,"Mesh"),o.transferToEffect(P?C:R)):(n.getMeshUniformBuffer().bindToEffect(E,"Mesh"),n.transferToEffect(C))}),this.forceBackFacesOnly&&h.setState(!0,0,!1,!1,d.cullBackFaces),this.onAfterShadowMapRenderObservable.notifyObservers(E),this.onAfterShadowMapRenderMeshObservable.notifyObservers(n)}else this._shadowMap&&this._shadowMap.resetRefreshCounter()}_applyFilterValues(){this._shadowMap&&this._shadowMap.updateSamplingMode(this.filter===l.FILTER_NONE||this.filter===l.FILTER_PCSS?g.NEAREST_SAMPLINGMODE:g.BILINEAR_SAMPLINGMODE)}forceCompilation(e,i){const a={useInstances:!1,...i},s=this.getShadowMap();if(!s)return void(e&&e(this));const n=s.renderList;if(!n)return void(e&&e(this));const o=new Array;for(const d of n)o.push(...d.subMeshes);if(0===o.length)return void(e&&e(this));let c=0;const h=()=>{var d,u;if(this._scene&&this._scene.getEngine()){for(;this.isReady(o[c],a.useInstances,null!==(u=null===(d=o[c].getMaterial())||void 0===d?void 0:d.needAlphaBlendingForMesh(o[c].getMesh()))&&void 0!==u&&u);)if(c++,c>=o.length)return void(e&&e(this));setTimeout(h,16)}};h()}forceCompilationAsync(e){return new Promise(i=>{this.forceCompilation(()=>{i()},e)})}_isReadyCustomDefines(e,i,a){}_prepareShadowDefines(e,i,a,s){a.push("#define SM_LIGHTTYPE_"+this._light.getClassName().toUpperCase()),a.push("#define SM_FLOAT "+(0!==this._textureType?"1":"0")),a.push("#define SM_ESM "+(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?"1":"0")),a.push("#define SM_DEPTHTEXTURE "+(this.usePercentageCloserFiltering||this.useContactHardeningShadow?"1":"0"));const n=e.getMesh();return a.push("#define SM_NORMALBIAS "+(this.normalBias&&n.isVerticesDataPresent(r.z.NormalKind)?"1":"0")),a.push("#define SM_DIRECTIONINLIGHTDATA "+(this.getLight().getTypeID()===A.LIGHTTYPEID_DIRECTIONALLIGHT?"1":"0")),a.push("#define SM_USEDISTANCE "+(this._light.needCube()?"1":"0")),a.push("#define SM_SOFTTRANSPARENTSHADOW "+(this.enableSoftTransparentShadow&&s?"1":"0")),this._isReadyCustomDefines(a,e,i),a}isReady(e,i,a){var s;const n=e.getMaterial(),o=n?.shadowDepthWrapper;if(this._opacityTexture=null,!n)return!1;const c=[];if(this._prepareShadowDefines(e,i,c,a),o){if(!o.isReadyForSubMesh(e,c,this,i,this._scene.getEngine().currentRenderPassId))return!1}else{const h=e._getDrawWrapper(void 0,!0);let d=h.effect,u=h.defines;const f=[r.z.PositionKind],p=e.getMesh();this.normalBias&&p.isVerticesDataPresent(r.z.NormalKind)&&(f.push(r.z.NormalKind),c.push("#define NORMAL"),p.nonUniformScaling&&c.push("#define NONUNIFORMSCALING"));const m=n.needAlphaTesting();if((m||n.needAlphaBlending())&&(this._opacityTexture=this.useOpacityTextureForTransparentShadow?n.opacityTexture:n.getAlphaTestTexture(),this._opacityTexture)){if(!this._opacityTexture.isReady())return!1;const x=null!==(s=n.alphaCutOff)&&void 0!==s?s:l.DEFAULT_ALPHA_CUTOFF;c.push("#define ALPHATEXTURE"),m&&c.push(`#define ALPHATESTVALUE ${x}${x%1==0?".":""}`),p.isVerticesDataPresent(r.z.UVKind)&&(f.push(r.z.UVKind),c.push("#define UV1")),p.isVerticesDataPresent(r.z.UV2Kind)&&1===this._opacityTexture.coordinatesIndex&&(f.push(r.z.UV2Kind),c.push("#define UV2"))}const S=new Be;if(p.useBones&&p.computeBonesUsingShaders&&p.skeleton){f.push(r.z.MatricesIndicesKind),f.push(r.z.MatricesWeightsKind),p.numBoneInfluencers>4&&(f.push(r.z.MatricesIndicesExtraKind),f.push(r.z.MatricesWeightsExtraKind));const x=p.skeleton;c.push("#define NUM_BONE_INFLUENCERS "+p.numBoneInfluencers),p.numBoneInfluencers>0&&S.addCPUSkinningFallback(0,p),c.push(x.isUsingTextureForMatrices?"#define BONETEXTURE":"#define BonesPerMesh "+(x.bones.length+1))}else c.push("#define NUM_BONE_INFLUENCERS 0");const _=p.morphTargetManager;let T=0;if(_&&_.numInfluencers>0&&(c.push("#define MORPHTARGETS"),T=_.numInfluencers,c.push("#define NUM_MORPH_INFLUENCERS "+T),_.isUsingTextureForTargets&&c.push("#define MORPHTARGETS_TEXTURE"),r.a0.PrepareAttributesForMorphTargetsInfluencers(f,p,T)),(0,r.a2)(n,this._scene,c),i&&(c.push("#define INSTANCES"),r.a0.PushAttributesForInstances(f),e.getRenderingMesh().hasThinInstances&&c.push("#define THIN_INSTANCES")),this.customShaderOptions&&this.customShaderOptions.defines)for(const x of this.customShaderOptions.defines)-1===c.indexOf(x)&&c.push(x);const E=c.join("\n");if(u!==E){u=E;let x="shadowMap";const R=["world","mBones","viewProjection","diffuseMatrix","lightDataSM","depthValuesSM","biasAndScaleSM","morphTargetInfluences","boneTextureWidth","softTransparentShadowSM","morphTargetTextureInfo","morphTargetTextureIndices"],P=["diffuseSampler","boneSampler","morphTargets"],C=["Scene","Mesh"];if((0,r.a3)(R),this.customShaderOptions){if(x=this.customShaderOptions.shaderName,this.customShaderOptions.attributes)for(const I of this.customShaderOptions.attributes)-1===f.indexOf(I)&&f.push(I);if(this.customShaderOptions.uniforms)for(const I of this.customShaderOptions.uniforms)-1===R.indexOf(I)&&R.push(I);if(this.customShaderOptions.samplers)for(const I of this.customShaderOptions.samplers)-1===P.indexOf(I)&&P.push(I)}const L=this._scene.getEngine();d=L.createEffect(x,{attributes:f,uniformsNames:R,uniformBuffersNames:C,samplers:P,defines:E,fallbacks:S,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:T}},L),h.setEffect(d,u)}if(!d.isReady())return!1}return(this.useBlurExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(!this._blurPostProcesses||!this._blurPostProcesses.length)&&this._initializeBlurRTTAndPostProcesses(),!(this._kernelBlurXPostprocess&&!this._kernelBlurXPostprocess.isReady()||this._kernelBlurYPostprocess&&!this._kernelBlurYPostprocess.isReady()||this._boxBlurPostprocess&&!this._boxBlurPostprocess.isReady())}prepareDefines(e,i){const s=this._light;!this._scene.shadowsEnabled||!s.shadowEnabled||(e["SHADOW"+i]=!0,this.useContactHardeningShadow?(e["SHADOWPCSS"+i]=!0,this._filteringQuality===l.QUALITY_LOW?e["SHADOWLOWQUALITY"+i]=!0:this._filteringQuality===l.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+i]=!0)):this.usePercentageCloserFiltering?(e["SHADOWPCF"+i]=!0,this._filteringQuality===l.QUALITY_LOW?e["SHADOWLOWQUALITY"+i]=!0:this._filteringQuality===l.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+i]=!0)):this.usePoissonSampling?e["SHADOWPOISSON"+i]=!0:this.useExponentialShadowMap||this.useBlurExponentialShadowMap?e["SHADOWESM"+i]=!0:(this.useCloseExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(e["SHADOWCLOSEESM"+i]=!0),s.needCube()&&(e["SHADOWCUBE"+i]=!0))}bindShadowLight(e,i){const a=this._light;if(!this._scene.shadowsEnabled||!a.shadowEnabled)return;const s=this._getCamera();if(!s)return;const n=this.getShadowMap();n&&(a.needCube()||i.setMatrix("lightMatrix"+e,this.getTransformMatrix()),this._filter===l.FILTER_PCF?(i.setDepthStencilTexture("shadowSampler"+e,this.getShadowMapForRendering()),a._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),n.getSize().width,1/n.getSize().width,this.frustumEdgeFalloff,e)):this._filter===l.FILTER_PCSS?(i.setDepthStencilTexture("shadowSampler"+e,this.getShadowMapForRendering()),i.setTexture("depthSampler"+e,this.getShadowMapForRendering()),a._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/n.getSize().width,this._contactHardeningLightSizeUVRatio*n.getSize().width,this.frustumEdgeFalloff,e)):(i.setTexture("shadowSampler"+e,this.getShadowMapForRendering()),a._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),this.blurScale/n.getSize().width,this.depthScale,this.frustumEdgeFalloff,e)),a._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(s),this.getLight().getDepthMinZ(s)+this.getLight().getDepthMaxZ(s),e))}getTransformMatrix(){const e=this._scene;if(this._currentRenderId===e.getRenderId()&&this._currentFaceIndexCache===this._currentFaceIndex)return this._transformMatrix;this._currentRenderId=e.getRenderId(),this._currentFaceIndexCache=this._currentFaceIndex;let i=this._light.position;if(this._light.computeTransformedInformation()&&(i=this._light.transformedPosition),r.V.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex),this._lightDirection),1===Math.abs(r.V.Dot(this._lightDirection,r.V.Up()))&&(this._lightDirection.z=1e-13),this._light.needProjectionMatrixCompute()||!this._cachedPosition||!this._cachedDirection||!i.equals(this._cachedPosition)||!this._lightDirection.equals(this._cachedDirection)){this._cachedPosition.copyFrom(i),this._cachedDirection.copyFrom(this._lightDirection),r.b.LookAtLHToRef(i,i.add(this._lightDirection),r.V.Up(),this._viewMatrix);const a=this.getShadowMap();if(a){const s=a.renderList;s&&this._light.setShadowProjectionMatrix(this._projectionMatrix,this._viewMatrix,s)}this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix}recreateShadowMap(){const e=this._shadowMap;if(!e)return;const i=e.renderList;if(this._disposeRTTandPostProcesses(),this._initializeGenerator(),this.filter=this._filter,this._applyFilterValues(),i){this._shadowMap.renderList||(this._shadowMap.renderList=[]);for(const a of i)this._shadowMap.renderList.push(a)}else this._shadowMap.renderList=null}_disposeBlurPostProcesses(){this._shadowMap2&&(this._shadowMap2.dispose(),this._shadowMap2=null),this._boxBlurPostprocess&&(this._boxBlurPostprocess.dispose(),this._boxBlurPostprocess=null),this._kernelBlurXPostprocess&&(this._kernelBlurXPostprocess.dispose(),this._kernelBlurXPostprocess=null),this._kernelBlurYPostprocess&&(this._kernelBlurYPostprocess.dispose(),this._kernelBlurYPostprocess=null),this._blurPostProcesses=[]}_disposeRTTandPostProcesses(){this._shadowMap&&(this._shadowMap.dispose(),this._shadowMap=null),this._disposeBlurPostProcesses()}_disposeSceneUBOs(){if(this._sceneUBOs){for(const e of this._sceneUBOs)e.dispose();this._sceneUBOs=[]}}dispose(){if(this._disposeRTTandPostProcesses(),this._disposeSceneUBOs(),this._light){if(this._light._shadowGenerators){const e=this._light._shadowGenerators.entries();for(let i=e.next();!0!==i.done;i=e.next()){const[a,s]=i.value;s===this&&this._light._shadowGenerators.delete(a)}0===this._light._shadowGenerators.size&&(this._light._shadowGenerators=null)}this._light._markMeshesAsLightDirty()}this.onBeforeShadowMapRenderMeshObservable.clear(),this.onBeforeShadowMapRenderObservable.clear(),this.onAfterShadowMapRenderMeshObservable.clear(),this.onAfterShadowMapRenderObservable.clear()}serialize(){var e;const i={},a=this.getShadowMap();if(!a)return i;if(i.className=this.getClassName(),i.lightId=this._light.id,i.cameraId=null===(e=this._camera)||void 0===e?void 0:e.id,i.id=this.id,i.mapSize=a.getRenderSize(),i.forceBackFacesOnly=this.forceBackFacesOnly,i.darkness=this.getDarkness(),i.transparencyShadow=this._transparencyShadow,i.frustumEdgeFalloff=this.frustumEdgeFalloff,i.bias=this.bias,i.normalBias=this.normalBias,i.usePercentageCloserFiltering=this.usePercentageCloserFiltering,i.useContactHardeningShadow=this.useContactHardeningShadow,i.contactHardeningLightSizeUVRatio=this.contactHardeningLightSizeUVRatio,i.filteringQuality=this.filteringQuality,i.useExponentialShadowMap=this.useExponentialShadowMap,i.useBlurExponentialShadowMap=this.useBlurExponentialShadowMap,i.useCloseExponentialShadowMap=this.useBlurExponentialShadowMap,i.useBlurCloseExponentialShadowMap=this.useBlurExponentialShadowMap,i.usePoissonSampling=this.usePoissonSampling,i.depthScale=this.depthScale,i.blurBoxOffset=this.blurBoxOffset,i.blurKernel=this.blurKernel,i.blurScale=this.blurScale,i.useKernelBlur=this.useKernelBlur,i.renderList=[],a.renderList)for(let s=0;s<a.renderList.length;s++)i.renderList.push(a.renderList[s].id);return i}static Parse(e,i,a){const s=i.getLightById(e.lightId),n=void 0!==e.cameraId?i.getCameraById(e.cameraId):null,o=a?a(e.mapSize,s,n):new l(e.mapSize,s,void 0,n),c=o.getShadowMap();for(let h=0;h<e.renderList.length;h++)i.getMeshesById(e.renderList[h]).forEach(function(d){c&&(c.renderList||(c.renderList=[]),c.renderList.push(d))});return void 0!==e.id&&(o.id=e.id),o.forceBackFacesOnly=!!e.forceBackFacesOnly,void 0!==e.darkness&&o.setDarkness(e.darkness),e.transparencyShadow&&o.setTransparencyShadow(!0),void 0!==e.frustumEdgeFalloff&&(o.frustumEdgeFalloff=e.frustumEdgeFalloff),void 0!==e.bias&&(o.bias=e.bias),void 0!==e.normalBias&&(o.normalBias=e.normalBias),e.usePercentageCloserFiltering?o.usePercentageCloserFiltering=!0:e.useContactHardeningShadow?o.useContactHardeningShadow=!0:e.usePoissonSampling?o.usePoissonSampling=!0:e.useExponentialShadowMap?o.useExponentialShadowMap=!0:e.useBlurExponentialShadowMap?o.useBlurExponentialShadowMap=!0:e.useCloseExponentialShadowMap?o.useCloseExponentialShadowMap=!0:e.useBlurCloseExponentialShadowMap?o.useBlurCloseExponentialShadowMap=!0:e.useVarianceShadowMap?o.useExponentialShadowMap=!0:e.useBlurVarianceShadowMap&&(o.useBlurExponentialShadowMap=!0),void 0!==e.contactHardeningLightSizeUVRatio&&(o.contactHardeningLightSizeUVRatio=e.contactHardeningLightSizeUVRatio),void 0!==e.filteringQuality&&(o.filteringQuality=e.filteringQuality),e.depthScale&&(o.depthScale=e.depthScale),e.blurScale&&(o.blurScale=e.blurScale),e.blurBoxOffset&&(o.blurBoxOffset=e.blurBoxOffset),e.useKernelBlur&&(o.useKernelBlur=e.useKernelBlur),e.blurKernel&&(o.blurKernel=e.blurKernel),o}}return l.CLASSNAME="ShadowGenerator",l.FILTER_NONE=0,l.FILTER_EXPONENTIALSHADOWMAP=1,l.FILTER_POISSONSAMPLING=2,l.FILTER_BLUREXPONENTIALSHADOWMAP=3,l.FILTER_CLOSEEXPONENTIALSHADOWMAP=4,l.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP=5,l.FILTER_PCF=6,l.FILTER_PCSS=7,l.QUALITY_HIGH=0,l.QUALITY_MEDIUM=1,l.QUALITY_LOW=2,l.DEFAULT_ALPHA_CUTOFF=.5,l._SceneComponentInitialization=t=>{throw(0,r.q)("ShadowGeneratorSceneComponent")},l})();r.x.ShadersStore.depthPixelShader="#ifdef ALPHATEST\nvarying vec2 vUV;\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\n#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}",r.x.IncludesShadersStore.instancesDeclaration="#ifdef INSTANCES\nattribute vec4 world0;\nattribute vec4 world1;\nattribute vec4 world2;\nattribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;\nattribute vec4 previousWorld1;\nattribute vec4 previousWorld2;\nattribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n",r.x.ShadersStore.depthVertexShader="attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\nuniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\nuniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;\nvarying vec4 vViewPos;\n#endif\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{\nvec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\n#endif\n#endif\n}\n";let ki=(()=>{class l{setMaterialForRendering(e,i){this._depthMap.setMaterialForRendering(e,i)}constructor(e,i=1,a=null,s=!1,n=g.TRILINEAR_SAMPLINGMODE,o=!1,c){this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._scene=e,this._storeNonLinearDepth=s,this._storeCameraSpaceZ=o,this.isPacked=0===i,this.clearColor=this.isPacked?new r.C(1,1,1,1):new r.C(o?1e8:1,0,0,1),l._SceneComponentInitialization(this._scene);const h=e.getEngine();this._camera=a,n!==g.NEAREST_SAMPLINGMODE&&(1===i&&!h._caps.textureFloatLinearFiltering&&(n=g.NEAREST_SAMPLINGMODE),2===i&&!h._caps.textureHalfFloatLinearFiltering&&(n=g.NEAREST_SAMPLINGMODE));const d=this.isPacked||!h._features.supportExtendedTextureFormats?5:6;this._depthMap=new de(c??"DepthRenderer",{width:h.getRenderWidth(),height:h.getRenderHeight()},this._scene,!1,!0,i,!1,n,void 0,void 0,void 0,d),this._depthMap.wrapU=g.CLAMP_ADDRESSMODE,this._depthMap.wrapV=g.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(f=>{f.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{var f;null===(f=h._debugPushGroup)||void 0===f||f.call(h,"depth renderer",1)}),this._depthMap.onAfterUnbindObservable.add(()=>{var f;null===(f=h._debugPopGroup)||void 0===f||f.call(h,1)}),this._depthMap.customIsReadyFunction=(f,p,m)=>{if((m||0===p)&&f.subMeshes)for(let S=0;S<f.subMeshes.length;++S){const _=f.subMeshes[S],T=_.getRenderingMesh(),E=T._getInstancesRenderList(_._id,!!_.getReplacementMesh()),x=h.getCaps().instancedArrays&&(null!=E.visibleInstances[_._id]||T.hasThinInstances);if(!this.isReady(_,x))return!1}return!0};const u=f=>{var p,m;const S=f.getRenderingMesh(),_=f.getEffectiveMesh(),T=this._scene,E=T.getEngine(),x=f.getMaterial();if(_._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!x||_.infiniteDistance||x.disableDepthWrite||0===f.verticesCount||f._renderId===T.getRenderId())return;const R=_._getWorldMatrixDeterminant()<0;let P=null!==(p=S.overrideMaterialSideOrientation)&&void 0!==p?p:x.sideOrientation;R&&(P=0===P?1:0),E.setState(x.backFaceCulling,0,!1,0===P,this.reverseCulling?!x.cullBackFaces:x.cullBackFaces);const L=S._getInstancesRenderList(f._id,!!f.getReplacementMesh());if(L.mustReturn)return;const I=E.getCaps().instancedArrays&&(null!=L.visibleInstances[f._id]||S.hasThinInstances),b=this._camera||T.activeCamera;if(this.isReady(f,I)&&b){f._renderId=T.getRenderId();const q=null===(m=_._internalAbstractMeshDataInfo._materialForRenderPass)||void 0===m?void 0:m[E.currentRenderPassId];let w=f._getDrawWrapper();!w&&q&&(w=q._getDrawWrapper());const he=b.mode===r.c.ORTHOGRAPHIC_CAMERA;if(!w)return;const F=w.effect;let Y,Z;if(E.enableEffect(w),I||S._bind(f,F,x.fillMode),q?q.bindForSubMesh(_.getWorldMatrix(),_,f):(F.setMatrix("viewProjection",T.getTransformMatrix()),F.setMatrix("world",_.getWorldMatrix()),this._storeCameraSpaceZ&&F.setMatrix("view",T.getViewMatrix())),he?(Y=!E.useReverseDepthBuffer&&E.isNDCHalfZRange?0:1,Z=E.useReverseDepthBuffer&&E.isNDCHalfZRange?0:1):(Y=E.useReverseDepthBuffer&&E.isNDCHalfZRange?b.minZ:E.isNDCHalfZRange?0:b.minZ,Z=E.useReverseDepthBuffer&&E.isNDCHalfZRange?0:b.maxZ),F.setFloat2("depthValues",Y,Y+Z),!q){if(x.needAlphaTesting()){const W=x.getAlphaTestTexture();W&&(F.setTexture("diffuseSampler",W),F.setMatrix("diffuseMatrix",W.getTextureMatrix()))}if(S.useBones&&S.computeBonesUsingShaders&&S.skeleton){const W=S.skeleton;if(W.isUsingTextureForMatrices){const ae=W.getTransformMatrixTexture(S);if(!ae)return;F.setTexture("boneSampler",ae),F.setFloat("boneTextureWidth",4*(W.bones.length+1))}else F.setMatrices("mBones",W.getTransformMatrices(S))}(0,r.a1)(F,x,T),r.a0.BindMorphTargetParameters(S,F),S.morphTargetManager&&S.morphTargetManager.isUsingTextureForTargets&&S.morphTargetManager._bind(F)}S._processRendering(_,f,F,x.fillMode,L,I,(W,ae)=>F.setMatrix("world",ae))}};this._depthMap.customRenderFunction=(f,p,m,S)=>{let _;if(S.length)for(_=0;_<S.length;_++)u(S.data[_]);for(_=0;_<f.length;_++)u(f.data[_]);for(_=0;_<p.length;_++)u(p.data[_]);if(this.forceDepthWriteTransparentMeshes)for(_=0;_<m.length;_++)u(m.data[_]);else for(_=0;_<m.length;_++)m.data[_].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}isReady(e,i){var a;const s=this._scene.getEngine(),n=e.getMesh(),o=n.getScene(),c=null===(a=n._internalAbstractMeshDataInfo._materialForRenderPass)||void 0===a?void 0:a[s.currentRenderPassId];if(c)return c.isReadyForSubMesh(n,e,i);const h=e.getMaterial();if(!h||h.disableDepthWrite)return!1;const d=[],u=[r.z.PositionKind];if(h&&h.needAlphaTesting()&&h.getAlphaTestTexture()&&(d.push("#define ALPHATEST"),n.isVerticesDataPresent(r.z.UVKind)&&(u.push(r.z.UVKind),d.push("#define UV1")),n.isVerticesDataPresent(r.z.UV2Kind)&&(u.push(r.z.UV2Kind),d.push("#define UV2"))),n.useBones&&n.computeBonesUsingShaders){u.push(r.z.MatricesIndicesKind),u.push(r.z.MatricesWeightsKind),n.numBoneInfluencers>4&&(u.push(r.z.MatricesIndicesExtraKind),u.push(r.z.MatricesWeightsExtraKind)),d.push("#define NUM_BONE_INFLUENCERS "+n.numBoneInfluencers),d.push("#define BonesPerMesh "+(n.skeleton?n.skeleton.bones.length+1:0));const T=e.getRenderingMesh().skeleton;null!=T&&T.isUsingTextureForMatrices&&d.push("#define BONETEXTURE")}else d.push("#define NUM_BONE_INFLUENCERS 0");const f=n.morphTargetManager;let p=0;f&&f.numInfluencers>0&&(p=f.numInfluencers,d.push("#define MORPHTARGETS"),d.push("#define NUM_MORPH_INFLUENCERS "+p),f.isUsingTextureForTargets&&d.push("#define MORPHTARGETS_TEXTURE"),r.a0.PrepareAttributesForMorphTargetsInfluencers(u,n,p)),i&&(d.push("#define INSTANCES"),r.a0.PushAttributesForInstances(u),e.getRenderingMesh().hasThinInstances&&d.push("#define THIN_INSTANCES")),this._storeNonLinearDepth&&d.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&d.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&d.push("#define PACKED"),(0,r.a2)(h,o,d);const m=e._getDrawWrapper(void 0,!0),S=m.defines,_=d.join("\n");if(S!==_){const T=["world","mBones","boneTextureWidth","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetTextureInfo","morphTargetTextureIndices"];(0,r.a3)(T),m.setEffect(s.createEffect("depth",u,T,["diffuseSampler","morphTargets","boneSampler"],_,void 0,void 0,void 0,{maxSimultaneousMorphTargets:p}),_)}return m.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const i in this._scene._depthRenderer)this._scene._depthRenderer[i]===this&&e.push(i);if(e.length>0){this._depthMap.dispose();for(const i of e)delete this._scene._depthRenderer[i]}}}return l._SceneComponentInitialization=t=>{throw(0,r.q)("DepthRendererSceneComponent")},l})();r.x.ShadersStore.minmaxReduxPixelShader="varying vec2 vUV;\nuniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform sampler2D sourceTexture;\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nfloat f1=texelFetch(sourceTexture,coord,0).r;\nfloat f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;\nfloat f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;\nfloat f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;\nfloat minz=min(min(min(f1,f2),f3),f4);\n#ifdef DEPTH_REDUX\nfloat maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#else\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(MAIN)\nuniform vec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*(texSize-1.0));\nvec2 f1=texelFetch(textureSampler,coord,0).rg;\nvec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;\nvec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;\nvec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;\nfloat minz=min(min(min(f1.x,f2.x),f3.x),f4.x);\nfloat maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;\nvoid main(void)\n{\nivec2 coord=ivec2(vUV*vec2(texSize-1));\nvec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;\nvec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;\nvec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;\nvec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;\nfloat minz=min(f1.x,f2.x);\nfloat maxz=max(f1.y,f2.y);\nglFragColor=vec4(minz,maxz,0.,0.);\n}\n#elif defined(LAST)\nvoid main(void)\n{\nglFragColor=vec4(0.);\nif (true) { \ndiscard;\n}\n}\n#endif\n";class Yi{constructor(t){this.onAfterReductionPerformed=new r.O,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=t,this._postProcessManager=new r.W(t.getScene()),this._onContextRestoredObserver=t.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(t,e,i=2,a=!0){if(t===this._sourceTexture)return;this.dispose(!1),this._sourceTexture=t,this._reductionSteps=[],this._forceFullscreenViewport=a;const s=this._camera.getScene(),n=new y("Initial reduction phase","minmaxRedux",["texSize"],["sourceTexture"],1,null,1,s.getEngine(),!1,"#define INITIAL"+(e?"\n#define DEPTH_REDUX":""),i,void 0,void 0,void 0,7);n.autoClear=!1,n.forceFullscreenViewport=a;let o=this._sourceTexture.getRenderWidth(),c=this._sourceTexture.getRenderHeight();n.onApply=((d,u)=>f=>{f.setTexture("sourceTexture",this._sourceTexture),f.setFloat2("texSize",d,u)})(o,c),this._reductionSteps.push(n);let h=1;for(;o>1||c>1;){o=Math.max(Math.round(o/2),1),c=Math.max(Math.round(c/2),1);const d=new y("Reduction phase "+h,"minmaxRedux",["texSize"],null,{width:o,height:c},null,1,s.getEngine(),!1,"#define "+(1==o&&1==c?"LAST":1==o||1==c?"ONEBEFORELAST":"MAIN"),i,void 0,void 0,void 0,7);d.autoClear=!1,d.forceFullscreenViewport=a,d.onApply=((u,f)=>p=>{1==u||1==f?p.setInt2("texSize",u,f):p.setFloat2("texSize",u,f)})(o,c),this._reductionSteps.push(d),h++,1==o&&1==c&&d.onAfterRenderObservable.add(((f,p,m)=>{const S=new Float32Array(4*f*p),_={min:0,max:0};return()=>{s.getEngine()._readTexturePixels(m.inputTexture.texture,f,p,-1,0,S,!1),_.min=S[0],_.max=S[1],this.onAfterReductionPerformed.notifyObservers(_)}})(o,c,d))}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(t){this._sourceTexture&&(this._sourceTexture.refreshRate=t)}get activated(){return this._activated}activate(){this._onAfterUnbindObserver||!this._sourceTexture||(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{var t,e;const i=this._camera.getScene().getEngine();null===(t=i._debugPushGroup)||void 0===t||t.call(i,"min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport),i.unBindFramebuffer(this._reductionSteps[0].inputTexture,!1),null===(e=i._debugPopGroup)||void 0===e||e.call(i,1)}),this._activated=!0)}deactivate(){!this._onAfterUnbindObserver||!this._sourceTexture||(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(t=!0){if(t&&(this.onAfterReductionPerformed.clear(),this._onContextRestoredObserver&&(this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)),this.deactivate(),this._reductionSteps){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps=null}this._postProcessManager&&t&&this._postProcessManager.dispose(),this._sourceTexture=null}}class Zi extends Yi{get depthRenderer(){return this._depthRenderer}constructor(t){super(t)}setDepthRenderer(t=null,e=2,i=!0){const a=this._camera.getScene();this._depthRenderer&&(delete a._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),null===t&&(a._depthRenderer||(a._depthRenderer={}),(t=this._depthRenderer=new ki(a,e,this._camera,!1,1)).enabled=!1,this._depthRendererId="minmax"+this._camera.id,a._depthRenderer[this._depthRendererId]=t),super.setSourceTexture(t.getDepthMap(),!0,e,i)}setSourceTexture(t,e,i=2,a=!0){super.setSourceTexture(t,e,i,a)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(t=!0){if(super.dispose(t),this._depthRenderer&&t){const e=this._depthRenderer.getDepthMap().getScene();e&&delete e._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null}}}const Qe=r.V.Up(),ji=r.V.Zero(),N=new r.V,ce=new r.V,Ee=new r.b;class U extends G{_validateFilter(t){return t===G.FILTER_NONE||t===G.FILTER_PCF||t===G.FILTER_PCSS?t:(console.error('Unsupported filter "'+t+'"!'),G.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(t){(t=Math.min(Math.max(t,U.MIN_CASCADES_COUNT),U.MAX_CASCADES_COUNT))!==this._numCascades&&(this._numCascades=t,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(t){this._freezeShadowCastersBoundingInfoObservable&&t&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),!this._freezeShadowCastersBoundingInfoObservable&&!t&&(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this))),this._freezeShadowCastersBoundingInfo=t,t&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE),this._shadowMap&&this._shadowMap.renderList){const t=this._shadowMap.renderList;for(let i=0;i<t.length;i++){const a=t[i];if(!a)continue;const n=a.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(n.minimumWorld),this._scbiMax.maximizeInPlace(n.maximumWorld)}const e=this._scene.meshes;for(let i=0;i<e.length;i++){const a=e[i];if(!(a&&a.isVisible&&a.isEnabled&&a.receiveShadows))continue;const n=a.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(n.minimumWorld),this._scbiMax.maximizeInPlace(n.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(t){this._shadowCastersBoundingInfo=t}setMinMaxDistance(t,e){this._minDistance===t&&this._maxDistance===e||(t>e&&(t=0,e=1),t<0&&(t=0),e>1&&(e=1),this._minDistance=t,this._maxDistance=e,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return U.CLASSNAME}getCascadeMinExtents(t){return t>=0&&t<this._numCascades?this._cascadeMinExtents[t]:null}getCascadeMaxExtents(t){return t>=0&&t<this._numCascades?this._cascadeMaxExtents[t]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(t){const e=this._getCamera();e?this._shadowMaxZ===t||t<e.minZ||t>e.maxZ||(this._shadowMaxZ=t,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0):this._shadowMaxZ=t}get debug(){return this._debug}set debug(t){this._debug=t,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(t){this._depthClamp=t}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(t){this._cascadeBlendPercentage=t,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(t){const e=Math.min(Math.max(t,0),1);this._lambda!=e&&(this._lambda=e,this._breaksAreDirty=!0)}getCascadeViewMatrix(t){return t>=0&&t<this._numCascades?this._viewMatrices[t]:null}getCascadeProjectionMatrix(t){return t>=0&&t<this._numCascades?this._projectionMatrices[t]:null}getCascadeTransformMatrix(t){return t>=0&&t<this._numCascades?this._transformMatrices[t]:null}setDepthRenderer(t){this._depthRenderer=t,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(t){const e=this._getCamera();if(e){if(this._autoCalcDepthBounds=t,!t)return this._depthReducer&&this._depthReducer.deactivate(),void this.setMinMaxDistance(0,1);this._depthReducer||(this._depthReducer=new Zi(e),this._depthReducer.onAfterReductionPerformed.add(i=>{let a=i.min,s=i.max;a>=s&&(a=0,s=1),(a!=this._minDistance||s!=this._maxDistance)&&this.setMinMaxDistance(a,s)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){var t,e,i;return null!==(i=null===(e=null===(t=this._depthReducer)||void 0===t?void 0:t.depthRenderer)||void 0===e?void 0:e.getDepthMap().refreshRate)&&void 0!==i?i:-1}set autoCalcDepthBoundsRefreshRate(t){var e;null!==(e=this._depthReducer)&&void 0!==e&&e.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=t)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const t=this._getCamera();if(!t)return;const e=t.minZ,i=t.maxZ,a=i-e,s=this._minDistance,o=e+s*a,c=e+(this._shadowMaxZ<i&&this._shadowMaxZ>=e?Math.min((this._shadowMaxZ-e)/(i-e),this._maxDistance):this._maxDistance)*a,h=c-o,d=c/o;for(let u=0;u<this._cascades.length;++u){const f=(u+1)/this._numCascades,m=o+h*f,S=this._lambda*(o*d**f-m)+m;this._cascades[u].prevBreakDistance=0===u?s:this._cascades[u-1].breakDistance,this._cascades[u].breakDistance=(S-e)/a,this._viewSpaceFrustumsZ[u]=S,this._frustumLengths[u]=(this._cascades[u].breakDistance-this._cascades[u].prevBreakDistance)*a}this._breaksAreDirty=!1}_computeMatrices(){const t=this._scene;if(!this._getCamera())return;r.V.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),1===Math.abs(r.V.Dot(this._lightDirection,r.V.Up()))&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const e=t.getEngine().useReverseDepthBuffer;for(let i=0;i<this._numCascades;++i){this._computeFrustumInWorldSpace(i),this._computeCascadeFrustum(i),this._cascadeMaxExtents[i].subtractToRef(this._cascadeMinExtents[i],N),this._frustumCenter[i].addToRef(this._lightDirection.scale(this._cascadeMinExtents[i].z),this._shadowCameraPos[i]),r.b.LookAtLHToRef(this._shadowCameraPos[i],this._frustumCenter[i],Qe,this._viewMatrices[i]);let a=0,s=N.z;const n=this._shadowCastersBoundingInfo;n.update(this._viewMatrices[i]),s=Math.min(s,n.boundingBox.maximumWorld.z),a=this._depthClamp&&this.filter!==G.FILTER_PCSS?Math.max(a,n.boundingBox.minimumWorld.z):Math.min(a,n.boundingBox.minimumWorld.z),r.b.OrthoOffCenterLHToRef(this._cascadeMinExtents[i].x,this._cascadeMaxExtents[i].x,this._cascadeMinExtents[i].y,this._cascadeMaxExtents[i].y,e?s:a,e?a:s,this._projectionMatrices[i],t.getEngine().isNDCHalfZRange),this._cascadeMinExtents[i].z=a,this._cascadeMaxExtents[i].z=s,this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i],this._transformMatrices[i]),r.V.TransformCoordinatesToRef(ji,this._transformMatrices[i],N),N.scaleInPlace(this._mapSize/2),ce.copyFromFloats(Math.round(N.x),Math.round(N.y),Math.round(N.z)),ce.subtractInPlace(N).scaleInPlace(2/this._mapSize),r.b.TranslationToRef(ce.x,ce.y,0,Ee),this._projectionMatrices[i].multiplyToRef(Ee,this._projectionMatrices[i]),this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i],this._transformMatrices[i]),this._transformMatrices[i].copyToArray(this._transformMatricesAsArray,16*i)}}_computeFrustumInWorldSpace(t){const e=this._getCamera();if(!e)return;const i=this._cascades[t].prevBreakDistance,a=this._cascades[t].breakDistance,s=this._scene.getEngine().isNDCHalfZRange;e.getViewMatrix();const n=r.b.Invert(e.getTransformationMatrix()),o=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let c=0;c<U._FrustumCornersNDCSpace.length;++c)N.copyFrom(U._FrustumCornersNDCSpace[(c+o)%U._FrustumCornersNDCSpace.length]),s&&-1===N.z&&(N.z=0),r.V.TransformCoordinatesToRef(N,n,this._frustumCornersWorldSpace[t][c]);for(let c=0;c<U._FrustumCornersNDCSpace.length/2;++c)N.copyFrom(this._frustumCornersWorldSpace[t][c+4]).subtractInPlace(this._frustumCornersWorldSpace[t][c]),ce.copyFrom(N).scaleInPlace(i),N.scaleInPlace(a),N.addInPlace(this._frustumCornersWorldSpace[t][c]),this._frustumCornersWorldSpace[t][c+4].copyFrom(N),this._frustumCornersWorldSpace[t][c].addInPlace(ce)}_computeCascadeFrustum(t){if(this._cascadeMinExtents[t].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[t].copyFromFloats(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE),this._frustumCenter[t].copyFromFloats(0,0,0),this._getCamera()){for(let e=0;e<this._frustumCornersWorldSpace[t].length;++e)this._frustumCenter[t].addInPlace(this._frustumCornersWorldSpace[t][e]);if(this._frustumCenter[t].scaleInPlace(1/this._frustumCornersWorldSpace[t].length),this.stabilizeCascades){let e=0;for(let i=0;i<this._frustumCornersWorldSpace[t].length;++i){const a=this._frustumCornersWorldSpace[t][i].subtractToRef(this._frustumCenter[t],N).length();e=Math.max(e,a)}e=Math.ceil(16*e)/16,this._cascadeMaxExtents[t].copyFromFloats(e,e,e),this._cascadeMinExtents[t].copyFromFloats(-e,-e,-e)}else{const e=this._frustumCenter[t];this._frustumCenter[t].addToRef(this._lightDirection,N),r.b.LookAtLHToRef(e,N,Qe,Ee);for(let i=0;i<this._frustumCornersWorldSpace[t].length;++i)r.V.TransformCoordinatesToRef(this._frustumCornersWorldSpace[t][i],Ee,N),this._cascadeMinExtents[t].minimizeInPlace(N),this._cascadeMaxExtents[t].maximizeInPlace(N)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let t=0;t<this._numCascades;++t)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${t})`))}static get IsSupported(){const t=r.a.LastCreatedEngine;return!!t&&t._features.supportCSM}constructor(t,e,i,a){U.IsSupported?(super(t,e,i,a),this.usePercentageCloserFiltering=!0):r.w.Error("CascadedShadowMap is not supported by the current engine.")}_initializeGenerator(){var t,e,i,a,s,n,o,c,h,d,u,f,p,m,S,_,T,E,x,R;this.penumbraDarkness=null!==(t=this.penumbraDarkness)&&void 0!==t?t:1,this._numCascades=null!==(e=this._numCascades)&&void 0!==e?e:U.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=null!==(i=this.stabilizeCascades)&&void 0!==i&&i,this._freezeShadowCastersBoundingInfoObservable=null!==(a=this._freezeShadowCastersBoundingInfoObservable)&&void 0!==a?a:null,this.freezeShadowCastersBoundingInfo=null!==(s=this.freezeShadowCastersBoundingInfo)&&void 0!==s&&s,this._scbiMin=null!==(n=this._scbiMin)&&void 0!==n?n:new r.V(0,0,0),this._scbiMax=null!==(o=this._scbiMax)&&void 0!==o?o:new r.V(0,0,0),this._shadowCastersBoundingInfo=null!==(c=this._shadowCastersBoundingInfo)&&void 0!==c?c:new r.a4(new r.V(0,0,0),new r.V(0,0,0)),this._breaksAreDirty=null===(h=this._breaksAreDirty)||void 0===h||h,this._minDistance=null!==(d=this._minDistance)&&void 0!==d?d:0,this._maxDistance=null!==(u=this._maxDistance)&&void 0!==u?u:1,this._currentLayer=null!==(f=this._currentLayer)&&void 0!==f?f:0,this._shadowMaxZ=null!==(S=null!==(p=this._shadowMaxZ)&&void 0!==p?p:null===(m=this._getCamera())||void 0===m?void 0:m.maxZ)&&void 0!==S?S:1e4,this._debug=null!==(_=this._debug)&&void 0!==_&&_,this._depthClamp=null===(T=this._depthClamp)||void 0===T||T,this._cascadeBlendPercentage=null!==(E=this._cascadeBlendPercentage)&&void 0!==E?E:.1,this._lambda=null!==(x=this._lambda)&&void 0!==x?x:.5,this._autoCalcDepthBounds=null!==(R=this._autoCalcDepthBounds)&&void 0!==R&&R,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const t=this._scene.getEngine();this._shadowMap=new de(this._light.name+"_CSMShadowMap",{width:this._mapSize,height:this._mapSize,layers:this.numCascades},this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0),this._shadowMap.createDepthStencilTexture(t.useReverseDepthBuffer?516:513,!0)}_initializeShadowMap(){if(super._initializeShadowMap(),null===this._shadowMap)return;this._transformMatricesAsArray=new Float32Array(16*this._numCascades),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(2*this._numCascades),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let e=0;e<this._numCascades;++e){this._cascades[e]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[e]=r.b.Zero(),this._projectionMatrices[e]=r.b.Zero(),this._transformMatrices[e]=r.b.Zero(),this._cascadeMinExtents[e]=new r.V,this._cascadeMaxExtents[e]=new r.V,this._frustumCenter[e]=new r.V,this._shadowCameraPos[e]=new r.V,this._frustumCornersWorldSpace[e]=new Array(U._FrustumCornersNDCSpace.length);for(let i=0;i<U._FrustumCornersNDCSpace.length;++i)this._frustumCornersWorldSpace[e][i]=new r.V}const t=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(e=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[e]),this._currentLayer=e,this._filter===G.FILTER_PCF&&t.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(e),this.getCascadeProjectionMatrix(e)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{var e;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),null===(e=t._debugPushGroup)||void 0===e||e.call(t,`cascaded shadow map generation for pass id ${t.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(t,e){e.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(t){t.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==G.FILTER_PCSS?"1":"0"))}prepareDefines(t,e){super.prepareDefines(t,e);const i=this._scene;if(!i.shadowsEnabled||!this._light.shadowEnabled)return;t["SHADOWCSM"+e]=!0,t["SHADOWCSMDEBUG"+e]=this.debug,t["SHADOWCSMNUM_CASCADES"+e]=this.numCascades,t["SHADOWCSM_RIGHTHANDED"+e]=i.useRightHandedSystem;const s=this._getCamera();s&&this._shadowMaxZ<s.maxZ&&(t["SHADOWCSMUSESHADOWMAXZ"+e]=!0),0===this.cascadeBlendPercentage&&(t["SHADOWCSMNOBLEND"+e]=!0)}bindShadowLight(t,e){const i=this._light;if(!this._scene.shadowsEnabled||!i.shadowEnabled)return;const a=this._getCamera();if(!a)return;const s=this.getShadowMap();if(!s)return;const n=s.getSize().width;if(e.setMatrices("lightMatrix"+t,this._transformMatricesAsArray),e.setArray("viewFrustumZ"+t,this._viewSpaceFrustumsZ),e.setFloat("cascadeBlendFactor"+t,0===this.cascadeBlendPercentage?1e4:1/this.cascadeBlendPercentage),e.setArray("frustumLengths"+t,this._frustumLengths),this._filter===G.FILTER_PCF)e.setDepthStencilTexture("shadowSampler"+t,s),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),n,1/n,this.frustumEdgeFalloff,t);else if(this._filter===G.FILTER_PCSS){for(let o=0;o<this._numCascades;++o)this._lightSizeUVCorrection[2*o+0]=0===o?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[o].x-this._cascadeMinExtents[o].x),this._lightSizeUVCorrection[2*o+1]=0===o?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[o].y-this._cascadeMinExtents[o].y),this._depthCorrection[o]=0===o?1:(this._cascadeMaxExtents[o].z-this._cascadeMinExtents[o].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);e.setDepthStencilTexture("shadowSampler"+t,s),e.setTexture("depthSampler"+t,s),e.setArray2("lightSizeUVCorrection"+t,this._lightSizeUVCorrection),e.setArray("depthCorrection"+t,this._depthCorrection),e.setFloat("penumbraDarkness"+t,this.penumbraDarkness),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/n,this._contactHardeningLightSizeUVRatio*n,this.frustumEdgeFalloff,t)}else e.setTexture("shadowSampler"+t,s),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),n,1/n,this.frustumEdgeFalloff,t);i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(a),this.getLight().getDepthMinZ(a)+this.getLight().getDepthMaxZ(a),t)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const t=super.serialize(),e=this.getShadowMap();if(!e)return t;if(t.numCascades=this._numCascades,t.debug=this._debug,t.stabilizeCascades=this.stabilizeCascades,t.lambda=this._lambda,t.cascadeBlendPercentage=this.cascadeBlendPercentage,t.depthClamp=this._depthClamp,t.autoCalcDepthBounds=this.autoCalcDepthBounds,t.shadowMaxZ=this._shadowMaxZ,t.penumbraDarkness=this.penumbraDarkness,t.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,t.minDistance=this.minDistance,t.maxDistance=this.maxDistance,t.renderList=[],e.renderList)for(let i=0;i<e.renderList.length;i++)t.renderList.push(e.renderList[i].id);return t}static Parse(t,e){const i=G.Parse(t,e,(a,s,n)=>new U(a,s,void 0,n));return void 0!==t.numCascades&&(i.numCascades=t.numCascades),void 0!==t.debug&&(i.debug=t.debug),void 0!==t.stabilizeCascades&&(i.stabilizeCascades=t.stabilizeCascades),void 0!==t.lambda&&(i.lambda=t.lambda),void 0!==t.cascadeBlendPercentage&&(i.cascadeBlendPercentage=t.cascadeBlendPercentage),void 0!==t.depthClamp&&(i.depthClamp=t.depthClamp),void 0!==t.autoCalcDepthBounds&&(i.autoCalcDepthBounds=t.autoCalcDepthBounds),void 0!==t.shadowMaxZ&&(i.shadowMaxZ=t.shadowMaxZ),void 0!==t.penumbraDarkness&&(i.penumbraDarkness=t.penumbraDarkness),void 0!==t.freezeShadowCastersBoundingInfo&&(i.freezeShadowCastersBoundingInfo=t.freezeShadowCastersBoundingInfo),void 0!==t.minDistance&&void 0!==t.maxDistance&&i.setMinMaxDistance(t.minDistance,t.maxDistance),i}}U._FrustumCornersNDCSpace=[new r.V(-1,1,-1),new r.V(1,1,-1),new r.V(1,-1,-1),new r.V(-1,-1,-1),new r.V(-1,1,1),new r.V(1,1,1),new r.V(1,-1,1),new r.V(-1,-1,1)],U.CLASSNAME="CascadedShadowGenerator",U.DEFAULT_CASCADES_COUNT=4,U.MIN_CASCADES_COUNT=2,U.MAX_CASCADES_COUNT=4,U._SceneComponentInitialization=l=>{throw(0,r.q)("ShadowGeneratorSceneComponent")},r.a5.AddParser(r.a6.NAME_SHADOWGENERATOR,(l,t)=>{if(null!=l.shadowGenerators)for(let e=0,i=l.shadowGenerators.length;e<i;e++){const a=l.shadowGenerators[e];a.className===U.CLASSNAME?U.Parse(a,t):G.Parse(a,t)}});class Qi{constructor(t){this.name=r.a6.NAME_SHADOWGENERATOR,this.scene=t}register(){this.scene._gatherRenderTargetsStage.registerStep(r.a6.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(t){t.shadowGenerators=[];const e=this.scene.lights;for(const i of e){const a=i.getShadowGenerators();if(a){const s=a.values();for(let n=s.next();!0!==n.done;n=s.next())t.shadowGenerators.push(n.value.serialize())}}}addFromContainer(t){}removeFromContainer(t,e){}dispose(){}_gatherRenderTargets(t){const e=this.scene;if(this.scene.shadowsEnabled)for(let i=0;i<e.lights.length;i++){const a=e.lights[i],s=a.getShadowGenerators();if(a.isEnabled()&&a.shadowEnabled&&s){const n=s.values();for(let o=n.next();!0!==o.done;o=n.next()){const c=o.value.getShadowMap();-1!==e.textures.indexOf(c)&&t.push(c)}}}}}G._SceneComponentInitialization=l=>{let t=l._getComponent(r.a6.NAME_SHADOWGENERATOR);t||(t=new Qi(l),l._addComponent(t))};const Ki={enableShadows:!0};function Ke(l=Ki){const{enableShadows:t,shadowTransparency:e,intensity:i,scene:a}=l,s=new $("DirectionalLight",new r.V(-.3,-1,.4),a);s.position=new r.V(-50,65,-50),s.intensity=.65*i;const n=new Se("HemisphericLight",new r.V(1,1,0),a);return n.intensity=.4*i,t&&(s.shadowMinZ=1,s.shadowMaxZ=70,s.shadowGenerator=new G(2048,s),s.shadowGenerator.useCloseExponentialShadowMap=!0,s.shadowGenerator.darkness=e),{directional:s,hemispheric:n}}function qe(l){let t=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];const e=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],i=[];let a=[];const s=l.width||l.size||1,n=l.height||l.size||1,o=l.depth||l.size||1;let h=void 0===l.topBaseAt?1:l.topBaseAt,d=void 0===l.bottomBaseAt?0:l.bottomBaseAt;h=(h+4)%4,d=(d+4)%4;let p=[2,0,3,1][h],m=[2,0,1,3][d],S=[1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1];if(l.wrap){t=[2,3,0,2,0,1,4,5,6,4,6,7,9,10,11,9,11,8,12,14,15,12,13,14],S=[-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1];let C=[[1,1,1],[-1,1,1],[-1,1,-1],[1,1,-1]],L=[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]];const I=[17,18,19,16],b=[22,23,20,21];for(;p>0;)C.unshift(C.pop()),I.unshift(I.pop()),p--;for(;m>0;)L.unshift(L.pop()),b.unshift(b.pop()),m--;C=C.flat(),L=L.flat(),S=S.concat(C).concat(L),t.push(I[0],I[2],I[3],I[0],I[1],I[2]),t.push(b[0],b[2],b[3],b[0],b[1],b[2])}const _=[s/2,n/2,o/2];a=S.reduce((C,L,I)=>C.concat(L*_[I%3]),[]);const T=0===l.sideOrientation?0:l.sideOrientation||r.a7.DEFAULTSIDE,E=l.faceUV||new Array(6),x=l.faceColors,R=[];for(let C=0;C<6;C++)void 0===E[C]&&(E[C]=new r.a8(0,0,1,1)),x&&void 0===x[C]&&(x[C]=new r.C(1,1,1,1));for(let C=0;C<6;C++)if(i.push(E[C].z,r.n.UseOpenGLOrientationForUV?1-E[C].w:E[C].w),i.push(E[C].x,r.n.UseOpenGLOrientationForUV?1-E[C].w:E[C].w),i.push(E[C].x,r.n.UseOpenGLOrientationForUV?1-E[C].y:E[C].y),i.push(E[C].z,r.n.UseOpenGLOrientationForUV?1-E[C].y:E[C].y),x)for(let L=0;L<4;L++)R.push(x[C].r,x[C].g,x[C].b,x[C].a);r.a7._ComputeSides(T,a,t,e,i,l.frontUVs,l.backUVs);const P=new r.a7;if(P.indices=t,P.positions=a,P.normals=e,P.uvs=i,x){const C=T===r.a7.DOUBLESIDE?R.concat(R):R;P.colors=C}return P}function ue(l,t={},e=null){const i=new r.M(l,e);return t.sideOrientation=r.M._GetDefaultSideOrientation(t.sideOrientation),i._originalBuilderSideOrientation=t.sideOrientation,qe(t).applyToMesh(i,t.updatable),i}r.a7.CreateBox=qe,r.M.CreateBox=(l,t,e=null,i,a)=>ue(l,{size:t,sideOrientation:a,updatable:i},e);class $e{constructor(){this.previousWorldMatrices={},this.previousBones={}}static AddUniforms(t){t.push("previousWorld","previousViewProjection","mPreviousBones")}static AddSamplers(t){}bindForSubMesh(t,e,i,a,s){if(e.prePassRenderer&&e.prePassRenderer.enabled&&e.prePassRenderer.currentRTisSceneRT&&-1!==e.prePassRenderer.getIndex(2)){this.previousWorldMatrices[i.uniqueId]||(this.previousWorldMatrices[i.uniqueId]=a.clone()),this.previousViewProjection||(this.previousViewProjection=e.getTransformMatrix().clone(),this.currentViewProjection=e.getTransformMatrix().clone());const n=e.getEngine();this.currentViewProjection.updateFlag!==e.getTransformMatrix().updateFlag?(this._lastUpdateFrameId=n.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection),this.currentViewProjection.copyFrom(e.getTransformMatrix())):this._lastUpdateFrameId!==n.frameId&&(this._lastUpdateFrameId=n.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection)),t.setMatrix("previousWorld",this.previousWorldMatrices[i.uniqueId]),t.setMatrix("previousViewProjection",this.previousViewProjection),this.previousWorldMatrices[i.uniqueId]=a.clone()}}}class Je extends r.a9{constructor(t,e,i=!0){super(t,e),this._normalMatrix=new r.b,this._storeEffectOnSubMeshes=i}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(t,e){return!!t&&(!this._storeEffectOnSubMeshes||!t.subMeshes||0===t.subMeshes.length||this.isReadyForSubMesh(t,t.subMeshes[0],e))}_isReadyForSubMesh(t){const e=t.materialDefines;return!(this.checkReadyOnEveryCall||!t.effect||!e||e._renderId!==this.getScene().getRenderId())}bindOnlyWorldMatrix(t){this._activeEffect.setMatrix("world",t)}bindOnlyNormalMatrix(t){this._activeEffect.setMatrix("normalMatrix",t)}bind(t,e){e&&this.bindForSubMesh(t,e,e.subMeshes[0])}_afterBind(t,e=null){super._afterBind(t,e),this.getScene()._cachedEffect=e,e&&(e._forceRebindOnNextCall=!1)}_mustRebind(t,e,i=1){return t.isCachedMaterialInvalid(this,e,i)}dispose(t,e,i){this._activeEffect=void 0,super.dispose(t,e,i)}}let D=(()=>{class l{static get DiffuseTextureEnabled(){return this._DiffuseTextureEnabled}static set DiffuseTextureEnabled(e){this._DiffuseTextureEnabled!==e&&(this._DiffuseTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get DetailTextureEnabled(){return this._DetailTextureEnabled}static set DetailTextureEnabled(e){this._DetailTextureEnabled!==e&&(this._DetailTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get DecalMapEnabled(){return this._DecalMapEnabled}static set DecalMapEnabled(e){this._DecalMapEnabled!==e&&(this._DecalMapEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get AmbientTextureEnabled(){return this._AmbientTextureEnabled}static set AmbientTextureEnabled(e){this._AmbientTextureEnabled!==e&&(this._AmbientTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get OpacityTextureEnabled(){return this._OpacityTextureEnabled}static set OpacityTextureEnabled(e){this._OpacityTextureEnabled!==e&&(this._OpacityTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get ReflectionTextureEnabled(){return this._ReflectionTextureEnabled}static set ReflectionTextureEnabled(e){this._ReflectionTextureEnabled!==e&&(this._ReflectionTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get EmissiveTextureEnabled(){return this._EmissiveTextureEnabled}static set EmissiveTextureEnabled(e){this._EmissiveTextureEnabled!==e&&(this._EmissiveTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get SpecularTextureEnabled(){return this._SpecularTextureEnabled}static set SpecularTextureEnabled(e){this._SpecularTextureEnabled!==e&&(this._SpecularTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get BumpTextureEnabled(){return this._BumpTextureEnabled}static set BumpTextureEnabled(e){this._BumpTextureEnabled!==e&&(this._BumpTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get LightmapTextureEnabled(){return this._LightmapTextureEnabled}static set LightmapTextureEnabled(e){this._LightmapTextureEnabled!==e&&(this._LightmapTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get RefractionTextureEnabled(){return this._RefractionTextureEnabled}static set RefractionTextureEnabled(e){this._RefractionTextureEnabled!==e&&(this._RefractionTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get ColorGradingTextureEnabled(){return this._ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(e){this._ColorGradingTextureEnabled!==e&&(this._ColorGradingTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get FresnelEnabled(){return this._FresnelEnabled}static set FresnelEnabled(e){this._FresnelEnabled!==e&&(this._FresnelEnabled=e,r.E.MarkAllMaterialsAsDirty(4))}static get ClearCoatTextureEnabled(){return this._ClearCoatTextureEnabled}static set ClearCoatTextureEnabled(e){this._ClearCoatTextureEnabled!==e&&(this._ClearCoatTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get ClearCoatBumpTextureEnabled(){return this._ClearCoatBumpTextureEnabled}static set ClearCoatBumpTextureEnabled(e){this._ClearCoatBumpTextureEnabled!==e&&(this._ClearCoatBumpTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get ClearCoatTintTextureEnabled(){return this._ClearCoatTintTextureEnabled}static set ClearCoatTintTextureEnabled(e){this._ClearCoatTintTextureEnabled!==e&&(this._ClearCoatTintTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get SheenTextureEnabled(){return this._SheenTextureEnabled}static set SheenTextureEnabled(e){this._SheenTextureEnabled!==e&&(this._SheenTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get AnisotropicTextureEnabled(){return this._AnisotropicTextureEnabled}static set AnisotropicTextureEnabled(e){this._AnisotropicTextureEnabled!==e&&(this._AnisotropicTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get ThicknessTextureEnabled(){return this._ThicknessTextureEnabled}static set ThicknessTextureEnabled(e){this._ThicknessTextureEnabled!==e&&(this._ThicknessTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get RefractionIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set RefractionIntensityTextureEnabled(e){this._RefractionIntensityTextureEnabled!==e&&(this._RefractionIntensityTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get TranslucencyIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set TranslucencyIntensityTextureEnabled(e){this._TranslucencyIntensityTextureEnabled!==e&&(this._TranslucencyIntensityTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}static get IridescenceTextureEnabled(){return this._IridescenceTextureEnabled}static set IridescenceTextureEnabled(e){this._IridescenceTextureEnabled!==e&&(this._IridescenceTextureEnabled=e,r.E.MarkAllMaterialsAsDirty(1))}}return l._DiffuseTextureEnabled=!0,l._DetailTextureEnabled=!0,l._DecalMapEnabled=!0,l._AmbientTextureEnabled=!0,l._OpacityTextureEnabled=!0,l._ReflectionTextureEnabled=!0,l._EmissiveTextureEnabled=!0,l._SpecularTextureEnabled=!0,l._BumpTextureEnabled=!0,l._LightmapTextureEnabled=!0,l._RefractionTextureEnabled=!0,l._ColorGradingTextureEnabled=!0,l._FresnelEnabled=!0,l._ClearCoatTextureEnabled=!0,l._ClearCoatBumpTextureEnabled=!0,l._ClearCoatTintTextureEnabled=!0,l._SheenTextureEnabled=!0,l._AnisotropicTextureEnabled=!0,l._ThicknessTextureEnabled=!0,l._RefractionIntensityTextureEnabled=!0,l._TranslucencyIntensityTextureEnabled=!0,l._IridescenceTextureEnabled=!0,l})();r.x.IncludesShadersStore.decalFragmentDeclaration="#ifdef DECAL\nuniform vec4 vDecalInfos;\n#endif\n",r.x.IncludesShadersStore.defaultFragmentDeclaration="uniform vec4 vEyePosition;\nuniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;\nuniform vec3 vAmbientColor;\nuniform float visibility;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;\nuniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;\nuniform vec3 vRefractionSize; \n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;\nuniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;\nuniform vec4 emissiveRightColor;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;\nuniform vec3 vReflectionSize; \n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;\nuniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#define ADDITIONAL_FRAGMENT_DECLARATION\n",r.x.IncludesShadersStore.defaultUboDeclaration="layout(std140,column_major) uniform;\nuniform Material\n{\nvec4 diffuseLeftColor;\nvec4 diffuseRightColor;\nvec4 opacityParts;\nvec4 reflectionLeftColor;\nvec4 reflectionRightColor;\nvec4 refractionLeftColor;\nvec4 refractionRightColor;\nvec4 emissiveLeftColor;\nvec4 emissiveRightColor;\nvec2 vDiffuseInfos;\nvec2 vAmbientInfos;\nvec2 vOpacityInfos;\nvec2 vReflectionInfos;\nvec3 vReflectionPosition;\nvec3 vReflectionSize;\nvec2 vEmissiveInfos;\nvec2 vLightmapInfos;\nvec2 vSpecularInfos;\nvec3 vBumpInfos;\nmat4 diffuseMatrix;\nmat4 ambientMatrix;\nmat4 opacityMatrix;\nmat4 reflectionMatrix;\nmat4 emissiveMatrix;\nmat4 lightmapMatrix;\nmat4 specularMatrix;\nmat4 bumpMatrix;\nvec2 vTangentSpaceParams;\nfloat pointSize;\nfloat alphaCutOff;\nmat4 refractionMatrix;\nvec4 vRefractionInfos;\nvec3 vRefractionPosition;\nvec3 vRefractionSize;\nvec4 vSpecularColor;\nvec3 vEmissiveColor;\nvec4 vDiffuseColor;\nvec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",r.x.IncludesShadersStore.prePassDeclaration="#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\n#endif\n#endif\n",r.x.IncludesShadersStore.oitDeclaration="#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \nlayout(location=1) out vec4 frontColor;\nlayout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;\nuniform sampler2D oitDepthSampler;\nuniform sampler2D oitFrontColorSampler;\n#endif\n",r.x.IncludesShadersStore.mainUVVaryingDeclaration="#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n",r.x.IncludesShadersStore.lightFragmentDeclaration="#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#endif\n",r.x.IncludesShadersStore.lightUboDeclaration="#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};\nuniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float cascadeBlendFactor{X};\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\nuniform highp sampler2DArray depthSampler{X};\nuniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];\nuniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);\nvec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};\nuniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.lightsFragmentFunctions="struct lightingInfo\n{\nvec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 lightVectorW;\nfloat attenuation=1.0;\nif (lightData.w==0.)\n{\nvec3 direction=lightData.xyz-vPositionW;\nattenuation=max(0.,1.0-length(direction)/range);\nlightVectorW=normalize(direction);\n}\nelse\n{\nlightVectorW=normalize(-lightData.xyz);\n}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\nlightingInfo result;\nvec3 direction=lightData.xyz-vPositionW;\nvec3 lightVectorW=normalize(direction);\nfloat attenuation=max(0.,1.0-length(direction)/range);\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\nif (cosAngle>=lightDirection.w)\n{\ncosAngle=max(0.,pow(cosAngle,lightData.w));\nattenuation*=cosAngle;\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;\n}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;\n}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\nlightingInfo result;\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\nfloat specComp=max(0.,dot(vNormal,angleW));\nspecComp=pow(specComp,max(1.,glossiness));\nresult.specular=specComp*specularColor;\n#endif\nreturn result;\n}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){\nvec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);\nstrq/=strq.w;\nvec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;\nreturn textureColor;\n}",r.x.IncludesShadersStore.shadowsFragmentFunctions="#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\nreturn dot(color,bit_shift);\n}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{\nfloat mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));\nreturn mix(value,1.0,mask);\n}\n#define inline\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;\n}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\ndepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\nfloat visibility=1.;\nvec3 poissonDisk[4];\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);\n}\n#define inline\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \nreturn esm;\n}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{\nvec3 directionToLight=vPositionW-lightPosition;\nfloat depth=length(directionToLight);\ndepth=(depth+depthValues.x)/(depthValues.y);\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\ndirectionToLight=normalize(directionToLight);\ndirectionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn esm;\n}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nvec3 uvLayer=vec3(uv.x,uv.y,layer);\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;\n}\n}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\nfloat visibility=1.;\nvec2 poissonDisk[4];\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\npoissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\n#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec2 uv=0.5*clipSpace.xy+vec2(0.5);\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{\nreturn 1.0;\n}\nelse\n{\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\nreturn computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat shadow=texture2D(shadowSampler,uvDepthLayer);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));\nshadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));\nshadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));\nshadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nfloat shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;\nvec2 uvw1=1.+2.*st;\nvec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;\nvec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);\nshadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);\nshadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);\nshadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);\nshadow=shadow/16.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nvec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;\nvec2 uvw1=vec2(7.);\nvec2 uvw2=1.+3.*st;\nvec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;\nvec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;\nfloat shadow=0.;\nshadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);\nshadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);\nshadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);\nshadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);\nshadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);\nshadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);\nshadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);\nshadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);\nshadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);\nshadow=shadow/144.;\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.),\nvec3(0.,0.,0.)\n);\nconst vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);\nvec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\nfloat AAOffset=shadowMapSizeInverse*10.;\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);\nvec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec4 offset=vec4(poissonSamplers[i],0.);\noffset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);\nshadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);\n}\nshadow/=float(pcfTapCount);\nshadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));\nshadow=mix(darkness,1.,shadow);\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{\nif (depthMetric>1.0 || depthMetric<0.0) {\nreturn 1.0;\n}\nelse\n{\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\nvec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));\nuvDepth.z=ZINCLIP;\nfloat blockerDepth=0.0;\nfloat sumBlockerDepth=0.0;\nfloat numBlocker=0.0;\nfor (int i=0; i<searchTapCount; i ++) {\nblockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;\nif (blockerDepth<depthMetric) {\nsumBlockerDepth+=blockerDepth;\nnumBlocker++;\n}\n}\nif (numBlocker<1.0) {\nreturn 1.0;\n}\nelse\n{\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;\nfloat AAOffset=shadowMapSizeInverse*10.;\nfloat penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);\nfloat filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;\nfloat random=getRand(vPositionFromLight.xy);\nfloat rotationAngle=random*3.1415926;\nvec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));\nfloat shadow=0.;\nfor (int i=0; i<pcfTapCount; i++) {\nvec3 offset=poissonSamplers[i];\noffset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);\nshadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);\n}\nshadow/=float(pcfTapCount);\nshadow=mix(shadow,1.,depthMetric-avgBlockerDepth);\nshadow=mix(darkness,1.,shadow);\nreturn computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);\n}\n}\n}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);\n}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{\nreturn computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);\n}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{\nreturn computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);\n}\n#endif\n#endif\n",r.x.IncludesShadersStore.samplerFragmentDeclaration="#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n",r.x.IncludesShadersStore.fresnelFunction="#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\nreturn clamp(fresnelTerm,0.,1.);\n}\n#endif\n",r.x.IncludesShadersStore.reflectionFunction="vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0); \n}\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(1.0-s,t,0); \n}\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\nr=vec3(reflectionMatrix*vec4(r,0));\nfloat lon=atan(r.z,r.x);\nfloat lat=acos(r.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr=vec3(reflectionMatrix*vec4(r,0));\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=worldPos.xyz-eyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*(view*worldPos));\n}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\n}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n",r.x.IncludesShadersStore.imageProcessingDeclaration="#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\n#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;\nuniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\nuniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n#ifdef DITHER\nuniform float ditherIntensity;\n#endif\n",r.x.IncludesShadersStore.imageProcessingFunctions="#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{\nfloat sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);\nfloat sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;\nsliceUV.x+=sliceInteger*sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\nsliceUV.x+=sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;\n}\n#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);\nconst mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);\nvec3 RRTAndODTFit(vec3 v)\n{\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFitted(vec3 color)\n{\ncolor=ACESInputMat*color;\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\ncolor=saturate(color);\nreturn color;\n}\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\nviewportXY=viewportXY*2.0-1.0;\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\nvec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\nresult.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);\nresult.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\nif (contrast<1.0) {\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\n} else {\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\n}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);\nfloat dither=mix(-ditherIntensity,ditherIntensity,rand);\nresult.rgb=saturate(result.rgb+vec3(dither));\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;\n}",r.x.IncludesShadersStore.bumpFragmentMainFunctions="#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\n{\nmat4 ret=inverse(wMatrix);\nret=transpose(ret);\nret[0][3]=0.;\nret[1][3]=0.;\nret[2][3]=0.;\nret[3]=vec4(0.,0.,0.,1.);\nreturn ret;\n}\n#else\nmat4 toNormalMatrix(mat4 m)\n{\nfloat\na00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\na10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\na20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\na30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\nb00=a00*a11-a01*a10,\nb01=a00*a12-a02*a10,\nb02=a00*a13-a03*a10,\nb03=a01*a12-a02*a11,\nb04=a01*a13-a03*a11,\nb05=a02*a13-a03*a12,\nb06=a20*a31-a21*a30,\nb07=a20*a32-a22*a30,\nb08=a20*a33-a23*a30,\nb09=a21*a32-a22*a31,\nb10=a21*a33-a23*a31,\nb11=a22*a33-a23*a32,\ndet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;\nmat4 mi=mat4(\na11*b11-a12*b10+a13*b09,\na02*b10-a01*b11-a03*b09,\na31*b05-a32*b04+a33*b03,\na22*b04-a21*b05-a23*b03,\na12*b08-a10*b11-a13*b07,\na00*b11-a02*b08+a03*b07,\na32*b02-a30*b05-a33*b01,\na20*b05-a22*b02+a23*b01,\na10*b10-a11*b08+a13*b06,\na01*b08-a00*b10-a03*b06,\na30*b04-a31*b02+a33*b00,\na21*b02-a20*b04-a23*b00,\na11*b07-a10*b09-a12*b06,\na00*b09-a01*b07+a02*b06,\na31*b01-a30*b03-a32*b00,\na20*b03-a21*b01+a22*b00)/det;\nreturn mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);\n}\n#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);\n}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{\nreturn perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);\n}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{\nvec3 dp1=dFdx(p);\nvec3 dp2=dFdy(p);\nvec2 duv1=dFdx(uv);\nvec2 duv2=dFdy(uv);\nvec3 dp2perp=cross(dp2,normal);\nvec3 dp1perp=cross(normal,dp1);\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\nvec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;\ntangent*=tangentSpaceParams.x;\nbitangent*=tangentSpaceParams.y;\nfloat det=max(dot(tangent,tangent),dot(bitangent,bitangent));\nfloat invmax=det==0.0 ? 0.0 : inversesqrt(det);\nreturn mat3(tangent*invmax,bitangent*invmax,normal);\n}\n#endif\n",r.x.IncludesShadersStore.bumpFragmentFunctions="#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;\nconst float maxSamples=15.;\nconst int iMaxSamples=15;\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\nparallaxLimit*=parallaxScale;\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\nfloat stepSize=1.0/numSamples;\nfloat currRayHeight=1.0;\nvec2 vCurrOffset=vec2(0,0);\nvec2 vLastOffset=vec2(0,0);\nfloat lastSampledHeight=1.0;\nfloat currSampledHeight=1.0;\nbool keepWorking=true;\nfor (int i=0; i<iMaxSamples; i++)\n{\ncurrSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;\nif (!keepWorking)\n{\n}\nelse if (currSampledHeight>currRayHeight)\n{\nfloat delta1=currSampledHeight-currRayHeight;\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\nfloat ratio=delta1/(delta1+delta2);\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\nkeepWorking=false;\n}\nelse\n{\ncurrRayHeight-=stepSize;\nvLastOffset=vCurrOffset;\nvCurrOffset+=stepSize*vMaxOffset;\nlastSampledHeight=currSampledHeight;\n}\n}\nreturn vCurrOffset;\n}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{\nfloat height=texture2D(bumpSampler,vBumpUV).w;\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\nreturn -texCoordOffset;\n}\n#endif\n",r.x.IncludesShadersStore.logDepthDeclaration="#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;\nvarying float vFragmentDepth;\n#endif\n",r.x.IncludesShadersStore.fogFragmentDeclaration="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;\nuniform vec3 vFogColor;\nvarying vec3 vFogDistance;\nfloat CalcFogFactor()\n{\nfloat fogCoeff=1.0;\nfloat fogStart=vFogInfos.y;\nfloat fogEnd=vFogInfos.z;\nfloat fogDensity=vFogInfos.w;\nfloat fogDistance=length(vFogDistance);\nif (FOGMODE_LINEAR==vFogInfos.x)\n{\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\n}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\n}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\n}\nreturn clamp(fogCoeff,0.0,1.0);\n}\n#endif\n",r.x.IncludesShadersStore.bumpFragment="vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;\nmat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);\nvec2 detailNormalRG=detailColor.wy*2.0-1.0;\nfloat detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));\nvec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);\nnormalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;\nvec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;\nbumpNormal+=vec3(0.0,0.0,1.0);\ndetailNormal*=vec3(-1.0,-1.0,1.0);\nvec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;\nnormalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n",r.x.IncludesShadersStore.decalFragment="#ifdef DECAL\n#ifdef GAMMADECAL\ndecalColor.rgb=toLinearSpace(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalColor.a*=decalColor.a;\n#endif\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);\n#endif\n",r.x.IncludesShadersStore.depthPrePass="#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);\nreturn;\n#endif\n",r.x.IncludesShadersStore.lightFragment="#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\npreInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\npreInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\npreInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);\ninfo.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {\nindex{X}=i;\nbreak;\n}\n}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];\nfloat diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};\nif (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{\nindex{X}+=1;\nfloat nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;\nshadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.logDepthFragment="#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n",r.x.IncludesShadersStore.fogFragment="#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n",r.x.IncludesShadersStore.oitFragment="#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));\nvec2 full=unpackHalf2x16(halfFloat);\nfragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);\nvec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;\nvec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);\ndepth.rg=vec2(-MAX_DEPTH);\nfrontColor=lastFrontColor;\nbackColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;\nfloat nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;\nfloat furthestDepth=lastDepth.y;\n#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn;\n}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\ndepth.rg=vec2(-fragDepth,fragDepth);\nreturn;\n}\n#endif\n",r.x.ShadersStore.defaultPixelShader="#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#define RECIPROCAL_PI2 0.15915494\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\nvec4 baseColor=vec4(1.,1.,1.,1.);\nvec3 diffuseColor=vDiffuseColor.rgb;\nfloat alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#ifdef DECAL\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;\nvec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\nspecularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\nvec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\nvec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);\nif (dot(refractionVector,viewDirectionW)<1.0) {\nrefractionColor=refractionLookup;\n}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\nrefractionCoords.y=1.0-refractionCoords.y;\nrefractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;\nreflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\nrefractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);\ncolor=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;\ngl_FragData[0]=color; \n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;\nvec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;\nvec2 velocity=abs(a-b);\nvelocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;\ngl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\n#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {\nfrontColor.rgb+=color.rgb*color.a*alphaMultiplier;\nfrontColor.a=1.0-alphaMultiplier*(1.0-color.a);\n} else {\nbackColor+=color;\n}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n",r.x.IncludesShadersStore.decalVertexDeclaration="#ifdef DECAL\nuniform vec4 vDecalInfos;\nuniform mat4 decalMatrix;\n#endif\n",r.x.IncludesShadersStore.defaultVertexDeclaration="uniform mat4 viewProjection;\nuniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;\nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\nuniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\nuniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\nuniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n",r.x.IncludesShadersStore.uvAttributeDeclaration="#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n",r.x.IncludesShadersStore.prePassVertexDeclaration="#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;\nvarying vec4 vCurrentPosition;\nvarying vec4 vPreviousPosition;\n#endif\n#endif\n",r.x.IncludesShadersStore.samplerVertexDeclaration="#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n",r.x.IncludesShadersStore.bumpVertexDeclaration="#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#endif\n",r.x.IncludesShadersStore.fogVertexDeclaration="#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n",r.x.IncludesShadersStore.lightVxFragmentDeclaration="#ifdef LIGHT{X}\nuniform vec4 vLightData{X};\nuniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};\nuniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};\nuniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif\n",r.x.IncludesShadersStore.lightVxUboDeclaration="#ifdef LIGHT{X}\nuniform Light{X}\n{\nvec4 vLightData;\nvec4 vLightDiffuse;\nvec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;\nvec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;\nvec2 depthValues;\n} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];\nvarying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};\nvarying float vDepthMetric{X};\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.prePassVertex="#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;\npreviousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n",r.x.IncludesShadersStore.uvVariableDeclaration="#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n",r.x.IncludesShadersStore.samplerVertexImplementation="#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));\n}\n#ifdef UV2\nelse if (v_INFONAME_==1.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));\n}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));\n}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));\n}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));\n}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\n{\nv_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));\n}\n#endif\n#endif\n",r.x.IncludesShadersStore.bumpVertex="#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);\nvec3 tbnTangent=normalize(tangentUpdated.xyz);\nvec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;\nvTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif\n",r.x.IncludesShadersStore.fogVertex="#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n",r.x.IncludesShadersStore.shadowsVertex="#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {\nvPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n",r.x.IncludesShadersStore.vertexColorMixing="#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvColor=vec4(1.0);\n#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvColor*=color;\n#else\nvColor.rgb*=color.rgb;\n#endif\n#endif\n#ifdef INSTANCESCOLOR\nvColor*=instanceColor;\n#endif\n#endif\n",r.x.IncludesShadersStore.pointCloudVertex="#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n",r.x.IncludesShadersStore.logDepthVertex="#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n",r.x.ShadersStore.defaultVertexShader="#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));\nvNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {\ngl_Position=viewProjection*worldPos;\n} else {\ngl_Position=viewProjectionR*worldPos;\n}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";const Ns=new RegExp("^([gimus]+)!");let ys=(()=>{class l{constructor(e){this._plugins=[],this._activePlugins=[],this._activePluginsForExtraEvents=[],this._material=e,this._scene=e.getScene(),this._engine=this._scene.getEngine()}_addPlugin(e){for(let s=0;s<this._plugins.length;++s)if(this._plugins[s].name===e.name)throw`Plugin "${e.name}" already added to the material "${this._material.name}"!`;if(this._material._uniformBufferLayoutBuilt)throw`The plugin "${e.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;const i=e.getClassName();l._MaterialPluginClassToMainDefine[i]||(l._MaterialPluginClassToMainDefine[i]="MATERIALPLUGIN_"+ ++l._MaterialPluginCounter),this._material._callbackPluginEventGeneric=this._handlePluginEvent.bind(this),this._plugins.push(e),this._plugins.sort((s,n)=>s.priority-n.priority),this._codeInjectionPoints={};const a={};a[l._MaterialPluginClassToMainDefine[i]]={type:"boolean",default:!0};for(const s of this._plugins)s.collectDefines(a),this._collectPointNames("vertex",s.getCustomCode("vertex")),this._collectPointNames("fragment",s.getCustomCode("fragment"));this._defineNamesFromPlugins=a}_activatePlugin(e){-1===this._activePlugins.indexOf(e)&&(this._activePlugins.push(e),this._activePlugins.sort((i,a)=>i.priority-a.priority),this._material._callbackPluginEventIsReadyForSubMesh=this._handlePluginEventIsReadyForSubMesh.bind(this),this._material._callbackPluginEventPrepareDefinesBeforeAttributes=this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this),this._material._callbackPluginEventPrepareDefines=this._handlePluginEventPrepareDefines.bind(this),this._material._callbackPluginEventBindForSubMesh=this._handlePluginEventBindForSubMesh.bind(this),e.registerForExtraEvents&&(this._activePluginsForExtraEvents.push(e),this._activePluginsForExtraEvents.sort((i,a)=>i.priority-a.priority),this._material._callbackPluginEventHasRenderTargetTextures=this._handlePluginEventHasRenderTargetTextures.bind(this),this._material._callbackPluginEventFillRenderTargetTextures=this._handlePluginEventFillRenderTargetTextures.bind(this),this._material._callbackPluginEventHardBindForSubMesh=this._handlePluginEventHardBindForSubMesh.bind(this)))}getPlugin(e){for(let i=0;i<this._plugins.length;++i)if(this._plugins[i].name===e)return this._plugins[i];return null}_handlePluginEventIsReadyForSubMesh(e){let i=!0;for(const a of this._activePlugins)i=i&&a.isReadyForSubMesh(e.defines,this._scene,this._engine,e.subMesh);e.isReadyForSubMesh=i}_handlePluginEventPrepareDefinesBeforeAttributes(e){for(const i of this._activePlugins)i.prepareDefinesBeforeAttributes(e.defines,this._scene,e.mesh)}_handlePluginEventPrepareDefines(e){for(const i of this._activePlugins)i.prepareDefines(e.defines,this._scene,e.mesh)}_handlePluginEventHardBindForSubMesh(e){for(const i of this._activePluginsForExtraEvents)i.hardBindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,e.subMesh)}_handlePluginEventBindForSubMesh(e){for(const i of this._activePlugins)i.bindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,e.subMesh)}_handlePluginEventHasRenderTargetTextures(e){let i=!1;for(const a of this._activePluginsForExtraEvents)if(i=a.hasRenderTargetTextures(),i)break;e.hasRenderTargetTextures=i}_handlePluginEventFillRenderTargetTextures(e){for(const i of this._activePluginsForExtraEvents)i.fillRenderTargetTextures(e.renderTargets)}_handlePluginEvent(e,i){var a;switch(e){case r.aa.GetActiveTextures:{const s=i;for(const n of this._activePlugins)n.getActiveTextures(s.activeTextures);break}case r.aa.GetAnimatables:{const s=i;for(const n of this._activePlugins)n.getAnimatables(s.animatables);break}case r.aa.HasTexture:{const s=i;let n=!1;for(const o of this._activePlugins)if(n=o.hasTexture(s.texture),n)break;s.hasTexture=n;break}case r.aa.Disposed:{const s=i;for(const n of this._plugins)n.dispose(s.forceDisposeTextures);break}case r.aa.GetDefineNames:i.defineNames=this._defineNamesFromPlugins;break;case r.aa.PrepareEffect:{const s=i;for(const n of this._activePlugins)s.fallbackRank=n.addFallbacks(s.defines,s.fallbacks,s.fallbackRank),n.getAttributes(s.attributes,this._scene,s.mesh);this._uniformList.length>0&&s.uniforms.push(...this._uniformList),this._samplerList.length>0&&s.samplers.push(...this._samplerList),this._uboList.length>0&&s.uniformBuffersNames.push(...this._uboList),s.customCode=this._injectCustomCode(s.customCode);break}case r.aa.PrepareUniformBuffer:{const s=i;this._uboDeclaration="",this._vertexDeclaration="",this._fragmentDeclaration="",this._uniformList=[],this._samplerList=[],this._uboList=[];for(const n of this._plugins){const o=n.getUniforms();if(o){if(o.ubo)for(const c of o.ubo){if(c.size&&c.type){const h=null!==(a=c.arraySize)&&void 0!==a?a:0;s.ubo.addUniform(c.name,c.size,h),this._uboDeclaration+=`${c.type} ${c.name}${h>0?`[${h}]`:""};\r\n`}this._uniformList.push(c.name)}o.vertex&&(this._vertexDeclaration+=o.vertex+"\r\n"),o.fragment&&(this._fragmentDeclaration+=o.fragment+"\r\n")}n.getSamplers(this._samplerList),n.getUniformBuffersNames(this._uboList)}break}}}_collectPointNames(e,i){if(i)for(const a in i)this._codeInjectionPoints[e]||(this._codeInjectionPoints[e]={}),this._codeInjectionPoints[e][a]=!0}_injectCustomCode(e){return(i,a)=>{var s;e&&(a=e(i,a)),this._uboDeclaration&&(a=a.replace("#define ADDITIONAL_UBO_DECLARATION",this._uboDeclaration)),this._vertexDeclaration&&(a=a.replace("#define ADDITIONAL_VERTEX_DECLARATION",this._vertexDeclaration)),this._fragmentDeclaration&&(a=a.replace("#define ADDITIONAL_FRAGMENT_DECLARATION",this._fragmentDeclaration));const n=null===(s=this._codeInjectionPoints)||void 0===s?void 0:s[i];if(!n)return a;for(let o in n){let c="";for(const h of this._activePlugins){const d=h.getCustomCode(i);null!=d&&d[o]&&(c+=d[o]+"\r\n")}if(c.length>0)if("!"===o.charAt(0)){o=o.substring(1);let h="g";if("!"===o.charAt(0))h="",o=o.substring(1);else{const p=Ns.exec(o);p&&p.length>=2&&(h=p[1],o=o.substring(h.length+1))}h.indexOf("g")<0&&(h+="g");const d=a,u=new RegExp(o,h);let f=u.exec(d);for(;null!==f;){let p=c;for(let m=0;m<f.length;++m)p=p.replace("$"+m,f[m]);a=a.replace(f[0],p),f=u.exec(d)}}else{const h="#define "+o;a=a.replace(h,"\r\n"+c+"\r\n"+h)}}return a}}}return l._MaterialPluginClassToMainDefine={},l._MaterialPluginCounter=0,l})();class Te{_enable(t){t&&this._pluginManager._activatePlugin(this)}constructor(t,e,i,a,s=!0,n=!1){this.priority=500,this.registerForExtraEvents=!1,this._material=t,this.name=e,this.priority=i,t.pluginManager||(t.pluginManager=new ys(t),t.onDisposeObservable.add(()=>{t.pluginManager=void 0})),this._pluginDefineNames=a,this._pluginManager=t.pluginManager,s&&this._pluginManager._addPlugin(this),n&&this._enable(!0),this.markAllDefinesAsDirty=t._dirtyCallbacks[63]}getClassName(){return"MaterialPluginBase"}isReadyForSubMesh(t,e,i,a){return!0}hardBindForSubMesh(t,e,i,a){}bindForSubMesh(t,e,i,a){}dispose(t){}getCustomCode(t){return null}collectDefines(t){if(this._pluginDefineNames)for(const e of Object.keys(this._pluginDefineNames)){if("_"===e[0])continue;const i=typeof this._pluginDefineNames[e];t[e]={type:"number"===i?"number":"string"===i?"string":"boolean"===i?"boolean":"object",default:this._pluginDefineNames[e]}}}prepareDefinesBeforeAttributes(t,e,i){}prepareDefines(t,e,i){}hasTexture(t){return!1}hasRenderTargetTextures(){return!1}fillRenderTargetTextures(t){}getActiveTextures(t){}getAnimatables(t){}addFallbacks(t,e,i){return i}getSamplers(t){}getAttributes(t,e,i){}getUniformBuffersNames(t){}getUniforms(){return{}}copyTo(t){r.j.Clone(()=>t,this)}serialize(){return r.j.Serialize(this)}parse(t,e,i){r.j.Parse(()=>this,t,e,i)}}(0,r._)([(0,r.f)()],Te.prototype,"name",void 0),(0,r._)([(0,r.f)()],Te.prototype,"priority",void 0),(0,r._)([(0,r.f)()],Te.prototype,"registerForExtraEvents",void 0);class Us extends Re{constructor(){super(...arguments),this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0}}class le extends Te{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(t,e=!0){super(t,"DetailMap",140,new Us,e),this._texture=null,this.diffuseBlendLevel=1,this.roughnessBlendLevel=1,this.bumpLevel=1,this._normalBlendMethod=r.a9.MATERIAL_NORMALBLENDMETHOD_WHITEOUT,this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=t._dirtyCallbacks[1]}isReadyForSubMesh(t,e,i){return!this._isEnabled||!(t._areTexturesDirty&&e.texturesEnabled&&i.getCaps().standardDerivatives&&this._texture&&D.DetailTextureEnabled&&!this._texture.isReady())}prepareDefines(t,e){if(this._isEnabled){t.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod;const i=e.getEngine();t._areTexturesDirty&&(i.getCaps().standardDerivatives&&this._texture&&D.DetailTextureEnabled&&this._isEnabled?(r.a0.PrepareDefinesForMergedUV(this._texture,t,"DETAIL"),t.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod):t.DETAIL=!1)}else t.DETAIL=!1}bindForSubMesh(t,e){this._isEnabled&&((!t.useUbo||!this._material.isFrozen||!t.isSync)&&this._texture&&D.DetailTextureEnabled&&(t.updateFloat4("vDetailInfos",this._texture.coordinatesIndex,this.diffuseBlendLevel,this.bumpLevel,this.roughnessBlendLevel),r.a0.BindTextureMatrix(this._texture,t,"detail")),e.texturesEnabled&&this._texture&&D.DetailTextureEnabled&&t.setTexture("detailSampler",this._texture))}hasTexture(t){return this._texture===t}getActiveTextures(t){this._texture&&t.push(this._texture)}getAnimatables(t){this._texture&&this._texture.animations&&this._texture.animations.length>0&&t.push(this._texture)}dispose(t){var e;t&&(null===(e=this._texture)||void 0===e||e.dispose())}getClassName(){return"DetailMapConfiguration"}getSamplers(t){t.push("detailSampler")}getUniforms(){return{ubo:[{name:"vDetailInfos",size:4,type:"vec4"},{name:"detailMatrix",size:16,type:"mat4"}]}}}(0,r._)([(0,r.m)("detailTexture"),(0,r.l)("_markAllSubMeshesAsTexturesDirty")],le.prototype,"texture",void 0),(0,r._)([(0,r.f)()],le.prototype,"diffuseBlendLevel",void 0),(0,r._)([(0,r.f)()],le.prototype,"roughnessBlendLevel",void 0),(0,r._)([(0,r.f)()],le.prototype,"bumpLevel",void 0),(0,r._)([(0,r.f)(),(0,r.l)("_markAllSubMeshesAsTexturesDirty")],le.prototype,"normalBlendMethod",void 0),(0,r._)([(0,r.f)(),(0,r.l)("_markAllSubMeshesAsTexturesDirty")],le.prototype,"isEnabled",void 0);const Ve={effect:null,subMesh:null};class Bs extends Re{constructor(t){super(t),this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.OPACITY=!1,this.OPACITYDIRECTUV=0,this.OPACITYRGB=!1,this.REFLECTION=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.SPECULAR=!1,this.SPECULARDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAXOCCLUSION=!1,this.SPECULAROVERALPHA=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.SPECULARTERM=!1,this.DIFFUSEFRESNEL=!1,this.OPACITYFRESNEL=!1,this.REFLECTIONFRESNEL=!1,this.REFRACTIONFRESNEL=!1,this.EMISSIVEFRESNEL=!1,this.FRESNEL=!1,this.NORMAL=!1,this.TANGENT=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.INSTANCESCOLOR=!1,this.GLOSSINESS=!1,this.ROUGHNESS=!1,this.EMISSIVEASILLUMINATION=!1,this.LINKEMISSIVEWITHDIFFUSE=!1,this.REFLECTIONFRESNELFROMSPECULAR=!1,this.LIGHTMAP=!1,this.LIGHTMAPDIRECTUV=0,this.OBJECTSPACE_NORMALMAP=!1,this.USELIGHTMAPASSHADOWMAP=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFRACTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_OPPOSITEZ=!1,this.INVERTCUBICMAP=!1,this.LOGARITHMICDEPTH=!1,this.REFRACTION=!1,this.REFRACTIONMAP_3D=!1,this.REFLECTIONOVERALPHA=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.RGBDLIGHTMAP=!1,this.RGBDREFLECTION=!1,this.RGBDREFRACTION=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.CAMERA_ORTHOGRAPHIC=!1,this.CAMERA_PERSPECTIVE=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.rebuild()}setReflectionMode(t){const e=["REFLECTIONMAP_CUBIC","REFLECTIONMAP_EXPLICIT","REFLECTIONMAP_PLANAR","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_PROJECTION","REFLECTIONMAP_SKYBOX","REFLECTIONMAP_SPHERICAL","REFLECTIONMAP_EQUIRECTANGULAR","REFLECTIONMAP_EQUIRECTANGULAR_FIXED","REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"];for(const i of e)this[i]=i===t}}class v extends Je{get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(t){this._attachImageProcessingConfiguration(t),this._markAllSubMeshesAsTexturesDirty()}_attachImageProcessingConfiguration(t){t!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration=t||this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._markAllSubMeshesAsImageProcessingDirty()})))}get isPrePassCapable(){return!this.disableDepthWrite}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(t){this.imageProcessingConfiguration.colorCurvesEnabled=t}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(t){this.imageProcessingConfiguration.colorGradingEnabled=t}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(t){this._imageProcessingConfiguration.toneMappingEnabled=t}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(t){this._imageProcessingConfiguration.exposure=t}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(t){this._imageProcessingConfiguration.contrast=t}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(t){this._imageProcessingConfiguration.colorGradingTexture=t}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(t){this._imageProcessingConfiguration.colorCurves=t}get canRenderToMRT(){return!0}constructor(t,e){super(t,e),this._diffuseTexture=null,this._ambientTexture=null,this._opacityTexture=null,this._reflectionTexture=null,this._emissiveTexture=null,this._specularTexture=null,this._bumpTexture=null,this._lightmapTexture=null,this._refractionTexture=null,this.ambientColor=new r.h(0,0,0),this.diffuseColor=new r.h(1,1,1),this.specularColor=new r.h(1,1,1),this.emissiveColor=new r.h(0,0,0),this.specularPower=64,this._useAlphaFromDiffuseTexture=!1,this._useEmissiveAsIllumination=!1,this._linkEmissiveWithDiffuse=!1,this._useSpecularOverAlpha=!1,this._useReflectionOverAlpha=!1,this._disableLighting=!1,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this.parallaxScaleBias=.05,this._roughness=0,this.indexOfRefraction=.98,this.invertRefractionY=!0,this.alphaCutOff=.4,this._useLightmapAsShadowmap=!1,this._useReflectionFresnelFromSpecular=!1,this._useGlossinessFromSpecularMapAlpha=!1,this._maxSimultaneousLights=4,this._invertNormalMapX=!1,this._invertNormalMapY=!1,this._twoSidedLighting=!1,this._renderTargets=new r.Y(16),this._worldViewProjectionMatrix=r.b.Zero(),this._globalAmbientColor=new r.h(0,0,0),this._cacheHasRenderTargetTextures=!1,this.detailMap=new le(this),this._attachImageProcessingConfiguration(null),this.prePassConfiguration=new $e,this.getRenderTargetTextures=()=>(this._renderTargets.reset(),v.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._renderTargets.push(this._reflectionTexture),v.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget&&this._renderTargets.push(this._refractionTexture),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets)}get hasRenderTargetTextures(){return!!(v.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget||v.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget)||this._cacheHasRenderTargetTextures}getClassName(){return"StandardMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(t){this._useLogarithmicDepth=t&&this.getScene().getEngine().getCaps().fragmentDepthSupported,this._markAllSubMeshesAsMiscDirty()}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||null!=this._opacityTexture||this._shouldUseAlphaFromDiffuseTexture()||this._opacityFresnelParameters&&this._opacityFresnelParameters.isEnabled)}needAlphaTesting(){return!!this._forceAlphaTest||this._hasAlphaChannel()&&(null==this._transparencyMode||this._transparencyMode===r.a9.MATERIAL_ALPHATEST)}_shouldUseAlphaFromDiffuseTexture(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==r.a9.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha||null!=this._opacityTexture}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(t,e,i=!1){if(this._uniformBufferLayoutBuilt||this.buildUniformLayout(),e.effect&&this.isFrozen&&e.effect._wasPreviouslyReady&&e.effect._wasPreviouslyUsingInstances===i)return!0;e.materialDefines||(this._callbackPluginEventGeneric(r.aa.GetDefineNames,this._eventInfo),e.materialDefines=new Bs(this._eventInfo.defineNames));const a=this.getScene(),s=e.materialDefines;if(this._isReadyForSubMesh(e))return!0;const n=a.getEngine();s._needNormals=r.a0.PrepareDefinesForLights(a,t,s,!0,this._maxSimultaneousLights,this._disableLighting),r.a0.PrepareDefinesForMultiview(a,s);const o=this.needAlphaBlendingForMesh(t)&&this.getScene().useOrderIndependentTransparency;if(r.a0.PrepareDefinesForPrePass(a,s,this.canRenderToMRT&&!o),r.a0.PrepareDefinesForOIT(a,s,o),s._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,s._needUVs=!1;for(let h=1;h<=6;++h)s["MAINUV"+h]=!1;if(a.texturesEnabled){if(s.DIFFUSEDIRECTUV=0,s.BUMPDIRECTUV=0,s.AMBIENTDIRECTUV=0,s.OPACITYDIRECTUV=0,s.EMISSIVEDIRECTUV=0,s.SPECULARDIRECTUV=0,s.LIGHTMAPDIRECTUV=0,this._diffuseTexture&&v.DiffuseTextureEnabled){if(!this._diffuseTexture.isReadyOrNotBlocking())return!1;r.a0.PrepareDefinesForMergedUV(this._diffuseTexture,s,"DIFFUSE")}else s.DIFFUSE=!1;if(this._ambientTexture&&v.AmbientTextureEnabled){if(!this._ambientTexture.isReadyOrNotBlocking())return!1;r.a0.PrepareDefinesForMergedUV(this._ambientTexture,s,"AMBIENT")}else s.AMBIENT=!1;if(this._opacityTexture&&v.OpacityTextureEnabled){if(!this._opacityTexture.isReadyOrNotBlocking())return!1;r.a0.PrepareDefinesForMergedUV(this._opacityTexture,s,"OPACITY"),s.OPACITYRGB=this._opacityTexture.getAlphaFromRGB}else s.OPACITY=!1;if(this._reflectionTexture&&v.ReflectionTextureEnabled){if(!this._reflectionTexture.isReadyOrNotBlocking())return!1;switch(s._needNormals=!0,s.REFLECTION=!0,s.ROUGHNESS=this._roughness>0,s.REFLECTIONOVERALPHA=this._useReflectionOverAlpha,s.INVERTCUBICMAP=this._reflectionTexture.coordinatesMode===g.INVCUBIC_MODE,s.REFLECTIONMAP_3D=this._reflectionTexture.isCube,s.REFLECTIONMAP_OPPOSITEZ=s.REFLECTIONMAP_3D&&this.getScene().useRightHandedSystem?!this._reflectionTexture.invertZ:this._reflectionTexture.invertZ,s.RGBDREFLECTION=this._reflectionTexture.isRGBD,this._reflectionTexture.coordinatesMode){case g.EXPLICIT_MODE:s.setReflectionMode("REFLECTIONMAP_EXPLICIT");break;case g.PLANAR_MODE:s.setReflectionMode("REFLECTIONMAP_PLANAR");break;case g.PROJECTION_MODE:s.setReflectionMode("REFLECTIONMAP_PROJECTION");break;case g.SKYBOX_MODE:s.setReflectionMode("REFLECTIONMAP_SKYBOX");break;case g.SPHERICAL_MODE:s.setReflectionMode("REFLECTIONMAP_SPHERICAL");break;case g.EQUIRECTANGULAR_MODE:s.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");break;case g.FIXED_EQUIRECTANGULAR_MODE:s.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");break;case g.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:s.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");break;default:s.setReflectionMode("REFLECTIONMAP_CUBIC")}s.USE_LOCAL_REFLECTIONMAP_CUBIC=!!this._reflectionTexture.boundingBoxSize}else s.REFLECTION=!1,s.REFLECTIONMAP_OPPOSITEZ=!1;if(this._emissiveTexture&&v.EmissiveTextureEnabled){if(!this._emissiveTexture.isReadyOrNotBlocking())return!1;r.a0.PrepareDefinesForMergedUV(this._emissiveTexture,s,"EMISSIVE")}else s.EMISSIVE=!1;if(this._lightmapTexture&&v.LightmapTextureEnabled){if(!this._lightmapTexture.isReadyOrNotBlocking())return!1;r.a0.PrepareDefinesForMergedUV(this._lightmapTexture,s,"LIGHTMAP"),s.USELIGHTMAPASSHADOWMAP=this._useLightmapAsShadowmap,s.RGBDLIGHTMAP=this._lightmapTexture.isRGBD}else s.LIGHTMAP=!1;if(this._specularTexture&&v.SpecularTextureEnabled){if(!this._specularTexture.isReadyOrNotBlocking())return!1;r.a0.PrepareDefinesForMergedUV(this._specularTexture,s,"SPECULAR"),s.GLOSSINESS=this._useGlossinessFromSpecularMapAlpha}else s.SPECULAR=!1;if(a.getEngine().getCaps().standardDerivatives&&this._bumpTexture&&v.BumpTextureEnabled){if(!this._bumpTexture.isReady())return!1;r.a0.PrepareDefinesForMergedUV(this._bumpTexture,s,"BUMP"),s.PARALLAX=this._useParallax,s.PARALLAXOCCLUSION=this._useParallaxOcclusion,s.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap}else s.BUMP=!1,s.PARALLAX=!1,s.PARALLAXOCCLUSION=!1;if(this._refractionTexture&&v.RefractionTextureEnabled){if(!this._refractionTexture.isReadyOrNotBlocking())return!1;s._needUVs=!0,s.REFRACTION=!0,s.REFRACTIONMAP_3D=this._refractionTexture.isCube,s.RGBDREFRACTION=this._refractionTexture.isRGBD,s.USE_LOCAL_REFRACTIONMAP_CUBIC=!!this._refractionTexture.boundingBoxSize}else s.REFRACTION=!1;s.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else s.DIFFUSE=!1,s.AMBIENT=!1,s.OPACITY=!1,s.REFLECTION=!1,s.EMISSIVE=!1,s.LIGHTMAP=!1,s.BUMP=!1,s.REFRACTION=!1;s.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),s.EMISSIVEASILLUMINATION=this._useEmissiveAsIllumination,s.LINKEMISSIVEWITHDIFFUSE=this._linkEmissiveWithDiffuse,s.SPECULAROVERALPHA=this._useSpecularOverAlpha,s.PREMULTIPLYALPHA=7===this.alphaMode||8===this.alphaMode,s.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,s.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(t)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=s,this._eventInfo.subMesh=e,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(s._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(s),s.IS_REFLECTION_LINEAR=null!=this.reflectionTexture&&!this.reflectionTexture.gammaSpace,s.IS_REFRACTION_LINEAR=null!=this.refractionTexture&&!this.refractionTexture.gammaSpace}s._areFresnelDirty&&(v.FresnelEnabled?(this._diffuseFresnelParameters||this._opacityFresnelParameters||this._emissiveFresnelParameters||this._refractionFresnelParameters||this._reflectionFresnelParameters)&&(s.DIFFUSEFRESNEL=this._diffuseFresnelParameters&&this._diffuseFresnelParameters.isEnabled,s.OPACITYFRESNEL=this._opacityFresnelParameters&&this._opacityFresnelParameters.isEnabled,s.REFLECTIONFRESNEL=this._reflectionFresnelParameters&&this._reflectionFresnelParameters.isEnabled,s.REFLECTIONFRESNELFROMSPECULAR=this._useReflectionFresnelFromSpecular,s.REFRACTIONFRESNEL=this._refractionFresnelParameters&&this._refractionFresnelParameters.isEnabled,s.EMISSIVEFRESNEL=this._emissiveFresnelParameters&&this._emissiveFresnelParameters.isEnabled,s._needNormals=!0,s.FRESNEL=!0):s.FRESNEL=!1),r.a0.PrepareDefinesForMisc(t,a,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(t)||this._forceAlphaTest,s),r.a0.PrepareDefinesForFrameBoundValues(a,n,this,s,i,null,e.getRenderingMesh().hasThinInstances),this._eventInfo.defines=s,this._eventInfo.mesh=t,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),r.a0.PrepareDefinesForAttributes(t,s,!0,!0,!0),this._callbackPluginEventPrepareDefines(this._eventInfo);let c=!1;if(s.isDirty){const h=s._areLightsDisposed;s.markAsProcessed();const d=new Be;s.REFLECTION&&d.addFallback(0,"REFLECTION"),s.SPECULAR&&d.addFallback(0,"SPECULAR"),s.BUMP&&d.addFallback(0,"BUMP"),s.PARALLAX&&d.addFallback(1,"PARALLAX"),s.PARALLAXOCCLUSION&&d.addFallback(0,"PARALLAXOCCLUSION"),s.SPECULAROVERALPHA&&d.addFallback(0,"SPECULAROVERALPHA"),s.FOG&&d.addFallback(1,"FOG"),s.POINTSIZE&&d.addFallback(0,"POINTSIZE"),s.LOGARITHMICDEPTH&&d.addFallback(0,"LOGARITHMICDEPTH"),r.a0.HandleFallbacksForShadows(s,d,this._maxSimultaneousLights),s.SPECULARTERM&&d.addFallback(0,"SPECULARTERM"),s.DIFFUSEFRESNEL&&d.addFallback(1,"DIFFUSEFRESNEL"),s.OPACITYFRESNEL&&d.addFallback(2,"OPACITYFRESNEL"),s.REFLECTIONFRESNEL&&d.addFallback(3,"REFLECTIONFRESNEL"),s.EMISSIVEFRESNEL&&d.addFallback(4,"EMISSIVEFRESNEL"),s.FRESNEL&&d.addFallback(4,"FRESNEL"),s.MULTIVIEW&&d.addFallback(0,"MULTIVIEW");const u=[r.z.PositionKind];s.NORMAL&&u.push(r.z.NormalKind),s.TANGENT&&u.push(r.z.TangentKind);for(let R=1;R<=6;++R)s["UV"+R]&&u.push(`uv${1===R?"":R}`);s.VERTEXCOLOR&&u.push(r.z.ColorKind),r.a0.PrepareAttributesForBones(u,t,s,d),r.a0.PrepareAttributesForInstances(u,s),r.a0.PrepareAttributesForMorphTargets(u,t,s),r.a0.PrepareAttributesForBakedVertexAnimation(u,t,s);let f="default";const p=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vDiffuseColor","vSpecularColor","vEmissiveColor","visibility","vFogInfos","vFogColor","pointSize","vDiffuseInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vEmissiveInfos","vSpecularInfos","vBumpInfos","vLightmapInfos","vRefractionInfos","mBones","diffuseMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","specularMatrix","bumpMatrix","normalMatrix","lightmapMatrix","refractionMatrix","diffuseLeftColor","diffuseRightColor","opacityParts","reflectionLeftColor","reflectionRightColor","emissiveLeftColor","emissiveRightColor","refractionLeftColor","refractionRightColor","vReflectionPosition","vReflectionSize","vRefractionPosition","vRefractionSize","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices"],m=["diffuseSampler","ambientSampler","opacitySampler","reflectionCubeSampler","reflection2DSampler","emissiveSampler","specularSampler","bumpSampler","lightmapSampler","refractionCubeSampler","refraction2DSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler"],S=["Material","Scene","Mesh"];this._eventInfo.fallbacks=d,this._eventInfo.fallbackRank=0,this._eventInfo.defines=s,this._eventInfo.uniforms=p,this._eventInfo.attributes=u,this._eventInfo.samplers=m,this._eventInfo.uniformBuffersNames=S,this._eventInfo.customCode=void 0,this._eventInfo.mesh=t,this._callbackPluginEventGeneric(r.aa.PrepareEffect,this._eventInfo),$e.AddUniforms(p),r.ab&&(r.ab.PrepareUniforms(p,s),r.ab.PrepareSamplers(m,s)),r.a0.PrepareUniformsAndSamplersList({uniformsNames:p,uniformBuffersNames:S,samplers:m,defines:s,maxSimultaneousLights:this._maxSimultaneousLights}),(0,r.a3)(p);const _={};this.customShaderNameResolve&&(f=this.customShaderNameResolve(f,p,S,m,s,u,_));const T=s.toString(),E=e.effect;let x=a.getEngine().createEffect(f,{attributes:u,uniformsNames:p,uniformBuffersNames:S,samplers:m,defines:T,fallbacks:d,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:s.NUM_MORPH_INFLUENCERS},processFinalCode:_.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:s.PREPASS},n);if(this._eventInfo.customCode=void 0,x)if(this._onEffectCreatedObservable&&(Ve.effect=x,Ve.subMesh=e,this._onEffectCreatedObservable.notifyObservers(Ve)),this.allowShaderHotSwapping&&E&&!x.isReady()){if(x=E,s.markAsUnprocessed(),c=this.isFrozen,h)return s._areLightsDisposed=!0,!1}else a.resetCachedMaterial(),e.setEffect(x,s,this._materialContext)}return!(!e.effect||!e.effect.isReady()||(s._renderId=a.getRenderId(),e.effect._wasPreviouslyReady=!c,e.effect._wasPreviouslyUsingInstances=i,this._checkScenePerformancePriority(),0))}buildUniformLayout(){const t=this._uniformBuffer;t.addUniform("diffuseLeftColor",4),t.addUniform("diffuseRightColor",4),t.addUniform("opacityParts",4),t.addUniform("reflectionLeftColor",4),t.addUniform("reflectionRightColor",4),t.addUniform("refractionLeftColor",4),t.addUniform("refractionRightColor",4),t.addUniform("emissiveLeftColor",4),t.addUniform("emissiveRightColor",4),t.addUniform("vDiffuseInfos",2),t.addUniform("vAmbientInfos",2),t.addUniform("vOpacityInfos",2),t.addUniform("vReflectionInfos",2),t.addUniform("vReflectionPosition",3),t.addUniform("vReflectionSize",3),t.addUniform("vEmissiveInfos",2),t.addUniform("vLightmapInfos",2),t.addUniform("vSpecularInfos",2),t.addUniform("vBumpInfos",3),t.addUniform("diffuseMatrix",16),t.addUniform("ambientMatrix",16),t.addUniform("opacityMatrix",16),t.addUniform("reflectionMatrix",16),t.addUniform("emissiveMatrix",16),t.addUniform("lightmapMatrix",16),t.addUniform("specularMatrix",16),t.addUniform("bumpMatrix",16),t.addUniform("vTangentSpaceParams",2),t.addUniform("pointSize",1),t.addUniform("alphaCutOff",1),t.addUniform("refractionMatrix",16),t.addUniform("vRefractionInfos",4),t.addUniform("vRefractionPosition",3),t.addUniform("vRefractionSize",3),t.addUniform("vSpecularColor",4),t.addUniform("vEmissiveColor",3),t.addUniform("vDiffuseColor",4),t.addUniform("vAmbientColor",3),super.buildUniformLayout()}bindForSubMesh(t,e,i){var a;const s=this.getScene(),n=i.materialDefines;if(!n)return;const o=i.effect;if(!o)return;this._activeEffect=o,e.getMeshUniformBuffer().bindToEffect(o,"Mesh"),e.transferToEffect(t),this._uniformBuffer.bindToEffect(o,"Material"),this.prePassConfiguration.bindForSubMesh(this._activeEffect,s,e,t,this.isFrozen),this._eventInfo.subMesh=i,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),n.OBJECTSPACE_NORMALMAP&&(t.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const c=o._forceRebindOnNextCall||this._mustRebind(s,o,e.visibility);r.a0.BindBonesParameters(e,o);const h=this._uniformBuffer;if(c){if(this.bindViewProjection(o),!h.useUbo||!this.isFrozen||!h.isSync||o._forceRebindOnNextCall){if(v.FresnelEnabled&&n.FRESNEL&&(this.diffuseFresnelParameters&&this.diffuseFresnelParameters.isEnabled&&(h.updateColor4("diffuseLeftColor",this.diffuseFresnelParameters.leftColor,this.diffuseFresnelParameters.power),h.updateColor4("diffuseRightColor",this.diffuseFresnelParameters.rightColor,this.diffuseFresnelParameters.bias)),this.opacityFresnelParameters&&this.opacityFresnelParameters.isEnabled&&h.updateColor4("opacityParts",new r.h(this.opacityFresnelParameters.leftColor.toLuminance(),this.opacityFresnelParameters.rightColor.toLuminance(),this.opacityFresnelParameters.bias),this.opacityFresnelParameters.power),this.reflectionFresnelParameters&&this.reflectionFresnelParameters.isEnabled&&(h.updateColor4("reflectionLeftColor",this.reflectionFresnelParameters.leftColor,this.reflectionFresnelParameters.power),h.updateColor4("reflectionRightColor",this.reflectionFresnelParameters.rightColor,this.reflectionFresnelParameters.bias)),this.refractionFresnelParameters&&this.refractionFresnelParameters.isEnabled&&(h.updateColor4("refractionLeftColor",this.refractionFresnelParameters.leftColor,this.refractionFresnelParameters.power),h.updateColor4("refractionRightColor",this.refractionFresnelParameters.rightColor,this.refractionFresnelParameters.bias)),this.emissiveFresnelParameters&&this.emissiveFresnelParameters.isEnabled&&(h.updateColor4("emissiveLeftColor",this.emissiveFresnelParameters.leftColor,this.emissiveFresnelParameters.power),h.updateColor4("emissiveRightColor",this.emissiveFresnelParameters.rightColor,this.emissiveFresnelParameters.bias))),s.texturesEnabled){if(this._diffuseTexture&&v.DiffuseTextureEnabled&&(h.updateFloat2("vDiffuseInfos",this._diffuseTexture.coordinatesIndex,this._diffuseTexture.level),r.a0.BindTextureMatrix(this._diffuseTexture,h,"diffuse")),this._ambientTexture&&v.AmbientTextureEnabled&&(h.updateFloat2("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level),r.a0.BindTextureMatrix(this._ambientTexture,h,"ambient")),this._opacityTexture&&v.OpacityTextureEnabled&&(h.updateFloat2("vOpacityInfos",this._opacityTexture.coordinatesIndex,this._opacityTexture.level),r.a0.BindTextureMatrix(this._opacityTexture,h,"opacity")),this._hasAlphaChannel()&&h.updateFloat("alphaCutOff",this.alphaCutOff),this._reflectionTexture&&v.ReflectionTextureEnabled&&(h.updateFloat2("vReflectionInfos",this._reflectionTexture.level,this.roughness),h.updateMatrix("reflectionMatrix",this._reflectionTexture.getReflectionTextureMatrix()),this._reflectionTexture.boundingBoxSize)){const d=this._reflectionTexture;h.updateVector3("vReflectionPosition",d.boundingBoxPosition),h.updateVector3("vReflectionSize",d.boundingBoxSize)}if(this._emissiveTexture&&v.EmissiveTextureEnabled&&(h.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),r.a0.BindTextureMatrix(this._emissiveTexture,h,"emissive")),this._lightmapTexture&&v.LightmapTextureEnabled&&(h.updateFloat2("vLightmapInfos",this._lightmapTexture.coordinatesIndex,this._lightmapTexture.level),r.a0.BindTextureMatrix(this._lightmapTexture,h,"lightmap")),this._specularTexture&&v.SpecularTextureEnabled&&(h.updateFloat2("vSpecularInfos",this._specularTexture.coordinatesIndex,this._specularTexture.level),r.a0.BindTextureMatrix(this._specularTexture,h,"specular")),this._bumpTexture&&s.getEngine().getCaps().standardDerivatives&&v.BumpTextureEnabled&&(h.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this.parallaxScaleBias),r.a0.BindTextureMatrix(this._bumpTexture,h,"bump"),s._mirroredCameraPosition?h.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):h.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this._refractionTexture&&v.RefractionTextureEnabled){let d=1;if(this._refractionTexture.isCube||(h.updateMatrix("refractionMatrix",this._refractionTexture.getReflectionTextureMatrix()),this._refractionTexture.depth&&(d=this._refractionTexture.depth)),h.updateFloat4("vRefractionInfos",this._refractionTexture.level,this.indexOfRefraction,d,this.invertRefractionY?-1:1),this._refractionTexture.boundingBoxSize){const u=this._refractionTexture;h.updateVector3("vRefractionPosition",u.boundingBoxPosition),h.updateVector3("vRefractionSize",u.boundingBoxSize)}}}this.pointsCloud&&h.updateFloat("pointSize",this.pointSize),n.SPECULARTERM&&h.updateColor4("vSpecularColor",this.specularColor,this.specularPower),h.updateColor3("vEmissiveColor",v.EmissiveTextureEnabled?this.emissiveColor:r.h.BlackReadOnly),h.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),s.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),h.updateColor3("vAmbientColor",this._globalAmbientColor)}s.texturesEnabled&&(this._diffuseTexture&&v.DiffuseTextureEnabled&&o.setTexture("diffuseSampler",this._diffuseTexture),this._ambientTexture&&v.AmbientTextureEnabled&&o.setTexture("ambientSampler",this._ambientTexture),this._opacityTexture&&v.OpacityTextureEnabled&&o.setTexture("opacitySampler",this._opacityTexture),this._reflectionTexture&&v.ReflectionTextureEnabled&&o.setTexture(this._reflectionTexture.isCube?"reflectionCubeSampler":"reflection2DSampler",this._reflectionTexture),this._emissiveTexture&&v.EmissiveTextureEnabled&&o.setTexture("emissiveSampler",this._emissiveTexture),this._lightmapTexture&&v.LightmapTextureEnabled&&o.setTexture("lightmapSampler",this._lightmapTexture),this._specularTexture&&v.SpecularTextureEnabled&&o.setTexture("specularSampler",this._specularTexture),this._bumpTexture&&s.getEngine().getCaps().standardDerivatives&&v.BumpTextureEnabled&&o.setTexture("bumpSampler",this._bumpTexture),this._refractionTexture&&v.RefractionTextureEnabled&&o.setTexture(this._refractionTexture.isCube?"refractionCubeSampler":"refraction2DSampler",this._refractionTexture)),this.getScene().useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(e)&&this.getScene().depthPeelingRenderer.bind(o),this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),(0,r.a1)(o,this,s),this.bindEyePosition(o)}else s.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);(c||!this.isFrozen)&&(s.lightsEnabled&&!this._disableLighting&&r.a0.BindLights(s,e,o,n,this._maxSimultaneousLights),(s.fogEnabled&&e.applyFog&&s.fogMode!==r.S.FOGMODE_NONE||this._reflectionTexture||this._refractionTexture||e.receiveShadows||n.PREPASS)&&this.bindView(o),r.a0.BindFogParameters(s,e,o),n.NUM_MORPH_INFLUENCERS&&r.a0.BindMorphTargetParameters(e,o),n.BAKED_VERTEX_ANIMATION_TEXTURE&&(null===(a=e.bakedVertexAnimationManager)||void 0===a||a.bind(o,n.INSTANCES)),this.useLogarithmicDepth&&r.a0.BindLogDepth(n,o,s),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect)),this._afterBind(e,this._activeEffect),h.update()}getAnimatables(){const t=super.getAnimatables();return this._diffuseTexture&&this._diffuseTexture.animations&&this._diffuseTexture.animations.length>0&&t.push(this._diffuseTexture),this._ambientTexture&&this._ambientTexture.animations&&this._ambientTexture.animations.length>0&&t.push(this._ambientTexture),this._opacityTexture&&this._opacityTexture.animations&&this._opacityTexture.animations.length>0&&t.push(this._opacityTexture),this._reflectionTexture&&this._reflectionTexture.animations&&this._reflectionTexture.animations.length>0&&t.push(this._reflectionTexture),this._emissiveTexture&&this._emissiveTexture.animations&&this._emissiveTexture.animations.length>0&&t.push(this._emissiveTexture),this._specularTexture&&this._specularTexture.animations&&this._specularTexture.animations.length>0&&t.push(this._specularTexture),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&t.push(this._bumpTexture),this._lightmapTexture&&this._lightmapTexture.animations&&this._lightmapTexture.animations.length>0&&t.push(this._lightmapTexture),this._refractionTexture&&this._refractionTexture.animations&&this._refractionTexture.animations.length>0&&t.push(this._refractionTexture),t}getActiveTextures(){const t=super.getActiveTextures();return this._diffuseTexture&&t.push(this._diffuseTexture),this._ambientTexture&&t.push(this._ambientTexture),this._opacityTexture&&t.push(this._opacityTexture),this._reflectionTexture&&t.push(this._reflectionTexture),this._emissiveTexture&&t.push(this._emissiveTexture),this._specularTexture&&t.push(this._specularTexture),this._bumpTexture&&t.push(this._bumpTexture),this._lightmapTexture&&t.push(this._lightmapTexture),this._refractionTexture&&t.push(this._refractionTexture),t}hasTexture(t){return!(!super.hasTexture(t)&&this._diffuseTexture!==t&&this._ambientTexture!==t&&this._opacityTexture!==t&&this._reflectionTexture!==t&&this._emissiveTexture!==t&&this._specularTexture!==t&&this._bumpTexture!==t&&this._lightmapTexture!==t&&this._refractionTexture!==t)}dispose(t,e){var i,a,s,n,o,c,h,d,u;e&&(null===(i=this._diffuseTexture)||void 0===i||i.dispose(),null===(a=this._ambientTexture)||void 0===a||a.dispose(),null===(s=this._opacityTexture)||void 0===s||s.dispose(),null===(n=this._reflectionTexture)||void 0===n||n.dispose(),null===(o=this._emissiveTexture)||void 0===o||o.dispose(),null===(c=this._specularTexture)||void 0===c||c.dispose(),null===(h=this._bumpTexture)||void 0===h||h.dispose(),null===(d=this._lightmapTexture)||void 0===d||d.dispose(),null===(u=this._refractionTexture)||void 0===u||u.dispose()),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(t,e)}clone(t){const e=r.j.Clone(()=>new v(t,this.getScene()),this);return e.name=t,e.id=t,this.stencil.copyTo(e.stencil),e}static Parse(t,e,i){const a=r.j.Parse(()=>new v(t.name,e),t,e,i);return t.stencil&&a.stencil.parse(t.stencil,e,i),a}static get DiffuseTextureEnabled(){return D.DiffuseTextureEnabled}static set DiffuseTextureEnabled(t){D.DiffuseTextureEnabled=t}static get DetailTextureEnabled(){return D.DetailTextureEnabled}static set DetailTextureEnabled(t){D.DetailTextureEnabled=t}static get AmbientTextureEnabled(){return D.AmbientTextureEnabled}static set AmbientTextureEnabled(t){D.AmbientTextureEnabled=t}static get OpacityTextureEnabled(){return D.OpacityTextureEnabled}static set OpacityTextureEnabled(t){D.OpacityTextureEnabled=t}static get ReflectionTextureEnabled(){return D.ReflectionTextureEnabled}static set ReflectionTextureEnabled(t){D.ReflectionTextureEnabled=t}static get EmissiveTextureEnabled(){return D.EmissiveTextureEnabled}static set EmissiveTextureEnabled(t){D.EmissiveTextureEnabled=t}static get SpecularTextureEnabled(){return D.SpecularTextureEnabled}static set SpecularTextureEnabled(t){D.SpecularTextureEnabled=t}static get BumpTextureEnabled(){return D.BumpTextureEnabled}static set BumpTextureEnabled(t){D.BumpTextureEnabled=t}static get LightmapTextureEnabled(){return D.LightmapTextureEnabled}static set LightmapTextureEnabled(t){D.LightmapTextureEnabled=t}static get RefractionTextureEnabled(){return D.RefractionTextureEnabled}static set RefractionTextureEnabled(t){D.RefractionTextureEnabled=t}static get ColorGradingTextureEnabled(){return D.ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(t){D.ColorGradingTextureEnabled=t}static get FresnelEnabled(){return D.FresnelEnabled}static set FresnelEnabled(t){D.FresnelEnabled=t}}(0,r._)([(0,r.m)("diffuseTexture")],v.prototype,"_diffuseTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesAndMiscDirty")],v.prototype,"diffuseTexture",void 0),(0,r._)([(0,r.m)("ambientTexture")],v.prototype,"_ambientTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"ambientTexture",void 0),(0,r._)([(0,r.m)("opacityTexture")],v.prototype,"_opacityTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesAndMiscDirty")],v.prototype,"opacityTexture",void 0),(0,r._)([(0,r.m)("reflectionTexture")],v.prototype,"_reflectionTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"reflectionTexture",void 0),(0,r._)([(0,r.m)("emissiveTexture")],v.prototype,"_emissiveTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"emissiveTexture",void 0),(0,r._)([(0,r.m)("specularTexture")],v.prototype,"_specularTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"specularTexture",void 0),(0,r._)([(0,r.m)("bumpTexture")],v.prototype,"_bumpTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"bumpTexture",void 0),(0,r._)([(0,r.m)("lightmapTexture")],v.prototype,"_lightmapTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"lightmapTexture",void 0),(0,r._)([(0,r.m)("refractionTexture")],v.prototype,"_refractionTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"refractionTexture",void 0),(0,r._)([(0,r.k)("ambient")],v.prototype,"ambientColor",void 0),(0,r._)([(0,r.k)("diffuse")],v.prototype,"diffuseColor",void 0),(0,r._)([(0,r.k)("specular")],v.prototype,"specularColor",void 0),(0,r._)([(0,r.k)("emissive")],v.prototype,"emissiveColor",void 0),(0,r._)([(0,r.f)()],v.prototype,"specularPower",void 0),(0,r._)([(0,r.f)("useAlphaFromDiffuseTexture")],v.prototype,"_useAlphaFromDiffuseTexture",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesAndMiscDirty")],v.prototype,"useAlphaFromDiffuseTexture",void 0),(0,r._)([(0,r.f)("useEmissiveAsIllumination")],v.prototype,"_useEmissiveAsIllumination",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useEmissiveAsIllumination",void 0),(0,r._)([(0,r.f)("linkEmissiveWithDiffuse")],v.prototype,"_linkEmissiveWithDiffuse",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"linkEmissiveWithDiffuse",void 0),(0,r._)([(0,r.f)("useSpecularOverAlpha")],v.prototype,"_useSpecularOverAlpha",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useSpecularOverAlpha",void 0),(0,r._)([(0,r.f)("useReflectionOverAlpha")],v.prototype,"_useReflectionOverAlpha",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useReflectionOverAlpha",void 0),(0,r._)([(0,r.f)("disableLighting")],v.prototype,"_disableLighting",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsLightsDirty")],v.prototype,"disableLighting",void 0),(0,r._)([(0,r.f)("useObjectSpaceNormalMap")],v.prototype,"_useObjectSpaceNormalMap",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useObjectSpaceNormalMap",void 0),(0,r._)([(0,r.f)("useParallax")],v.prototype,"_useParallax",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useParallax",void 0),(0,r._)([(0,r.f)("useParallaxOcclusion")],v.prototype,"_useParallaxOcclusion",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useParallaxOcclusion",void 0),(0,r._)([(0,r.f)()],v.prototype,"parallaxScaleBias",void 0),(0,r._)([(0,r.f)("roughness")],v.prototype,"_roughness",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"roughness",void 0),(0,r._)([(0,r.f)()],v.prototype,"indexOfRefraction",void 0),(0,r._)([(0,r.f)()],v.prototype,"invertRefractionY",void 0),(0,r._)([(0,r.f)()],v.prototype,"alphaCutOff",void 0),(0,r._)([(0,r.f)("useLightmapAsShadowmap")],v.prototype,"_useLightmapAsShadowmap",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useLightmapAsShadowmap",void 0),(0,r._)([(0,r.ac)("diffuseFresnelParameters")],v.prototype,"_diffuseFresnelParameters",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsFresnelDirty")],v.prototype,"diffuseFresnelParameters",void 0),(0,r._)([(0,r.ac)("opacityFresnelParameters")],v.prototype,"_opacityFresnelParameters",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsFresnelAndMiscDirty")],v.prototype,"opacityFresnelParameters",void 0),(0,r._)([(0,r.ac)("reflectionFresnelParameters")],v.prototype,"_reflectionFresnelParameters",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsFresnelDirty")],v.prototype,"reflectionFresnelParameters",void 0),(0,r._)([(0,r.ac)("refractionFresnelParameters")],v.prototype,"_refractionFresnelParameters",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsFresnelDirty")],v.prototype,"refractionFresnelParameters",void 0),(0,r._)([(0,r.ac)("emissiveFresnelParameters")],v.prototype,"_emissiveFresnelParameters",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsFresnelDirty")],v.prototype,"emissiveFresnelParameters",void 0),(0,r._)([(0,r.f)("useReflectionFresnelFromSpecular")],v.prototype,"_useReflectionFresnelFromSpecular",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsFresnelDirty")],v.prototype,"useReflectionFresnelFromSpecular",void 0),(0,r._)([(0,r.f)("useGlossinessFromSpecularMapAlpha")],v.prototype,"_useGlossinessFromSpecularMapAlpha",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"useGlossinessFromSpecularMapAlpha",void 0),(0,r._)([(0,r.f)("maxSimultaneousLights")],v.prototype,"_maxSimultaneousLights",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsLightsDirty")],v.prototype,"maxSimultaneousLights",void 0),(0,r._)([(0,r.f)("invertNormalMapX")],v.prototype,"_invertNormalMapX",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"invertNormalMapX",void 0),(0,r._)([(0,r.f)("invertNormalMapY")],v.prototype,"_invertNormalMapY",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"invertNormalMapY",void 0),(0,r._)([(0,r.f)("twoSidedLighting")],v.prototype,"_twoSidedLighting",void 0),(0,r._)([(0,r.l)("_markAllSubMeshesAsTexturesDirty")],v.prototype,"twoSidedLighting",void 0),(0,r._)([(0,r.f)()],v.prototype,"useLogarithmicDepth",null),(0,r.r)("BABYLON.StandardMaterial",v),r.S.DefaultMaterialFactory=l=>new v("default material",l),r.x.IncludesShadersStore.imageProcessingCompatibility="#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));\n#endif\n",r.x.ShadersStore.shadowOnlyPixelShader="precision highp float;\nuniform vec4 vEyePosition;\nuniform float alpha;\nuniform vec3 shadowColor;\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=vec3(1.0,1.0,1.0);\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);\nlightingInfo info;\nfloat shadow=1.;\nfloat glossiness=0.;\n#include<lightFragment>[0..1]\nvec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);\n#include<fogFragment>\ngl_FragColor=color;\n#include<imageProcessingCompatibility>\n#define CUSTOM_FRAGMENT_MAIN_END\n}",r.x.ShadersStore.shadowOnlyVertexShader="precision highp float;\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\nuniform mat4 view;\nuniform mat4 viewProjection;\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#ifdef VERTEXCOLOR\nvarying vec4 vColor;\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\ngl_Position=viewProjection*worldPos;\nvPositionW=vec3(worldPos);\n#ifdef NORMAL\nvNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n#define CUSTOM_VERTEX_MAIN_END\n}\n";class Hs extends Re{constructor(){super(),this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.INSTANCES=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.rebuild()}}class me extends Je{constructor(t,e){super(t,e),this._needAlphaBlending=!0,this.shadowColor=r.h.Black()}needAlphaBlending(){return this._needAlphaBlending}needAlphaTesting(){return!1}getAlphaTestTexture(){return null}get activeLight(){return this._activeLight}set activeLight(t){this._activeLight=t}_getFirstShadowLightForMesh(t){for(const e of t.lightSources)if(e.shadowEnabled)return e;return null}isReadyForSubMesh(t,e,i){var a;if(this.isFrozen&&e.effect&&e.effect._wasPreviouslyReady&&e.effect._wasPreviouslyUsingInstances===i)return!0;e.materialDefines||(e.materialDefines=new Hs);const s=e.materialDefines,n=this.getScene();if(this._isReadyForSubMesh(e))return!0;const o=n.getEngine();if(this._activeLight)for(const h of t.lightSources)if(h.shadowEnabled){if(this._activeLight===h)break;const d=t.lightSources.indexOf(this._activeLight);-1!==d&&(t.lightSources.splice(d,1),t.lightSources.splice(0,0,this._activeLight));break}r.a0.PrepareDefinesForFrameBoundValues(n,o,this,s,!!i),r.a0.PrepareDefinesForMisc(t,n,!1,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(t),s),s._needNormals=r.a0.PrepareDefinesForLights(n,t,s,!1,1);const c=null===(a=this._getFirstShadowLightForMesh(t))||void 0===a?void 0:a.getShadowGenerator();if(this._needAlphaBlending=!0,c&&c.getClassName&&"CascadedShadowGenerator"===c.getClassName()&&(this._needAlphaBlending=!c.autoCalcDepthBounds),r.a0.PrepareDefinesForAttributes(t,s,!1,!0),s.isDirty){s.markAsProcessed(),n.resetCachedMaterial();const h=new Be;s.FOG&&h.addFallback(1,"FOG"),r.a0.HandleFallbacksForShadows(s,h,1),s.NUM_BONE_INFLUENCERS>0&&h.addCPUSkinningFallback(0,t),s.IMAGEPROCESSINGPOSTPROCESS=n.imageProcessingConfiguration.applyByPostProcess;const d=[r.z.PositionKind];s.NORMAL&&d.push(r.z.NormalKind),r.a0.PrepareAttributesForBones(d,t,s,h),r.a0.PrepareAttributesForInstances(d,s);const u="shadowOnly",f=s.toString(),p=["world","view","viewProjection","vEyePosition","vLightsType","vFogInfos","vFogColor","pointSize","alpha","shadowColor","mBones"],m=new Array,S=new Array;(0,r.a3)(p),r.a0.PrepareUniformsAndSamplersList({uniformsNames:p,uniformBuffersNames:S,samplers:m,defines:s,maxSimultaneousLights:1}),e.setEffect(n.getEngine().createEffect(u,{attributes:d,uniformsNames:p,uniformBuffersNames:S,samplers:m,defines:f,fallbacks:h,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:1}},o),s,this._materialContext)}return!(!e.effect||!e.effect.isReady()||(s._renderId=n.getRenderId(),e.effect._wasPreviouslyReady=!0,e.effect._wasPreviouslyUsingInstances=!!i,0))}bindForSubMesh(t,e,i){const a=this.getScene(),s=i.materialDefines;if(!s)return;const n=i.effect;if(n){if(this._activeEffect=n,this.bindOnlyWorldMatrix(t),this._activeEffect.setMatrix("viewProjection",a.getTransformMatrix()),r.a0.BindBonesParameters(e,this._activeEffect),this._mustRebind(a,n)&&((0,r.a1)(n,this,a),this.pointsCloud&&this._activeEffect.setFloat("pointSize",this.pointSize),this._activeEffect.setFloat("alpha",this.alpha),this._activeEffect.setColor3("shadowColor",this.shadowColor),a.bindEyePosition(n)),a.lightsEnabled){r.a0.BindLights(a,e,this._activeEffect,s,1);const o=this._getFirstShadowLightForMesh(e);o&&(o._renderId=-1)}(a.fogEnabled&&e.applyFog&&a.fogMode!==r.S.FOGMODE_NONE||s.SHADOWCSM0)&&this._activeEffect.setMatrix("view",a.getViewMatrix()),r.a0.BindFogParameters(a,e,this._activeEffect),this._afterBind(e,this._activeEffect)}}clone(t){return r.j.Clone(()=>new me(t,this.getScene()),this)}serialize(){const t=super.serialize();return t.customType="BABYLON.ShadowOnlyMaterial",t}getClassName(){return"ShadowOnlyMaterial"}static Parse(t,e,i){return r.j.Parse(()=>new me(t.name,e),t,e,i)}}(0,r.r)("BABYLON.ShadowOnlyMaterial",me);const Ys={aspect:2,enableDebugging:!1,enableShadows:!0};class Zs{constructor(t){ne(this,"size",9.5),this.config={...Ys,...t},this.create()}create(t){this.destroy(),Object.assign(this.config,t);const{aspect:e,enableDebugging:i,enableShadows:a}=this.config;this.box=new r.ad("diceBox");let n=new me("shadowOnly",this.config.scene);n.alpha=a?1:0,i&&(n=new v("diceBox_material"),n.alpha=.7,n.diffuseColor=new r.h(1,1,0));const o=ue("ground",{width:2*this.size,height:1,depth:2*this.size},this.config.scene);if(o.scaling=new r.V(e,1,1),o.material=n,o.receiveShadows=!0,o.setParent(this.box),i){const c=ue("wallTop",{width:this.size,height:30,depth:1},this.config.scene);c.position.y=15,c.position.z=this.size/-2,c.scaling=new r.V(e,1,1),c.material=n,c.setParent(this.box);const h=ue("wallRight",{width:1,height:30,depth:this.size},this.config.scene);h.position.x=this.size*e/2,h.position.y=15,h.material=n,h.setParent(this.box);const d=ue("wallBottom",{width:this.size,height:30,depth:1},this.config.scene);d.position.y=15,d.position.z=this.size/2,d.scaling=new r.V(e,1,1),d.material=n,d.setParent(this.box);const u=ue("wallLeft",{width:1,height:30,depth:this.size},this.config.scene);u.position.x=this.size*e/-2,u.position.y=15,u.material=n,u.setParent(this.box)}}destroy(){this.box&&this.box.dispose()}}class js{constructor(){}}let xe=(()=>{class l extends v{AttachAfterBind(e,i){if(this._newUniformInstances)for(const a in this._newUniformInstances){const s=a.toString().split("-");"vec2"==s[0]?i.setVector2(s[1],this._newUniformInstances[a]):"vec3"==s[0]?i.setVector3(s[1],this._newUniformInstances[a]):"vec4"==s[0]?i.setVector4(s[1],this._newUniformInstances[a]):"mat4"==s[0]?i.setMatrix(s[1],this._newUniformInstances[a]):"float"==s[0]&&i.setFloat(s[1],this._newUniformInstances[a])}if(this._newSamplerInstances)for(const a in this._newSamplerInstances){const s=a.toString().split("-");"sampler2D"==s[0]&&this._newSamplerInstances[a].isReady&&this._newSamplerInstances[a].isReady()&&i.setTexture(s[1],this._newSamplerInstances[a])}}ReviewUniform(e,i){if("uniform"==e&&this._newUniforms)for(let a=0;a<this._newUniforms.length;a++)-1==this._customUniform[a].indexOf("sampler")&&i.push(this._newUniforms[a].replace(/\[\d*\]/g,""));if("sampler"==e&&this._newUniforms)for(let a=0;a<this._newUniforms.length;a++)-1!=this._customUniform[a].indexOf("sampler")&&i.push(this._newUniforms[a].replace(/\[\d*\]/g,""));return i}Builder(e,i,a,s,n,o){if(o&&this._customAttributes&&this._customAttributes.length>0&&o.push(...this._customAttributes),this.ReviewUniform("uniform",i),this.ReviewUniform("sampler",s),this._isCreatedShader)return this._createdShaderName;this._isCreatedShader=!1,l.ShaderIndexer++;const c="custom_"+l.ShaderIndexer,h=this._afterBind.bind(this);return this._afterBind=(d,u)=>{if(u){this.AttachAfterBind(d,u);try{h(d,u)}catch{}}},r.F.ShadersStore[c+"VertexShader"]=this.VertexShader.replace("#define CUSTOM_VERTEX_BEGIN",this.CustomParts.Vertex_Begin?this.CustomParts.Vertex_Begin:"").replace("#define CUSTOM_VERTEX_DEFINITIONS",(this._customUniform?this._customUniform.join("\n"):"")+(this.CustomParts.Vertex_Definitions?this.CustomParts.Vertex_Definitions:"")).replace("#define CUSTOM_VERTEX_MAIN_BEGIN",this.CustomParts.Vertex_MainBegin?this.CustomParts.Vertex_MainBegin:"").replace("#define CUSTOM_VERTEX_UPDATE_POSITION",this.CustomParts.Vertex_Before_PositionUpdated?this.CustomParts.Vertex_Before_PositionUpdated:"").replace("#define CUSTOM_VERTEX_UPDATE_NORMAL",this.CustomParts.Vertex_Before_NormalUpdated?this.CustomParts.Vertex_Before_NormalUpdated:"").replace("#define CUSTOM_VERTEX_MAIN_END",this.CustomParts.Vertex_MainEnd?this.CustomParts.Vertex_MainEnd:""),this.CustomParts.Vertex_After_WorldPosComputed&&(r.F.ShadersStore[c+"VertexShader"]=r.F.ShadersStore[c+"VertexShader"].replace("#define CUSTOM_VERTEX_UPDATE_WORLDPOS",this.CustomParts.Vertex_After_WorldPosComputed)),r.F.ShadersStore[c+"PixelShader"]=this.FragmentShader.replace("#define CUSTOM_FRAGMENT_BEGIN",this.CustomParts.Fragment_Begin?this.CustomParts.Fragment_Begin:"").replace("#define CUSTOM_FRAGMENT_MAIN_BEGIN",this.CustomParts.Fragment_MainBegin?this.CustomParts.Fragment_MainBegin:"").replace("#define CUSTOM_FRAGMENT_DEFINITIONS",(this._customUniform?this._customUniform.join("\n"):"")+(this.CustomParts.Fragment_Definitions?this.CustomParts.Fragment_Definitions:"")).replace("#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE",this.CustomParts.Fragment_Custom_Diffuse?this.CustomParts.Fragment_Custom_Diffuse:"").replace("#define CUSTOM_FRAGMENT_UPDATE_ALPHA",this.CustomParts.Fragment_Custom_Alpha?this.CustomParts.Fragment_Custom_Alpha:"").replace("#define CUSTOM_FRAGMENT_BEFORE_LIGHTS",this.CustomParts.Fragment_Before_Lights?this.CustomParts.Fragment_Before_Lights:"").replace("#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR",this.CustomParts.Fragment_Before_FragColor?this.CustomParts.Fragment_Before_FragColor:"").replace("#define CUSTOM_FRAGMENT_MAIN_END",this.CustomParts.Fragment_MainEnd?this.CustomParts.Fragment_MainEnd:""),this.CustomParts.Fragment_Before_Fog&&(r.F.ShadersStore[c+"PixelShader"]=r.F.ShadersStore[c+"PixelShader"].replace("#define CUSTOM_FRAGMENT_BEFORE_FOG",this.CustomParts.Fragment_Before_Fog)),this._isCreatedShader=!0,this._createdShaderName=c,c}constructor(e,i){super(e,i),this.CustomParts=new js,this.customShaderNameResolve=this.Builder,this.FragmentShader=r.F.ShadersStore.defaultPixelShader,this.VertexShader=r.F.ShadersStore.defaultVertexShader}AddUniform(e,i,a){return this._customUniform||(this._customUniform=new Array,this._newUniforms=new Array,this._newSamplerInstances={},this._newUniformInstances={}),a&&(-1!=i.indexOf("sampler")?this._newSamplerInstances[i+"-"+e]=a:this._newUniformInstances[i+"-"+e]=a),this._customUniform.push("uniform "+i+" "+e+";"),this._newUniforms.push(e),this}AddAttribute(e){return this._customAttributes||(this._customAttributes=[]),this._customAttributes.push(e),this}Fragment_Begin(e){return this.CustomParts.Fragment_Begin=e,this}Fragment_Definitions(e){return this.CustomParts.Fragment_Definitions=e,this}Fragment_MainBegin(e){return this.CustomParts.Fragment_MainBegin=e,this}Fragment_MainEnd(e){return this.CustomParts.Fragment_MainEnd=e,this}Fragment_Custom_Diffuse(e){return this.CustomParts.Fragment_Custom_Diffuse=e.replace("result","diffuseColor"),this}Fragment_Custom_Alpha(e){return this.CustomParts.Fragment_Custom_Alpha=e.replace("result","alpha"),this}Fragment_Before_Lights(e){return this.CustomParts.Fragment_Before_Lights=e,this}Fragment_Before_Fog(e){return this.CustomParts.Fragment_Before_Fog=e,this}Fragment_Before_FragColor(e){return this.CustomParts.Fragment_Before_FragColor=e.replace("result","color"),this}Vertex_Begin(e){return this.CustomParts.Vertex_Begin=e,this}Vertex_Definitions(e){return this.CustomParts.Vertex_Definitions=e,this}Vertex_MainBegin(e){return this.CustomParts.Vertex_MainBegin=e,this}Vertex_Before_PositionUpdated(e){return this.CustomParts.Vertex_Before_PositionUpdated=e.replace("result","positionUpdated"),this}Vertex_Before_NormalUpdated(e){return this.CustomParts.Vertex_Before_NormalUpdated=e.replace("result","normalUpdated"),this}Vertex_After_WorldPosComputed(e){return this.CustomParts.Vertex_After_WorldPosComputed=e,this}Vertex_MainEnd(e){return this.CustomParts.Vertex_MainEnd=e,this}}return l.ShaderIndexer=1,l})();(0,r.r)("BABYLON.CustomMaterial",xe),xe.prototype.clone=function(l){const t=this,e=r.j.Clone(()=>new xe(l,this.getScene()),this);return e.name=l,e.id=l,e.CustomParts.Fragment_Begin=t.CustomParts.Fragment_Begin,e.CustomParts.Fragment_Definitions=t.CustomParts.Fragment_Definitions,e.CustomParts.Fragment_MainBegin=t.CustomParts.Fragment_MainBegin,e.CustomParts.Fragment_Custom_Diffuse=t.CustomParts.Fragment_Custom_Diffuse,e.CustomParts.Fragment_Before_Lights=t.CustomParts.Fragment_Before_Lights,e.CustomParts.Fragment_Before_Fog=t.CustomParts.Fragment_Before_Fog,e.CustomParts.Fragment_Custom_Alpha=t.CustomParts.Fragment_Custom_Alpha,e.CustomParts.Fragment_Before_FragColor=t.CustomParts.Fragment_Before_FragColor,e.CustomParts.Vertex_Begin=t.CustomParts.Vertex_Begin,e.CustomParts.Vertex_Definitions=t.CustomParts.Vertex_Definitions,e.CustomParts.Vertex_MainBegin=t.CustomParts.Vertex_MainBegin,e.CustomParts.Vertex_Before_PositionUpdated=t.CustomParts.Vertex_Before_PositionUpdated,e.CustomParts.Vertex_Before_NormalUpdated=t.CustomParts.Vertex_Before_NormalUpdated,e.CustomParts.Vertex_After_WorldPosComputed=t.CustomParts.Vertex_After_WorldPosComputed,e.CustomParts.Vertex_MainEnd=t.CustomParts.Vertex_MainEnd,e};class Qs{constructor(t){ne(this,"loadedThemes",{}),ne(this,"themeData",{}),this.scene=t.scene}loadStandardMaterial(t){var e=this;return(0,Q.Z)(function*(){const{theme:i,material:a}=t,s=new v(i,e.scene);a.diffuseTexture&&(s.diffuseTexture=yield e.getTexture("diffuse",t)),a.bumpTexture&&(s.bumpTexture=yield e.getTexture("bump",t)),a.specularTexture&&(s.specularTexture=yield e.getTexture("specular",t)),s.allowShaderHotSwapping=!1})()}loadColorMaterial(t){var e=this;return(0,Q.Z)(function*(){const{theme:i,material:a}=t,s=new xe(i+"_light",e.scene),n=(0,tt.d)(t);a.diffuseTexture&&a.diffuseTexture.light&&(n.material.diffuseTexture=t.material.diffuseTexture.light,s.diffuseTexture=yield e.getTexture("diffuse",n)),a.bumpTexture&&(s.bumpTexture=yield e.getTexture("bump",t)),a.specularTexture&&(s.specularTexture=yield e.getTexture("specular",t)),s.allowShaderHotSwapping=!1,s.Vertex_Definitions("\n      attribute vec3 customColor;\n      varying vec3 vColor;\n    ").Vertex_MainEnd("\n      vColor = customColor;\n    ").Fragment_Definitions("\n      varying vec3 vColor;\n    ").Fragment_Custom_Diffuse("\n      baseColor.rgb = mix(vColor.rgb, baseColor.rgb, baseColor.a);\n    "),s.AddAttribute("customColor");const o=s.clone(i+"_dark");a.diffuseTexture&&a.diffuseTexture.dark&&(n.material.diffuseTexture=t.material.diffuseTexture.dark,o.diffuseTexture=yield e.getTexture("diffuse",n)),o.AddAttribute("customColor")})()}getTexture(t,e){var i=this;return(0,Q.Z)(function*(){const{basePath:a,material:s,theme:n}=e;let o;const c=t+"Level",h=t+"Texture";try{switch(t){case"diffuse":case"bump":o=yield i.importTextureAsync(`${a}/${s[h]}`,n),s[c]&&(o.level=s[c]);break;case"specular":o=yield i.importTextureAsync(`${a}/${s[h]}`,n),s.specularPower&&(o.specularPower=s.specularPower);break;default:throw new Error(`Texture type: ${t} is not supported`)}}catch(d){console.error(d)}return o})()}importTextureAsync(t,e){var i=this;return(0,Q.Z)(function*(){return new Promise((a,s)=>{let n=t.match(/^(.*\/)(.*)$/),o=new g(t,i.scene,void 0,!0,void 0,()=>a(o),()=>s(`Unable to load texture '${n[2]}' for theme: '${e}'. Check that your assetPath is configured correctly and that the files exist at path: '${n[1]}'`))}).catch(a=>console.error(a))})()}load(t){var e=this;return(0,Q.Z)(function*(){const{material:i}=t;"color"===i.type?yield e.loadColorMaterial(t):"standard"===i.type?yield e.loadStandardMaterial(t):console.error(`Material type: ${i.type} not supported`)})()}}var V,ge,re,ve,J,K,X,Xe,ee,Me,Ce,j,Ae,ze,et;class Ks{constructor(t){k(this,ze),ne(this,"config"),ne(this,"initialized",!1),k(this,V,{}),k(this,ge,0),k(this,re,0),k(this,ve,[]),k(this,J,void 0),k(this,K,void 0),k(this,X,void 0),k(this,Xe,void 0),k(this,ee,void 0),k(this,Me,void 0),k(this,Ce,void 0),k(this,j,void 0),k(this,Ae,{}),ne(this,"noop",()=>{}),ne(this,"diceBufferView",new Float32Array(8e3)),this.onInitComplete=t.onInitComplete||this.noop,this.onThemeLoaded=t.onThemeLoaded||this.noop,this.onRollResult=t.onRollResult||this.noop,this.onRollComplete=t.onRollComplete||this.noop,this.onDieRemoved=t.onDieRemoved||this.noop,this.initialized=this.initScene(t)}initScene(t){var e=this;return(0,Q.Z)(function*(){H(e,J,t.canvas),M(e,J).width=t.width,M(e,J).height=t.height,e.config=t.options,H(e,K,function at(l){return new r.E(l,!0,{preserveDrawingBuffer:!0,stencil:!0})}(M(e,J))),H(e,X,function ot(l){const{engine:t}=l,e=new r.S(t);e.clearColor=new r.C(0,0,0,0),e.pointerMovePredicate=()=>!1,e.pointerDownPredicate=()=>!1,e.pointerUpPredicate=()=>!1,e.clearCachedVertexData(),e.themeData={};const i=oe.LowDegradationAllowed();return i.optimizations=i.optimizations.splice(1),i.targetFrameRate=60,Fe.OptimizeAsync(e,i),e}({engine:M(e,K)})),H(e,Xe,function lt(l){const{scene:t}=l;let e;return e=new B("TargetCamera1",new r.V(0,36.5,0),t),e.fov=.25,e.minZ=5,e.maxZ=37.5,e.setTarget(r.V.Zero()),e}({engine:M(e,K),scene:M(e,X)})),H(e,ee,Ke({enableShadows:e.config.enableShadows,shadowTransparency:e.config.shadowTransparency,intensity:e.config.lightIntensity,scene:M(e,X)})),H(e,Me,new Zs({enableShadows:e.config.enableShadows,aspect:M(e,J).width/M(e,J).height,lights:M(e,ee),scene:M(e,X)})),H(e,Ce,new Qs({scene:M(e,X)})),e.onInitComplete()})()}connect(t){H(this,j,t),M(this,j).postMessage({action:"initBuffer",diceBuffer:this.diceBufferView.buffer},[this.diceBufferView.buffer]),M(this,j).onmessage=e=>{"updates"===e.data.action?this.updatesFromPhysics(e.data.diceBuffer):console.error("action from physicsWorker not found in offscreen worker")}}updateConfig(t){const e=this.config;this.config=t,e.enableShadows!==this.config.enableShadows&&(Object.values(M(this,ee)).forEach(i=>i.dispose()),H(this,ee,Ke({enableShadows:this.config.enableShadows,shadowTransparency:this.config.shadowTransparency,intensity:this.config.lightIntensity,scene:M(this,X)}))),e.scale!==this.config.scale&&Object.values(M(this,V)).forEach(({mesh:i})=>{var a;if(i){const{x:s=1,y:n=1,z:o=1}=null==(a=i?.metadata)?void 0:a.baseScale;i.scaling=new r.V(this.config.scale*s,this.config.scale*n,this.config.scale*o)}}),e.shadowTransparency!==this.config.shadowTransparency&&(M(this,ee).directional.shadowGenerator.darkness=this.config.shadowTransparency),e.lightIntensity!==this.config.lightIntensity&&(M(this,ee).directional.intensity=.65*this.config.lightIntensity,M(this,ee).hemispheric.intensity=.4*this.config.lightIntensity)}render(t){M(this,K).runRenderLoop(this.renderLoop.bind(this)),M(this,j).postMessage({action:"resumeSimulation",newStartPoint:t})}renderLoop(){M(this,re)&&M(this,re)===Object.keys(M(this,V)).length?(M(this,K).stopRenderLoop(),M(this,j).postMessage({action:"stopSimulation"}),this.onRollComplete()):M(this,X).render()}loadTheme(t){var e=this;return(0,Q.Z)(function*(){const{theme:i,basePath:a,material:s,meshFilePath:n,meshName:o}=t;if(yield M(e,Ce).load({theme:i,basePath:a,material:s}),!Object.keys(M(e,Ae)).includes(o)){M(e,Ae)[o]=n;const c=yield r.D.loadModels({meshFilePath:n,meshName:o},M(e,X));if(!c)throw new Error("No colliders returned from the 3D mesh file. Low poly colliders are expected to be in the same file as the high poly dice and the mesh name contains the word 'collider'");M(e,j).postMessage({action:"loadModels",options:{colliders:c,meshName:o}})}e.onThemeLoaded({id:i})})()}clear(){!Object.keys(M(this,V)).length&&!M(this,re)||(this.diceBufferView.byteLength&&this.diceBufferView.fill(0),M(this,ve).forEach(t=>clearTimeout(t)),M(this,K).stopRenderLoop(),Object.values(M(this,V)).forEach(t=>{t.mesh&&t.mesh.dispose()}),H(this,V,{}),H(this,ge,0),H(this,re,0),M(this,X).render())}add(t){r.D.loadDie(t,M(this,X)).then(e=>{M(this,ve).push(setTimeout(()=>{((l,t,e)=>(Ie(this,t,"access private method"),e))(0,ze,et).call(this,e)},pe(this,ge)._++*this.config.delay))})}addNonDie(t){0===M(this,K).activeRenderLoops.length&&this.render(!1);const{id:e,value:i,...a}=t,s={id:e,value:i,config:a};M(this,V)[e]=s,setTimeout(()=>{M(this,ve).push(setTimeout(()=>{this.handleAsleep(s)},pe(this,ge)._++*this.config.delay))},10)}remove(t){const e=M(this,V)[t.id];e.hasOwnProperty("d10Instance")&&(M(this,V)[e.d10Instance.id].mesh&&(M(this,V)[e.d10Instance.id].mesh.dispose(),M(this,j).postMessage({action:"removeDie",id:e.d10Instance.id})),delete M(this,V)[e.d10Instance.id],pe(this,re)._--),M(this,V)[t.id].mesh&&M(this,V)[t.id].mesh.dispose(),delete M(this,V)[t.id],pe(this,re)._--,M(this,X).render(),this.onDieRemoved(t.rollId)}updatesFromPhysics(t){this.diceBufferView=new Float32Array(t);let e=1;for(let i=0,a=this.diceBufferView[0];i<a;i++){if(!Object.keys(M(this,V)).length)continue;const s=M(this,V)[`${this.diceBufferView[e]}`];if(!s){console.log("Error: die not available in scene to animate");break}if(-1===this.diceBufferView[e+1])this.handleAsleep(s);else{const h=this.diceBufferView[e+4],d=this.diceBufferView[e+5],u=this.diceBufferView[e+6],f=this.diceBufferView[e+7];s.mesh.position.set(this.diceBufferView[e+1],this.diceBufferView[e+2],this.diceBufferView[e+3]),s.mesh.rotationQuaternion.set(h,d,u,f)}e+=8}requestAnimationFrame(()=>{M(this,j).postMessage({action:"stepSimulation",diceBuffer:this.diceBufferView.buffer},[this.diceBufferView.buffer])})}handleAsleep(t){var e=this;return(0,Q.Z)(function*(){var i,a;if(t.asleep=!0,yield r.D.getRollResult(t,M(e,X)),t.d10Instance||t.dieParent){if(null!=(i=t?.d10Instance)&&i.asleep||null!=(a=t?.dieParent)&&a.asleep){const s=100===t.config.sides?t:t.dieParent,n=10===t.config.sides?t:t.d10Instance;s.rawValue&&(s.value=s.rawValue),s.rawValue=s.value,s.value=s.value+n.value,e.onRollResult({rollId:s.config.rollId,value:s.value})}}else 10===t.config.sides&&0===t.value&&(t.value=10),e.onRollResult({rollId:t.config.rollId,value:t.value});pe(e,re)._++})()}resize(t){const e=M(this,J).width=t.width,i=M(this,J).height=t.height;M(this,Me).create({aspect:e/i}),M(this,K).resize()}}V=new WeakMap,ge=new WeakMap,re=new WeakMap,ve=new WeakMap,J=new WeakMap,K=new WeakMap,X=new WeakMap,Xe=new WeakMap,ee=new WeakMap,Me=new WeakMap,Ce=new WeakMap,j=new WeakMap,Ae=new WeakMap,ze=new WeakSet,et=function(){var l=(0,Q.Z)(function*(t){0===M(this,K).activeRenderLoops.length&&this.render(t.newStartPoint);const e={...t,assetPath:this.config.assetPath,enableShadows:this.config.enableShadows,scale:this.config.scale,lights:M(this,ee)},i=new r.D(e,M(this,X));return M(this,V)[i.id]=i,M(this,j).postMessage({action:"addDie",options:{sides:t.sides,scale:this.config.scale,id:i.id,newStartPoint:t.newStartPoint,theme:t.theme,meshName:t.meshName}}),100===t.sides&&"single"!==t.data&&(i.d10Instance=yield r.D.loadDie({...e,dieType:"d10",sides:10,id:i.id+1e4},M(this,X)).then(a=>{const s=new r.D(a,M(this,X));return s.dieParent=i,s}),M(this,V)[`${i.d10Instance.id}`]=i.d10Instance,M(this,j).postMessage({action:"addDie",options:{sides:10,scale:this.config.scale,id:i.d10Instance.id,theme:t.theme,meshName:t.meshName}})),i});return function(e){return l.apply(this,arguments)}}()}}]);